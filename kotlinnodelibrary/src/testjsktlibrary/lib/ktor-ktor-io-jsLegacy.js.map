{"version":3,"file":"ktor-ktor-io-jsLegacy.js","sources":["../../../../../ktor-io/common/src/io/ktor/utils/io/ByteChannelSequential.kt","util/Preconditions.kt","kotlin/UShort.kt","kotlin/UInt.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/charsets/Encoding.kt","text/StringBuilder.kt","kotlin/UByte.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/bits/MemoryPrimitivesJs.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/InputArrays.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/Buffers.kt","util/Standard.kt","coroutines/Continuation.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/ByteChannelCtor.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/internal/Require.kt","generated/_ComparisonsJs.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/Buffer.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/ByteReadChannel.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/ByteWriteChannel.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/Builder.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/ChannelLittleEndian.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/Coroutines.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/ReadSession.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/WriterSession.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/bits/MemoryPrimitives.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/internal/Numbers.kt","kotlin/ULong.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/bits/PrimiteArrays.kt","generated/_UArrays.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/bits/MemoryFactoryJs.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/Output.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/AbstractInput.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/bits/MemoryJs.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/PacketDirect.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/Input.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/internal/UTF8.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/AbstractOutput.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/BufferPrimitives.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/BufferCompatibility.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/bits/ByteOrder.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/BufferFactory.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/BytePacketBuilder.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/ByteReadPacket.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/InputPrimitives.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/OutputPrimitives.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/Packet.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/Preview.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/Scanner.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/Strings.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/internal/ChunkBuffer.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/internal/Unsafe.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/errors/Errors.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/internal/AwaitingSlot.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/internal/SequentialCopyTo.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/pool/Pool.kt","../../../../../atomicfu/src/commonMain/kotlin/kotlinx/atomicfu/AtomicFU.common.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/ByteChannelJS.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/ByteChannelSequentialBaseSharedStateJs.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/ConditionJS.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/ExceptionUtilsJs.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/NativeUtilsJs.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/bits/ByteOrderJs.kt","kotlin/numbers_js-v1.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/bits/PrimitiveArraysJs.kt","org.w3c/org.khronos.webgl.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/charsets/CharsetJS.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/js/TextDecoders.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/charsets/DecodeBuffer.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/charsets/ISO88591.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/core/IoBufferJS.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/concurrent/SharedJs.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/core/AbstractInputSharedStateJs.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/core/AbstractOutputSharedStateJs.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/core/BufferSharedStateJs.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/core/ByteOrderJS.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/core/ByteReadPacket.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/core/CloseableJS.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/core/InputArraysJS.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/core/InputJs.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/core/OutputJs.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/core/PacketJS.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/core/ScannerJS.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/core/StringsJS.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/errors/IOException.kt"],"sourcesContent":["package io.ktor.utils.io\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.concurrent.*\nimport io.ktor.utils.io.core.*\nimport io.ktor.utils.io.core.internal.*\nimport io.ktor.utils.io.internal.*\nimport io.ktor.utils.io.pool.*\nimport kotlinx.atomicfu.locks.*\nimport kotlin.math.*\n\n@Deprecated(\"This is going to become internal. Use ByteReadChannel receiver instead.\", level = DeprecationLevel.ERROR)\npublic suspend fun ByteChannelSequentialBase.joinTo(dst: ByteChannelSequentialBase, closeOnEnd: Boolean) {\n    return joinToImpl(dst, closeOnEnd)\n}\n\n@Deprecated(\"This is going to become internal. Use ByteReadChannel receiver instead.\", level = DeprecationLevel.ERROR)\npublic suspend fun ByteChannelSequentialBase.copyTo(\n    dst: ByteChannelSequentialBase,\n    limit: Long = Long.MAX_VALUE\n): Long {\n    return copyToSequentialImpl(dst, limit)\n}\n\nprivate const val EXPECTED_CAPACITY: Long = 4088L\n\n/**\n * Sequential (non-concurrent) byte channel implementation\n */\n@Suppress(\"OverridingDeprecatedMember\")\n@DangerousInternalIoApi\npublic abstract class ByteChannelSequentialBase(\n    initial: IoBuffer,\n    override val autoFlush: Boolean,\n    pool: ObjectPool<ChunkBuffer> = ChunkBuffer.Pool\n) : ByteChannel, ByteReadChannel, ByteWriteChannel, SuspendableReadSession, HasReadSession, HasWriteSession {\n\n    @Suppress(\"unused\", \"DEPRECATION\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public constructor(initial: IoBuffer, autoFlush: Boolean) : this(initial, autoFlush, ChunkBuffer.Pool)\n\n    private val state = ByteChannelSequentialBaseSharedState()\n\n    protected var closed: Boolean\n        get() = state.closed\n        set(value) {\n            state.closed = value\n        }\n\n    protected val writable: BytePacketBuilder = BytePacketBuilder(0, pool)\n    protected val readable: ByteReadPacket = ByteReadPacket(initial, pool)\n\n    private val slot = AwaitingSlot()\n\n    @Suppress(\"NOTHING_TO_INLINE\")\n    private inline fun totalPending(): Int = availableForRead + writable.size\n\n    private val flushSize: Int get() = flushBuffer.size\n\n    override val availableForRead: Int\n        get() = flushSize + readable.remaining.toInt()\n\n    override val availableForWrite: Int\n        get() = maxOf(0, EXPECTED_CAPACITY.toInt() - totalPending())\n\n    override var readByteOrder: ByteOrder\n        get() = state.readByteOrder\n        set(value) {\n            state.readByteOrder = value\n        }\n\n    override var writeByteOrder: ByteOrder\n        get() = state.writeByteOrder\n        set(value) {\n            state.writeByteOrder = value\n        }\n\n    override val isClosedForRead: Boolean\n        get() = closed && readable.isEmpty && flushSize == 0 && writable.isEmpty\n\n    override val isClosedForWrite: Boolean\n        get() = closed\n\n    private var _totalBytesRead: Long\n        get() = state.totalBytesRead\n        set(value) {\n            state.totalBytesRead = value\n        }\n\n    override val totalBytesRead: Long get() = state.totalBytesRead\n\n    private var _totalBytesWritten: Long\n        get() = state.totalBytesWritten\n        set(value) {\n            state.totalBytesWritten = value\n        }\n\n    override val totalBytesWritten: Long get() = state.totalBytesWritten\n\n    final override var closedCause: Throwable?\n        get() = state.closedCause\n        private set(value) {\n            state.closedCause = value\n        }\n\n    private val flushMutex = SynchronizedObject()\n    private val flushBuffer: BytePacketBuilder = BytePacketBuilder()\n\n    internal suspend fun awaitAtLeastNBytesAvailableForWrite(count: Int) {\n        while (availableForWrite < count && !closed) {\n            slot.sleep()\n        }\n    }\n\n    internal suspend fun awaitAtLeastNBytesAvailableForRead(count: Int) {\n        while (availableForRead < count && !closed) {\n            slot.sleep()\n        }\n    }\n\n    override fun flush() {\n        if (writable.isNotEmpty) {\n            flushWrittenBytes()\n            slot.resume()\n        }\n    }\n\n    /**\n     * Send bytes to thread-safe storage.\n     *\n     * This method is writer-only safe.\n     */\n    private fun flushWrittenBytes() {\n        synchronized(flushMutex) {\n            val buffer = writable.stealAll()!!\n            flushBuffer.writeChunkBuffer(buffer)\n        }\n    }\n\n    /**\n     * Take flushed bytes before read.\n     *\n     * This method is reader-only safe.\n     */\n    protected fun prepareFlushedBytes() {\n        synchronized(flushMutex) {\n            readable.unsafeAppend(flushBuffer)\n        }\n    }\n\n    private fun ensureNotClosed() {\n        if (closed) {\n            throw closedCause ?: ClosedWriteChannelException(\"Channel is already closed\")\n        }\n    }\n\n    private fun ensureNotFailed() {\n        closedCause?.let { throw it }\n    }\n\n    private fun ensureNotFailed(closeable: BytePacketBuilder) {\n        closedCause?.let { cause ->\n            closeable.release()\n            throw cause\n        }\n    }\n\n    override suspend fun writeByte(b: Byte) {\n        awaitAtLeastNBytesAvailableForWrite(1)\n        writable.writeByte(b)\n        afterWrite(1)\n    }\n\n    private inline fun <T : Any> reverseWrite(value: () -> T, reversed: () -> T): T {\n        @Suppress(\"DEPRECATION_ERROR\")\n        return if (writeByteOrder == ByteOrder.BIG_ENDIAN) {\n            value()\n        } else {\n            reversed()\n        }\n    }\n\n    override suspend fun writeShort(s: Short) {\n        awaitAtLeastNBytesAvailableForWrite(2)\n        writable.writeShort(reverseWrite({ s }, { s.reverseByteOrder() }))\n        afterWrite(2)\n    }\n\n    override suspend fun writeInt(i: Int) {\n        awaitAtLeastNBytesAvailableForWrite(4)\n        writable.writeInt(reverseWrite({ i }, { i.reverseByteOrder() }))\n        afterWrite(4)\n    }\n\n    override suspend fun writeLong(l: Long) {\n        awaitAtLeastNBytesAvailableForWrite(8)\n        writable.writeLong(reverseWrite({ l }, { l.reverseByteOrder() }))\n        afterWrite(8)\n    }\n\n    override suspend fun writeFloat(f: Float) {\n        awaitAtLeastNBytesAvailableForWrite(4)\n        writable.writeFloat(reverseWrite({ f }, { f.reverseByteOrder() }))\n        afterWrite(4)\n    }\n\n    override suspend fun writeDouble(d: Double) {\n        awaitAtLeastNBytesAvailableForWrite(8)\n        writable.writeDouble(reverseWrite({ d }, { d.reverseByteOrder() }))\n        afterWrite(8)\n    }\n\n    override suspend fun writePacket(packet: ByteReadPacket) {\n        awaitAtLeastNBytesAvailableForWrite(1)\n        val size = packet.remaining.toInt()\n        writable.writePacket(packet)\n        afterWrite(size)\n    }\n\n    override suspend fun writeFully(src: IoBuffer) {\n        writeFully(src as Buffer)\n    }\n\n    override suspend fun writeFully(src: Buffer) {\n        awaitAtLeastNBytesAvailableForWrite(1)\n        val count = src.readRemaining\n        writable.writeFully(src)\n        afterWrite(count)\n    }\n\n    override suspend fun writeFully(src: ByteArray, offset: Int, length: Int) {\n        var currentIndex = offset\n        val endIndex = offset + length\n\n        while (currentIndex < endIndex) {\n            awaitAtLeastNBytesAvailableForWrite(1)\n\n            val bytesCount = min(availableForWrite, endIndex - currentIndex)\n            writable.writeFully(src, currentIndex, bytesCount)\n\n            currentIndex += bytesCount\n            afterWrite(bytesCount)\n        }\n    }\n\n    override suspend fun writeFully(memory: Memory, startIndex: Int, endIndex: Int) {\n        var currentIndex = startIndex\n\n        while (currentIndex < endIndex) {\n            awaitAtLeastNBytesAvailableForWrite(1)\n\n            val bytesCount = min(availableForWrite, endIndex - currentIndex)\n            writable.writeFully(memory, currentIndex, bytesCount)\n\n            currentIndex += bytesCount\n            afterWrite(bytesCount)\n        }\n    }\n\n    override suspend fun writeAvailable(src: IoBuffer): Int {\n        val srcRemaining = src.readRemaining\n        if (srcRemaining == 0) return 0\n        val size = minOf(srcRemaining, availableForWrite)\n\n        return if (size == 0) writeAvailableSuspend(src)\n        else {\n            writable.writeFully(src, size)\n            afterWrite(size)\n            size\n        }\n    }\n\n    override suspend fun writeAvailable(src: ByteArray, offset: Int, length: Int): Int {\n        if (length == 0) return 0\n        val size = minOf(length, availableForWrite)\n\n        return if (size == 0) writeAvailableSuspend(src, offset, length)\n        else {\n            writable.writeFully(src, offset, size)\n            afterWrite(size)\n            size\n        }\n    }\n\n    @ExperimentalIoApi\n    @Suppress(\"DEPRECATION\")\n    override suspend fun writeSuspendSession(visitor: suspend WriterSuspendSession.() -> Unit) {\n        val session = beginWriteSession()\n        visitor(session)\n    }\n\n    @Suppress(\"DEPRECATION\")\n    override fun beginWriteSession(): WriterSuspendSession {\n        return object : WriterSuspendSession {\n            override fun request(min: Int): IoBuffer? {\n                if (availableForWrite == 0) return null\n                return writable.prepareWriteHead(min) as IoBuffer\n            }\n\n            override fun written(n: Int) {\n                writable.afterHeadWrite()\n                afterWrite(n)\n            }\n\n            override fun flush() {\n                this@ByteChannelSequentialBase.flush()\n            }\n\n            override suspend fun tryAwait(n: Int) {\n                if (availableForWrite < n) {\n                    awaitAtLeastNBytesAvailableForWrite(n)\n                }\n            }\n        }\n    }\n\n    override fun endWriteSession(written: Int) {\n        writable.afterHeadWrite()\n        afterWrite(written)\n    }\n\n    override suspend fun readByte(): Byte {\n        return if (readable.isNotEmpty) {\n            readable.readByte().also { afterRead(1) }\n        } else {\n            readByteSlow()\n        }\n    }\n\n    private fun checkClosed(n: Int) {\n        if (closed) {\n            throw closedCause ?: prematureClose(n)\n        }\n    }\n\n    private fun prematureClose(n: Int): Exception {\n        return EOFException(\"$n bytes required but EOF reached\")\n    }\n\n    private suspend fun readByteSlow(): Byte {\n        do {\n            awaitSuspend(1)\n\n            if (readable.isNotEmpty) return readable.readByte().also { afterRead(1) }\n            checkClosed(1)\n        } while (true)\n    }\n\n    override suspend fun readShort(): Short {\n        return if (readable.hasBytes(2)) {\n            readable.readShort().reverseRead().also { afterRead(2) }\n        } else {\n            readShortSlow()\n        }\n    }\n\n    private suspend fun readShortSlow(): Short {\n        readNSlow(2) { return readable.readShort().reverseRead().also { afterRead(2) } }\n    }\n\n    @Deprecated(\"Consider providing consumed count of bytes\", level = DeprecationLevel.ERROR)\n    protected fun afterRead() {\n        afterRead(0)\n    }\n\n    protected fun afterRead(count: Int) {\n        _totalBytesRead += count\n        slot.resume()\n    }\n\n    @Suppress(\"NOTHING_TO_INLINE\", \"DEPRECATION_ERROR\")\n    private inline fun Short.reverseRead(): Short = when {\n        readByteOrder == ByteOrder.BIG_ENDIAN -> this\n        else -> this.reverseByteOrder()\n    }\n\n    @Suppress(\"NOTHING_TO_INLINE\", \"DEPRECATION_ERROR\")\n    private inline fun Int.reverseRead(): Int = when {\n        readByteOrder == ByteOrder.BIG_ENDIAN -> this\n        else -> this.reverseByteOrder()\n    }\n\n    @Suppress(\"NOTHING_TO_INLINE\", \"DEPRECATION_ERROR\")\n    private inline fun Long.reverseRead(): Long = when {\n        readByteOrder == ByteOrder.BIG_ENDIAN -> this\n        else -> this.reverseByteOrder()\n    }\n\n    @Suppress(\"NOTHING_TO_INLINE\", \"DEPRECATION_ERROR\")\n    private inline fun Float.reverseRead(): Float = when {\n        readByteOrder == ByteOrder.BIG_ENDIAN -> this\n        else -> this.reverseByteOrder()\n    }\n\n    @Suppress(\"NOTHING_TO_INLINE\", \"DEPRECATION_ERROR\")\n    private inline fun Double.reverseRead(): Double = when {\n        readByteOrder == ByteOrder.BIG_ENDIAN -> this\n        else -> this.reverseByteOrder()\n    }\n\n    override suspend fun readInt(): Int {\n        return if (readable.hasBytes(4)) {\n            readable.readInt().reverseRead().also { afterRead(4) }\n        } else {\n            readIntSlow()\n        }\n    }\n\n    private suspend fun readIntSlow(): Int {\n        readNSlow(4) {\n            return readable.readInt().reverseRead().also { afterRead(4) }\n        }\n    }\n\n    override suspend fun readLong(): Long {\n        return if (readable.hasBytes(8)) {\n            readable.readLong().reverseRead().also { afterRead(8) }\n        } else {\n            readLongSlow()\n        }\n    }\n\n    private suspend fun readLongSlow(): Long {\n        readNSlow(8) {\n            return readable.readLong().reverseRead().also { afterRead(8) }\n        }\n    }\n\n    override suspend fun readFloat(): Float = if (readable.hasBytes(4)) {\n        readable.readFloat().reverseRead().also { afterRead(4) }\n    } else {\n        readFloatSlow()\n    }\n\n    private suspend fun readFloatSlow(): Float {\n        readNSlow(4) {\n            return readable.readFloat().reverseRead().also { afterRead(4) }\n        }\n    }\n\n    override suspend fun readDouble(): Double = if (readable.hasBytes(8)) {\n        readable.readDouble().reverseRead().also { afterRead(8) }\n    } else {\n        readDoubleSlow()\n    }\n\n    private suspend fun readDoubleSlow(): Double {\n        readNSlow(8) {\n            return readable.readDouble().reverseRead().also { afterRead(8) }\n        }\n    }\n\n    override suspend fun readRemaining(limit: Long, headerSizeHint: Int): ByteReadPacket {\n        ensureNotFailed()\n\n        val builder = BytePacketBuilder(headerSizeHint)\n\n        val size = minOf(limit, readable.remaining)\n        builder.writePacket(readable, size)\n        val remaining = limit - builder.size\n\n        return if (remaining == 0L || isClosedForRead) {\n            afterRead(remaining.toInt())\n            ensureNotFailed(builder)\n            builder.build()\n        } else {\n            readRemainingSuspend(builder, limit)\n        }\n    }\n\n    private suspend fun readRemainingSuspend(builder: BytePacketBuilder, limit: Long): ByteReadPacket {\n        while (builder.size < limit) {\n            val partLimit = minOf(limit - builder.size, readable.remaining)\n            builder.writePacket(readable, partLimit)\n            afterRead(partLimit.toInt())\n            ensureNotFailed(builder)\n\n            if (isClosedForRead || builder.size == limit.toInt()) {\n                break\n            }\n\n            awaitSuspend(1)\n        }\n\n        ensureNotFailed(builder)\n        return builder.build()\n    }\n\n    override suspend fun readPacket(size: Int, headerSizeHint: Int): ByteReadPacket {\n        val builder = BytePacketBuilder(headerSizeHint)\n\n        var remaining = size\n        val partSize = minOf(remaining.toLong(), readable.remaining).toInt()\n        remaining -= partSize\n        builder.writePacket(readable, partSize)\n        afterRead(partSize)\n\n        return if (remaining > 0) readPacketSuspend(builder, remaining)\n        else builder.build()\n    }\n\n    private suspend fun readPacketSuspend(builder: BytePacketBuilder, size: Int): ByteReadPacket {\n        var remaining = size\n        while (remaining > 0) {\n            val partSize = minOf(remaining.toLong(), readable.remaining).toInt()\n            remaining -= partSize\n            builder.writePacket(readable, partSize)\n            afterRead(partSize)\n\n            if (remaining > 0) {\n                awaitSuspend(1)\n            }\n        }\n\n        return builder.build()\n    }\n\n    protected fun readAvailableClosed(): Int {\n        closedCause?.let { throw it }\n        return -1\n    }\n\n    override suspend fun readAvailable(dst: IoBuffer): Int = readAvailable(dst as Buffer)\n\n    internal suspend fun readAvailable(dst: Buffer): Int = when {\n        closedCause != null -> throw closedCause!!\n        readable.canRead() -> {\n            val size = minOf(dst.writeRemaining.toLong(), readable.remaining).toInt()\n            readable.readFully(dst, size)\n            afterRead(size)\n            size\n        }\n        closed -> readAvailableClosed()\n        !dst.canWrite() -> 0\n        else -> readAvailableSuspend(dst)\n    }\n\n    private suspend fun readAvailableSuspend(dst: Buffer): Int {\n        awaitSuspend(1)\n        return readAvailable(dst)\n    }\n\n    override suspend fun readFully(dst: IoBuffer, n: Int) {\n        readFully(dst as Buffer, n)\n    }\n\n    private suspend fun readFully(dst: Buffer, n: Int) {\n        require(n <= dst.writeRemaining) { \"Not enough space in the destination buffer to write $n bytes\" }\n        require(n >= 0) { \"n shouldn't be negative\" }\n\n        return when {\n            closedCause != null -> throw closedCause!!\n            readable.remaining >= n -> readable.readFully(dst, n).also { afterRead(n) }\n            closed -> throw EOFException(\"Channel is closed and not enough bytes available: required $n but $availableForRead available\")\n            else -> readFullySuspend(dst, n)\n        }\n    }\n\n    private suspend fun readFullySuspend(dst: Buffer, n: Int) {\n        awaitSuspend(n)\n        return readFully(dst, n)\n    }\n\n    override suspend fun readAvailable(dst: ByteArray, offset: Int, length: Int): Int = when {\n        readable.canRead() -> {\n            val size = minOf(length.toLong(), readable.remaining).toInt()\n            readable.readFully(dst, offset, size)\n            afterRead(size)\n            size\n        }\n        closed -> readAvailableClosed()\n        else -> readAvailableSuspend(dst, offset, length)\n    }\n\n    private suspend fun readAvailableSuspend(dst: ByteArray, offset: Int, length: Int): Int {\n        awaitSuspend(1)\n        return readAvailable(dst, offset, length)\n    }\n\n    override suspend fun readFully(dst: ByteArray, offset: Int, length: Int) {\n        val rc = readAvailable(dst, offset, length)\n        if (rc == length) return\n        if (rc == -1) throw EOFException(\"Unexpected end of stream\")\n\n        return readFullySuspend(dst, offset + rc, length - rc)\n    }\n\n    private suspend fun readFullySuspend(dst: ByteArray, offset: Int, length: Int) {\n        var written = 0\n\n        while (written < length) {\n            val rc = readAvailable(dst, offset + written, length - written)\n            if (rc == -1) throw EOFException(\"Unexpected end of stream\")\n            written += rc\n        }\n    }\n\n    override suspend fun readBoolean(): Boolean {\n        return if (readable.canRead()) (readable.readByte() == 1.toByte()).also { afterRead(1) }\n        else readBooleanSlow()\n    }\n\n    private suspend fun readBooleanSlow(): Boolean {\n        awaitSuspend(1)\n        checkClosed(1)\n        return readBoolean()\n    }\n\n    private var lastReadAvailable: Int\n        get() = state.lastReadAvailable\n        set(value) {\n            state.lastReadAvailable = value\n        }\n\n    private var lastReadView: ChunkBuffer\n        get() = state.lastReadView\n        set(value) {\n            state.lastReadView = value\n        }\n\n    private fun completeReading() {\n        val remaining = lastReadView.readRemaining\n        val delta = lastReadAvailable - remaining\n        if (lastReadView !== Buffer.Empty) {\n            readable.completeReadHead(lastReadView)\n        }\n        if (delta > 0) {\n            afterRead(delta)\n        }\n        lastReadAvailable = 0\n        lastReadView = ChunkBuffer.Empty\n    }\n\n    override suspend fun await(atLeast: Int): Boolean {\n        require(atLeast >= 0) { \"atLeast parameter shouldn't be negative: $atLeast\" }\n        require(atLeast <= EXPECTED_CAPACITY) { \"atLeast parameter shouldn't be larger than max buffer size of $EXPECTED_CAPACITY: $atLeast\" }\n\n        completeReading()\n\n        if (atLeast == 0) return !isClosedForRead\n        if (readable.remaining >= atLeast) return true\n\n        return awaitSuspend(atLeast)\n    }\n\n    internal suspend fun awaitInternalAtLeast1(): Boolean = if (readable.isNotEmpty) {\n        true\n    } else {\n        awaitSuspend(1)\n    }\n\n    protected suspend fun awaitSuspend(atLeast: Int): Boolean {\n        require(atLeast >= 0)\n\n        awaitAtLeastNBytesAvailableForRead(atLeast)\n        prepareFlushedBytes()\n\n        closedCause?.let { throw it }\n        return !isClosedForRead && availableForRead >= atLeast\n    }\n\n    override fun discard(n: Int): Int {\n        closedCause?.let { throw it }\n\n        if (n == 0) {\n            return 0\n        }\n\n        return readable.discard(n).also {\n            afterRead(n)\n            requestNextView(1)\n        }\n    }\n\n    override fun request(atLeast: Int): IoBuffer? {\n        closedCause?.let { throw it }\n\n        completeReading()\n\n        return requestNextView(atLeast)\n    }\n\n    private fun requestNextView(atLeast: Int): IoBuffer? {\n        if (readable.isEmpty) {\n            prepareFlushedBytes()\n        }\n\n        val view = readable.prepareReadHead(atLeast) as IoBuffer?\n\n        if (view == null) {\n            lastReadView = ChunkBuffer.Empty\n            lastReadAvailable = 0\n        } else {\n            lastReadView = view\n            lastReadAvailable = view.readRemaining\n        }\n\n        return view\n    }\n\n    override suspend fun discard(max: Long): Long {\n        val discarded = readable.discard(max)\n\n        return if (discarded == max || isClosedForRead) {\n            ensureNotFailed()\n            return discarded\n        } else {\n            discardSuspend(max, discarded)\n        }\n    }\n\n    private suspend fun discardSuspend(max: Long, discarded0: Long): Long {\n        var discarded = discarded0\n\n        do {\n            if (!await(1)) break\n            discarded += readable.discard(max - discarded)\n        } while (discarded < max && !isClosedForRead)\n\n        ensureNotFailed()\n\n        return discarded\n    }\n\n    @Suppress(\"DEPRECATION\")\n    @Deprecated(\"Use read instead.\")\n    override fun readSession(consumer: ReadSession.() -> Unit) {\n        try {\n            consumer(this)\n        } finally {\n            completeReading()\n        }\n    }\n\n    override fun startReadSession(): SuspendableReadSession = this\n\n    override fun endReadSession() {\n        completeReading()\n    }\n\n    @Suppress(\"DEPRECATION\")\n    @Deprecated(\"Use read instead.\")\n    override suspend fun readSuspendableSession(consumer: suspend SuspendableReadSession.() -> Unit) {\n        try {\n            consumer(this)\n        } finally {\n            completeReading()\n        }\n    }\n\n    override suspend fun <A : Appendable> readUTF8LineTo(out: A, limit: Int): Boolean {\n        if (isClosedForRead) {\n            val cause = closedCause\n            if (cause != null) {\n                throw cause\n            }\n\n            return false\n        }\n        @OptIn(DangerousInternalIoApi::class)\n        return decodeUTF8LineLoopSuspend(out, limit) { size ->\n            afterRead(size)\n            if (await(size)) readable\n            else null\n        }\n    }\n\n    override suspend fun readUTF8Line(limit: Int): String? {\n        val sb = StringBuilder()\n        if (!readUTF8LineTo(sb, limit)) {\n            return null\n        }\n\n        return sb.toString()\n    }\n\n    override fun cancel(cause: Throwable?): Boolean {\n        if (closedCause != null || closed) {\n            return false\n        }\n\n        return close(cause ?: io.ktor.utils.io.CancellationException(\"Channel cancelled\"))\n    }\n\n    override fun close(cause: Throwable?): Boolean {\n        if (closed || closedCause != null) return false\n        closedCause = cause\n        closed = true\n        if (cause != null) {\n            readable.release()\n            writable.release()\n            flushBuffer.release()\n        } else {\n            flush()\n        }\n\n        slot.cancel(cause)\n        return true\n    }\n\n    internal fun transferTo(dst: ByteChannelSequentialBase, limit: Long): Long {\n        val size = readable.remaining\n        return if (size <= limit) {\n            dst.writable.writePacket(readable)\n            dst.afterWrite(size.toInt())\n            afterRead(size.toInt())\n            size\n        } else {\n            0\n        }\n    }\n\n    private suspend inline fun readNSlow(n: Int, block: () -> Nothing): Nothing {\n        do {\n            awaitSuspend(n)\n\n            if (readable.hasBytes(n)) block()\n            checkClosed(n)\n        } while (true)\n    }\n\n    @Suppress(\"DEPRECATION\")\n    private suspend fun writeAvailableSuspend(src: IoBuffer): Int {\n        awaitAtLeastNBytesAvailableForWrite(1)\n        return writeAvailable(src)\n    }\n\n    private suspend fun writeAvailableSuspend(src: ByteArray, offset: Int, length: Int): Int {\n        awaitAtLeastNBytesAvailableForWrite(1)\n        return writeAvailable(src, offset, length)\n    }\n\n    @Deprecated(\"Consider providing written count of bytes\", level = DeprecationLevel.ERROR)\n    protected fun afterWrite() {\n        afterWrite(0)\n    }\n\n    protected fun afterWrite(count: Int) {\n        _totalBytesWritten += count\n\n        if (closed) {\n            writable.release()\n            ensureNotClosed()\n        }\n        if (autoFlush || availableForWrite == 0) {\n            flush()\n        }\n    }\n\n    override suspend fun awaitFreeSpace() {\n        flush()\n        awaitAtLeastNBytesAvailableForWrite(1)\n        ensureNotClosed()\n    }\n\n    final override suspend fun peekTo(\n        destination: Memory,\n        destinationOffset: Long,\n        offset: Long,\n        min: Long,\n        max: Long\n    ): Long {\n        var bytesCopied = 0L\n\n        @Suppress(\"DEPRECATION\")\n        readSuspendableSession {\n            val desiredSize = (min + offset).coerceAtMost(EXPECTED_CAPACITY).toInt()\n\n            await(desiredSize)\n\n            val buffer = request(1) ?: IoBuffer.Empty\n            if (buffer.readRemaining > offset) {\n                buffer.discardExact(offset)\n                bytesCopied = minOf(buffer.readRemaining.toLong(), max)\n                buffer.memory.copyTo(destination, buffer.readPosition.toLong(), bytesCopied, destinationOffset)\n            }\n        }\n\n        return bytesCopied\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"PreconditionsKt\")\n\npackage kotlin\n\nimport kotlin.contracts.contract\n\n/**\n * Throws an [IllegalArgumentException] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun require(value: Boolean): Unit {\n    contract {\n        returns() implies value\n    }\n    require(value) { \"Failed requirement.\" }\n}\n\n/**\n * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun require(value: Boolean, lazyMessage: () -> Any): Unit {\n    contract {\n        returns() implies value\n    }\n    if (!value) {\n        val message = lazyMessage()\n        throw IllegalArgumentException(message.toString())\n    }\n}\n\n/**\n * Throws an [IllegalArgumentException] if the [value] is null. Otherwise returns the not null value.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> requireNotNull(value: T?): T {\n    contract {\n        returns() implies (value != null)\n    }\n    return requireNotNull(value) { \"Required value was null.\" }\n}\n\n/**\n * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failRequireNotNullWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> requireNotNull(value: T?, lazyMessage: () -> Any): T {\n    contract {\n        returns() implies (value != null)\n    }\n\n    if (value == null) {\n        val message = lazyMessage()\n        throw IllegalArgumentException(message.toString())\n    } else {\n        return value\n    }\n}\n\n/**\n * Throws an [IllegalStateException] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun check(value: Boolean): Unit {\n    contract {\n        returns() implies value\n    }\n    check(value) { \"Check failed.\" }\n}\n\n/**\n * Throws an [IllegalStateException] with the result of calling [lazyMessage] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun check(value: Boolean, lazyMessage: () -> Any): Unit {\n    contract {\n        returns() implies value\n    }\n    if (!value) {\n        val message = lazyMessage()\n        throw IllegalStateException(message.toString())\n    }\n}\n\n/**\n * Throws an [IllegalStateException] if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> checkNotNull(value: T?): T {\n    contract {\n        returns() implies (value != null)\n    }\n    return checkNotNull(value) { \"Required value was null.\" }\n}\n\n/**\n * Throws an [IllegalStateException] with the result of calling [lazyMessage]  if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> checkNotNull(value: T?, lazyMessage: () -> Any): T {\n    contract {\n        returns() implies (value != null)\n    }\n\n    if (value == null) {\n        val message = lazyMessage()\n        throw IllegalStateException(message.toString())\n    } else {\n        return value\n    }\n}\n\n\n/**\n * Throws an [IllegalStateException] with the given [message].\n *\n * @sample samples.misc.Preconditions.failWithError\n */\n@kotlin.internal.InlineOnly\npublic inline fun error(message: Any): Nothing = throw IllegalStateException(message.toString())\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin\n\nimport kotlin.experimental.*\n\n@Suppress(\"NON_PUBLIC_PRIMARY_CONSTRUCTOR_OF_INLINE_CLASS\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline class UShort @PublishedApi internal constructor(@PublishedApi internal val data: Short) : Comparable<UShort> {\n\n    companion object {\n        /**\n         * A constant holding the minimum value an instance of UShort can have.\n         */\n        public const val MIN_VALUE: UShort = UShort(0)\n\n        /**\n         * A constant holding the maximum value an instance of UShort can have.\n         */\n        public const val MAX_VALUE: UShort = UShort(-1)\n\n        /**\n         * The number of bytes used to represent an instance of UShort in a binary form.\n         */\n        public const val SIZE_BYTES: Int = 2\n\n        /**\n         * The number of bits used to represent an instance of UShort in a binary form.\n         */\n        public const val SIZE_BITS: Int = 16\n    }\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UByte): Int = this.toInt().compareTo(other.toInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    @Suppress(\"OVERRIDE_BY_INLINE\")\n    public override inline operator fun compareTo(other: UShort): Int = this.toInt().compareTo(other.toInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UInt): Int = this.toUInt().compareTo(other)\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: ULong): Int = this.toULong().compareTo(other)\n\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UByte): UInt = this.toUInt().plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UShort): UInt = this.toUInt().plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UInt): UInt = this.toUInt().plus(other)\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: ULong): ULong = this.toULong().plus(other)\n\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UByte): UInt = this.toUInt().minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UShort): UInt = this.toUInt().minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UInt): UInt = this.toUInt().minus(other)\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: ULong): ULong = this.toULong().minus(other)\n\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UByte): UInt = this.toUInt().times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UShort): UInt = this.toUInt().times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UInt): UInt = this.toUInt().times(other)\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: ULong): ULong = this.toULong().times(other)\n\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UByte): UInt = this.toUInt().div(other.toUInt())\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UShort): UInt = this.toUInt().div(other.toUInt())\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UInt): UInt = this.toUInt().div(other)\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: ULong): ULong = this.toULong().div(other)\n\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UByte): UInt = this.toUInt().rem(other.toUInt())\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UShort): UInt = this.toUInt().rem(other.toUInt())\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UInt): UInt = this.toUInt().rem(other)\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: ULong): ULong = this.toULong().rem(other)\n\n    /** Increments this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun inc(): UShort = UShort(data.inc())\n    /** Decrements this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun dec(): UShort = UShort(data.dec())\n\n    /** Creates a range from this value to the specified [other] value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rangeTo(other: UShort): UIntRange = UIntRange(this.toUInt(), other.toUInt())\n\n    /** Performs a bitwise AND operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun and(other: UShort): UShort = UShort(this.data and other.data)\n    /** Performs a bitwise OR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun or(other: UShort): UShort = UShort(this.data or other.data)\n    /** Performs a bitwise XOR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun xor(other: UShort): UShort = UShort(this.data xor other.data)\n    /** Inverts the bits in this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun inv(): UShort = UShort(data.inv())\n\n    /**\n     * Converts this [UShort] value to [Byte].\n     *\n     * If this value is less than or equals to [Byte.MAX_VALUE], the resulting `Byte` value represents\n     * the same numerical value as this `UShort`.\n     *\n     * The resulting `Byte` value is represented by the least significant 8 bits of this `UShort` value.\n     * Note that the resulting `Byte` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toByte(): Byte = data.toByte()\n    /**\n     * Converts this [UShort] value to [Short].\n     *\n     * If this value is less than or equals to [Short.MAX_VALUE], the resulting `Short` value represents\n     * the same numerical value as this `UShort`. Otherwise the result is negative.\n     *\n     * The resulting `Short` value has the same binary representation as this `UShort` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toShort(): Short = data\n    /**\n     * Converts this [UShort] value to [Int].\n     *\n     * The resulting `Int` value represents the same numerical value as this `UShort`.\n     *\n     * The least significant 16 bits of the resulting `Int` value are the same as the bits of this `UShort` value,\n     * whereas the most significant 16 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toInt(): Int = data.toInt() and 0xFFFF\n    /**\n     * Converts this [UShort] value to [Long].\n     *\n     * The resulting `Long` value represents the same numerical value as this `UShort`.\n     *\n     * The least significant 16 bits of the resulting `Long` value are the same as the bits of this `UShort` value,\n     * whereas the most significant 48 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toLong(): Long = data.toLong() and 0xFFFF\n\n    /**\n     * Converts this [UShort] value to [UByte].\n     *\n     * If this value is less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n     * the same numerical value as this `UShort`.\n     *\n     * The resulting `UByte` value is represented by the least significant 8 bits of this `UShort` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUByte(): UByte = data.toUByte()\n    /** Returns this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun toUShort(): UShort = this\n    /**\n     * Converts this [UShort] value to [UInt].\n     *\n     * The resulting `UInt` value represents the same numerical value as this `UShort`.\n     *\n     * The least significant 16 bits of the resulting `UInt` value are the same as the bits of this `UShort` value,\n     * whereas the most significant 16 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUInt(): UInt = UInt(data.toInt() and 0xFFFF)\n    /**\n     * Converts this [UShort] value to [ULong].\n     *\n     * The resulting `ULong` value represents the same numerical value as this `UShort`.\n     *\n     * The least significant 16 bits of the resulting `ULong` value are the same as the bits of this `UShort` value,\n     * whereas the most significant 48 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toULong(): ULong = ULong(data.toLong() and 0xFFFF)\n\n    /**\n     * Converts this [UShort] value to [Float].\n     *\n     * The resulting `Float` value represents the same numerical value as this `UShort`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toFloat(): Float = this.toInt().toFloat()\n    /**\n     * Converts this [UShort] value to [Double].\n     *\n     * The resulting `Double` value represents the same numerical value as this `UShort`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toDouble(): Double = this.toInt().toDouble()\n\n    public override fun toString(): String = toInt().toString()\n\n}\n\n/**\n * Converts this [Byte] value to [UShort].\n *\n * If this value is positive, the resulting `UShort` value represents the same numerical value as this `Byte`.\n *\n * The least significant 8 bits of the resulting `UShort` value are the same as the bits of this `Byte` value,\n * whereas the most significant 8 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Byte.toUShort(): UShort = UShort(this.toShort())\n/**\n * Converts this [Short] value to [UShort].\n *\n * If this value is positive, the resulting `UShort` value represents the same numerical value as this `Short`.\n *\n * The resulting `UShort` value has the same binary representation as this `Short` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Short.toUShort(): UShort = UShort(this)\n/**\n * Converts this [Int] value to [UShort].\n *\n * If this value is positive and less than or equals to [UShort.MAX_VALUE], the resulting `UShort` value represents\n * the same numerical value as this `Int`.\n *\n * The resulting `UShort` value is represented by the least significant 16 bits of this `Int` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Int.toUShort(): UShort = UShort(this.toShort())\n/**\n * Converts this [Long] value to [UShort].\n *\n * If this value is positive and less than or equals to [UShort.MAX_VALUE], the resulting `UShort` value represents\n * the same numerical value as this `Long`.\n *\n * The resulting `UShort` value is represented by the least significant 16 bits of this `Long` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Long.toUShort(): UShort = UShort(this.toShort())\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin\n\nimport kotlin.experimental.*\n\n@Suppress(\"NON_PUBLIC_PRIMARY_CONSTRUCTOR_OF_INLINE_CLASS\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline class UInt @PublishedApi internal constructor(@PublishedApi internal val data: Int) : Comparable<UInt> {\n\n    companion object {\n        /**\n         * A constant holding the minimum value an instance of UInt can have.\n         */\n        public const val MIN_VALUE: UInt = UInt(0)\n\n        /**\n         * A constant holding the maximum value an instance of UInt can have.\n         */\n        public const val MAX_VALUE: UInt = UInt(-1)\n\n        /**\n         * The number of bytes used to represent an instance of UInt in a binary form.\n         */\n        public const val SIZE_BYTES: Int = 4\n\n        /**\n         * The number of bits used to represent an instance of UInt in a binary form.\n         */\n        public const val SIZE_BITS: Int = 32\n    }\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UByte): Int = this.compareTo(other.toUInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UShort): Int = this.compareTo(other.toUInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    @Suppress(\"OVERRIDE_BY_INLINE\")\n    public override inline operator fun compareTo(other: UInt): Int = uintCompare(this.data, other.data)\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: ULong): Int = this.toULong().compareTo(other)\n\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UByte): UInt = this.plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UShort): UInt = this.plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UInt): UInt = UInt(this.data.plus(other.data))\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: ULong): ULong = this.toULong().plus(other)\n\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UByte): UInt = this.minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UShort): UInt = this.minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UInt): UInt = UInt(this.data.minus(other.data))\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: ULong): ULong = this.toULong().minus(other)\n\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UByte): UInt = this.times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UShort): UInt = this.times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UInt): UInt = UInt(this.data.times(other.data))\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: ULong): ULong = this.toULong().times(other)\n\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UByte): UInt = this.div(other.toUInt())\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UShort): UInt = this.div(other.toUInt())\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UInt): UInt = uintDivide(this, other)\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: ULong): ULong = this.toULong().div(other)\n\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UByte): UInt = this.rem(other.toUInt())\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UShort): UInt = this.rem(other.toUInt())\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UInt): UInt = uintRemainder(this, other)\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: ULong): ULong = this.toULong().rem(other)\n\n    /** Increments this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun inc(): UInt = UInt(data.inc())\n    /** Decrements this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun dec(): UInt = UInt(data.dec())\n\n    /** Creates a range from this value to the specified [other] value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rangeTo(other: UInt): UIntRange = UIntRange(this, other)\n\n    /** Shifts this value left by the [bitCount] number of bits. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun shl(bitCount: Int): UInt = UInt(data shl bitCount)\n    /** Shifts this value right by the [bitCount] number of bits, filling the leftmost bits with zeros. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun shr(bitCount: Int): UInt = UInt(data ushr bitCount)\n    /** Performs a bitwise AND operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun and(other: UInt): UInt = UInt(this.data and other.data)\n    /** Performs a bitwise OR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun or(other: UInt): UInt = UInt(this.data or other.data)\n    /** Performs a bitwise XOR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun xor(other: UInt): UInt = UInt(this.data xor other.data)\n    /** Inverts the bits in this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun inv(): UInt = UInt(data.inv())\n\n    /**\n     * Converts this [UInt] value to [Byte].\n     *\n     * If this value is less than or equals to [Byte.MAX_VALUE], the resulting `Byte` value represents\n     * the same numerical value as this `UInt`.\n     *\n     * The resulting `Byte` value is represented by the least significant 8 bits of this `UInt` value.\n     * Note that the resulting `Byte` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toByte(): Byte = data.toByte()\n    /**\n     * Converts this [UInt] value to [Short].\n     *\n     * If this value is less than or equals to [Short.MAX_VALUE], the resulting `Short` value represents\n     * the same numerical value as this `UInt`.\n     *\n     * The resulting `Short` value is represented by the least significant 16 bits of this `UInt` value.\n     * Note that the resulting `Short` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toShort(): Short = data.toShort()\n    /**\n     * Converts this [UInt] value to [Int].\n     *\n     * If this value is less than or equals to [Int.MAX_VALUE], the resulting `Int` value represents\n     * the same numerical value as this `UInt`. Otherwise the result is negative.\n     *\n     * The resulting `Int` value has the same binary representation as this `UInt` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toInt(): Int = data\n    /**\n     * Converts this [UInt] value to [Long].\n     *\n     * The resulting `Long` value represents the same numerical value as this `UInt`.\n     *\n     * The least significant 32 bits of the resulting `Long` value are the same as the bits of this `UInt` value,\n     * whereas the most significant 32 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toLong(): Long = data.toLong() and 0xFFFF_FFFF\n\n    /**\n     * Converts this [UInt] value to [UByte].\n     *\n     * If this value is less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n     * the same numerical value as this `UInt`.\n     *\n     * The resulting `UByte` value is represented by the least significant 8 bits of this `UInt` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUByte(): UByte = data.toUByte()\n    /**\n     * Converts this [UInt] value to [UShort].\n     *\n     * If this value is less than or equals to [UShort.MAX_VALUE], the resulting `UShort` value represents\n     * the same numerical value as this `UInt`.\n     *\n     * The resulting `UShort` value is represented by the least significant 16 bits of this `UInt` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUShort(): UShort = data.toUShort()\n    /** Returns this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun toUInt(): UInt = this\n    /**\n     * Converts this [UInt] value to [ULong].\n     *\n     * The resulting `ULong` value represents the same numerical value as this `UInt`.\n     *\n     * The least significant 32 bits of the resulting `ULong` value are the same as the bits of this `UInt` value,\n     * whereas the most significant 32 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toULong(): ULong = ULong(data.toLong() and 0xFFFF_FFFF)\n\n    /**\n     * Converts this [UInt] value to [Float].\n     *\n     * The resulting value is the closest `Float` to this `UInt` value.\n     * In case when this `UInt` value is exactly between two `Float`s,\n     * the one with zero at least significant bit of mantissa is selected.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toFloat(): Float = this.toDouble().toFloat()\n    /**\n     * Converts this [UInt] value to [Double].\n     *\n     * The resulting `Double` value represents the same numerical value as this `UInt`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toDouble(): Double = uintToDouble(data)\n\n    public override fun toString(): String = toLong().toString()\n\n}\n\n/**\n * Converts this [Byte] value to [UInt].\n *\n * If this value is positive, the resulting `UInt` value represents the same numerical value as this `Byte`.\n *\n * The least significant 8 bits of the resulting `UInt` value are the same as the bits of this `Byte` value,\n * whereas the most significant 24 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Byte.toUInt(): UInt = UInt(this.toInt())\n/**\n * Converts this [Short] value to [UInt].\n *\n * If this value is positive, the resulting `UInt` value represents the same numerical value as this `Short`.\n *\n * The least significant 16 bits of the resulting `UInt` value are the same as the bits of this `Short` value,\n * whereas the most significant 16 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Short.toUInt(): UInt = UInt(this.toInt())\n/**\n * Converts this [Int] value to [UInt].\n *\n * If this value is positive, the resulting `UInt` value represents the same numerical value as this `Int`.\n *\n * The resulting `UInt` value has the same binary representation as this `Int` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Int.toUInt(): UInt = UInt(this)\n/**\n * Converts this [Long] value to [UInt].\n *\n * If this value is positive and less than or equals to [UInt.MAX_VALUE], the resulting `UInt` value represents\n * the same numerical value as this `Long`.\n *\n * The resulting `UInt` value is represented by the least significant 32 bits of this `Long` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Long.toUInt(): UInt = UInt(this.toInt())\n\n/**\n * Converts this [Float] value to [UInt].\n *\n * The fractional part, if any, is rounded down towards zero.\n * Returns zero if this `Float` value is negative or `NaN`, [UInt.MAX_VALUE] if it's bigger than `UInt.MAX_VALUE`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Float.toUInt(): UInt = doubleToUInt(this.toDouble())\n/**\n * Converts this [Double] value to [UInt].\n *\n * The fractional part, if any, is rounded down towards zero.\n * Returns zero if this `Double` value is negative or `NaN`, [UInt.MAX_VALUE] if it's bigger than `UInt.MAX_VALUE`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Double.toUInt(): UInt = doubleToUInt(this)\n","package io.ktor.utils.io.charsets\n\nimport io.ktor.utils.io.core.*\nimport io.ktor.utils.io.core.internal.*\n\npublic expect abstract class Charset {\n    @ExperimentalIoApi\n    public abstract fun newEncoder(): CharsetEncoder\n\n    @ExperimentalIoApi\n    public abstract fun newDecoder(): CharsetDecoder\n\n    public companion object {\n        public fun forName(name: String): Charset\n    }\n}\n\npublic expect val Charset.name: String\n\n// ----------------------------- ENCODER -------------------------------------------------------------------------------\n@ExperimentalIoApi\npublic expect abstract class CharsetEncoder\n\npublic expect val CharsetEncoder.charset: Charset\n\n@Deprecated(\n    \"Use writeText on Output instead.\",\n    ReplaceWith(\"dst.writeText(input, fromIndex, toIndex, charset)\", \"io.ktor.utils.io.core.writeText\")\n)\npublic fun CharsetEncoder.encode(input: CharSequence, fromIndex: Int, toIndex: Int, dst: Output) {\n    encodeToImpl(dst, input, fromIndex, toIndex)\n}\n\n@ExperimentalIoApi\npublic expect fun CharsetEncoder.encodeToByteArray(\n    input: CharSequence,\n    fromIndex: Int = 0,\n    toIndex: Int = input.length\n): ByteArray\n\n@Deprecated(\n    \"Internal API. Will be hidden in future releases. Use encodeToByteArray instead.\",\n    replaceWith = ReplaceWith(\"encodeToByteArray(input, fromIndex, toIndex)\")\n)\npublic fun CharsetEncoder.encodeToByteArrayImpl(\n    input: CharSequence,\n    fromIndex: Int = 0,\n    toIndex: Int = input.length\n): ByteArray {\n    return encodeToByteArray(input, fromIndex, toIndex)\n}\n\n@ExperimentalIoApi\npublic expect fun CharsetEncoder.encodeUTF8(input: ByteReadPacket, dst: Output)\n\n@ExperimentalIoApi\npublic fun CharsetEncoder.encode(\n    input: CharSequence, fromIndex: Int = 0, toIndex: Int = input.length\n): ByteReadPacket = buildPacket {\n    encodeToImpl(this, input, fromIndex, toIndex)\n}\n\n@ExperimentalIoApi\npublic fun CharsetEncoder.encodeUTF8(input: ByteReadPacket): ByteReadPacket = buildPacket {\n    encodeUTF8(input, this)\n}\n\n\n@ExperimentalIoApi\npublic fun CharsetEncoder.encode(input: CharArray, fromIndex: Int, toIndex: Int, dst: Output) {\n    var start = fromIndex\n\n    if (start >= toIndex) return\n    dst.writeWhileSize(1) { view: Buffer ->\n        val rc = encodeArrayImpl(input, start, toIndex, view)\n        check(rc >= 0)\n        start += rc\n\n        when {\n            start >= toIndex -> 0\n            rc == 0 -> 8\n            else -> 1\n        }\n    }\n\n    encodeCompleteImpl(dst)\n}\n\n\n// ----------------------------- DECODER -------------------------------------------------------------------------------\n\n@ExperimentalIoApi\npublic expect abstract class CharsetDecoder\n\n/**\n * Decoder's charset it is created for.\n */\npublic expect val CharsetDecoder.charset: Charset\n\n@ExperimentalIoApi\npublic fun CharsetDecoder.decode(input: Input, max: Int = Int.MAX_VALUE): String =\n    buildString(minOf(max.toLong(), input.sizeEstimate()).toInt()) {\n        decode(input, this, max)\n    }\n\n@ExperimentalIoApi\npublic expect fun CharsetDecoder.decode(input: Input, dst: Appendable, max: Int): Int\n\n@ExperimentalIoApi\npublic expect fun CharsetDecoder.decodeExactBytes(input: Input, inputLength: Int): String\n\n// ----------------------------- REGISTRY ------------------------------------------------------------------------------\npublic expect object Charsets {\n    public val UTF_8: Charset\n    public val ISO_8859_1: Charset\n}\n\npublic expect open class MalformedInputException(message: String) : Throwable\n\n\npublic class TooLongLineException(message: String) : MalformedInputException(message)\n\n// ----------------------------- INTERNALS -----------------------------------------------------------------------------\n\ninternal fun CharsetEncoder.encodeArrayImpl(input: CharArray, fromIndex: Int, toIndex: Int, dst: Buffer): Int {\n    val length = toIndex - fromIndex\n    return encodeImpl(CharArraySequence(input, fromIndex, length), 0, length, dst)\n}\n\ninternal expect fun CharsetEncoder.encodeImpl(input: CharSequence, fromIndex: Int, toIndex: Int, dst: Buffer): Int\n\ninternal expect fun CharsetEncoder.encodeComplete(dst: Buffer): Boolean\n\ninternal expect fun CharsetDecoder.decodeBuffer(\n    input: Buffer,\n    out: Appendable,\n    lastBuffer: Boolean,\n    max: Int = Int.MAX_VALUE\n): Int\n\ninternal fun CharsetEncoder.encodeToByteArrayImpl1(\n    input: CharSequence,\n    fromIndex: Int = 0,\n    toIndex: Int = input.length\n): ByteArray {\n    var start = fromIndex\n    if (start >= toIndex) return EmptyByteArray\n    val single = ChunkBuffer.Pool.borrow()\n\n    try {\n        val rc = encodeImpl(input, start, toIndex, single)\n        start += rc\n        if (start == toIndex) {\n            val result = ByteArray(single.readRemaining)\n            single.readFully(result)\n            return result\n        }\n\n        return buildPacket {\n            appendSingleChunk(single.duplicate())\n            encodeToImpl(this, input, start, toIndex)\n        }.readBytes()\n    } finally {\n        single.release(ChunkBuffer.Pool)\n    }\n}\n\ninternal fun Input.sizeEstimate(): Long = when (this) {\n    is ByteReadPacket -> remaining\n    is AbstractInput -> maxOf(remaining, 16)\n    else -> 16\n}\n\n\nprivate fun CharsetEncoder.encodeCompleteImpl(dst: Output): Int {\n    var size = 1\n    var bytesWritten = 0\n\n    dst.writeWhile { view ->\n        val before = view.writeRemaining\n        if (encodeComplete(view)) {\n            size = 0\n        } else {\n            size++\n        }\n        bytesWritten += before - view.writeRemaining\n        size > 0\n    }\n\n    return bytesWritten\n}\n\ninternal fun CharsetEncoder.encodeToImpl(\n    destination: Output,\n    input: CharSequence,\n    fromIndex: Int,\n    toIndex: Int\n): Int {\n    var start = fromIndex\n    if (start >= toIndex) return 0\n\n    var bytesWritten = 0\n\n    destination.writeWhileSize(1) { view: Buffer ->\n        val before = view.writeRemaining\n        val rc = encodeImpl(input, start, toIndex, view)\n        check(rc >= 0)\n        start += rc\n        bytesWritten += before - view.writeRemaining\n\n        when {\n            start >= toIndex -> 0\n            rc == 0 -> 8\n            else -> 1\n        }\n    }\n\n    bytesWritten += encodeCompleteImpl(destination)\n    return bytesWritten\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n@file:Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\n\npackage kotlin.text\n\nimport kotlin.contracts.*\n\n/**\n * A mutable sequence of characters.\n *\n * String builder can be used to efficiently perform multiple string manipulation operations.\n */\nexpect class StringBuilder : Appendable, CharSequence {\n    /** Constructs an empty string builder. */\n    constructor()\n\n    /** Constructs an empty string builder with the specified initial [capacity]. */\n    constructor(capacity: Int)\n\n    /** Constructs a string builder that contains the same characters as the specified [content] char sequence. */\n    constructor(content: CharSequence)\n\n    /** Constructs a string builder that contains the same characters as the specified [content] string. */\n    @SinceKotlin(\"1.3\")\n//    @ExperimentalStdlibApi\n    constructor(content: String)\n\n    override val length: Int\n\n    override operator fun get(index: Int): Char\n\n    override fun subSequence(startIndex: Int, endIndex: Int): CharSequence\n\n    override fun append(value: Char): StringBuilder\n    override fun append(value: CharSequence?): StringBuilder\n    override fun append(value: CharSequence?, startIndex: Int, endIndex: Int): StringBuilder\n\n    /**\n     * Reverses the contents of this string builder and returns this instance.\n     *\n     * Surrogate pairs included in this string builder are treated as single characters.\n     * Therefore, the order of the high-low surrogates is never reversed.\n     *\n     * Note that the reverse operation may produce new surrogate pairs that were unpaired low-surrogates and high-surrogates before the operation.\n     * For example, reversing `\"\\uDC00\\uD800\"` produces `\"\\uD800\\uDC00\"` which is a valid surrogate pair.\n     */\n    fun reverse(): StringBuilder\n\n    /**\n     * Appends the string representation of the specified object [value] to this string builder and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was appended to this string builder.\n     */\n    fun append(value: Any?): StringBuilder\n\n    /**\n     * Appends the string representation of the specified boolean [value] to this string builder and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was appended to this string builder.\n     */\n    @SinceKotlin(\"1.3\")\n    fun append(value: Boolean): StringBuilder\n\n    /**\n     * Appends characters in the specified character array [value] to this string builder and returns this instance.\n     *\n     * Characters are appended in order, starting at the index 0.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun append(value: CharArray): StringBuilder\n\n    /**\n     * Appends the specified string [value] to this string builder and returns this instance.\n     *\n     * If [value] is `null`, then the four characters `\"null\"` are appended.\n     */\n    @SinceKotlin(\"1.3\")\n    fun append(value: String?): StringBuilder\n\n    /**\n     * Returns the current capacity of this string builder.\n     *\n     * The capacity is the maximum length this string builder can have before an allocation occurs.\n     */\n    @SinceKotlin(\"1.3\")\n//    @ExperimentalStdlibApi\n    @Deprecated(\"Obtaining StringBuilder capacity is not supported in JS and common code.\", level = DeprecationLevel.ERROR)\n    fun capacity(): Int\n\n    /**\n     * Ensures that the capacity of this string builder is at least equal to the specified [minimumCapacity].\n     *\n     * If the current capacity is less than the [minimumCapacity], a new backing storage is allocated with greater capacity.\n     * Otherwise, this method takes no action and simply returns.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun ensureCapacity(minimumCapacity: Int)\n\n    /**\n     * Returns the index within this string builder of the first occurrence of the specified [string].\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun indexOf(string: String): Int\n\n    /**\n     * Returns the index within this string builder of the first occurrence of the specified [string],\n     * starting at the specified [startIndex].\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder starting at the specified [startIndex].\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun indexOf(string: String, startIndex: Int): Int\n\n    /**\n     * Returns the index within this string builder of the last occurrence of the specified [string].\n     * The last occurrence of empty string `\"\"` is considered to be at the index equal to `this.length`.\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun lastIndexOf(string: String): Int\n\n    /**\n     * Returns the index within this string builder of the last occurrence of the specified [string],\n     * starting from the specified [startIndex] toward the beginning.\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder starting at the specified [startIndex].\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun lastIndexOf(string: String, startIndex: Int): Int\n\n    /**\n     * Inserts the string representation of the specified boolean [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was inserted into this string builder at the specified [index].\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: Boolean): StringBuilder\n\n    /**\n     * Inserts the specified character [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: Char): StringBuilder\n\n    /**\n     * Inserts characters in the specified character array [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The inserted characters go in same order as in the [value] character array, starting at [index].\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: CharArray): StringBuilder\n\n    /**\n     * Inserts characters in the specified character sequence [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The inserted characters go in the same order as in the [value] character sequence, starting at [index].\n     *\n     * @param index the position in this string builder to insert at.\n     * @param value the character sequence from which characters are inserted. If [value] is `null`, then the four characters `\"null\"` are inserted.\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: CharSequence?): StringBuilder\n\n    /**\n     * Inserts the string representation of the specified object [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was inserted into this string builder at the specified [index].\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: Any?): StringBuilder\n\n    /**\n     * Inserts the string [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * If [value] is `null`, then the four characters `\"null\"` are inserted.\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: String?): StringBuilder\n\n    /**\n     *  Sets the length of this string builder to the specified [newLength].\n     *\n     *  If the [newLength] is less than the current length, it is changed to the specified [newLength].\n     *  Otherwise, null characters '\\u0000' are appended to this string builder until its length is less than the [newLength].\n     *\n     *  Note that in Kotlin/JS [set] operator function has non-constant execution time complexity.\n     *  Therefore, increasing length of this string builder and then updating each character by index may slow down your program.\n     *\n     *  @throws IndexOutOfBoundsException or [IllegalArgumentException] if [newLength] is less than zero.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun setLength(newLength: Int)\n\n    /**\n     * Returns a new [String] that contains characters in this string builder at [startIndex] (inclusive) and up to the [length] (exclusive).\n     *\n     * @throws IndexOutOfBoundsException if [startIndex] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun substring(startIndex: Int): String\n\n    /**\n     * Returns a new [String] that contains characters in this string builder at [startIndex] (inclusive) and up to the [endIndex] (exclusive).\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun substring(startIndex: Int, endIndex: Int): String\n\n    /**\n     * Attempts to reduce storage used for this string builder.\n     *\n     * If the backing storage of this string builder is larger than necessary to hold its current contents,\n     * then it may be resized to become more space efficient.\n     * Calling this method may, but is not required to, affect the value of the [capacity] property.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun trimToSize()\n}\n\n\n/**\n * Clears the content of this string builder making it empty and returns this instance.\n *\n * @sample samples.text.Strings.clearStringBuilder\n */\n@SinceKotlin(\"1.3\")\npublic expect fun StringBuilder.clear(): StringBuilder\n\n/**\n * Sets the character at the specified [index] to the specified [value].\n *\n * @throws IndexOutOfBoundsException if [index] is out of bounds of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect operator fun StringBuilder.set(index: Int, value: Char)\n\n/**\n * Replaces characters in the specified range of this string builder with characters in the specified string [value] and returns this instance.\n *\n * @param startIndex the beginning (inclusive) of the range to replace.\n * @param endIndex the end (exclusive) of the range to replace.\n * @param value the string to replace with.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] if [startIndex] is less than zero, greater than the length of this string builder, or `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.setRange(startIndex: Int, endIndex: Int, value: String): StringBuilder\n\n/**\n * Removes the character at the specified [index] from this string builder and returns this instance.\n *\n * If the `Char` at the specified [index] is part of a supplementary code point, this method does not remove the entire supplementary character.\n *\n * @param index the index of `Char` to remove.\n *\n * @throws IndexOutOfBoundsException if [index] is out of bounds of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.deleteAt(index: Int): StringBuilder\n\n/**\n * Removes characters in the specified range from this string builder and returns this instance.\n *\n * @param startIndex the beginning (inclusive) of the range to remove.\n * @param endIndex the end (exclusive) of the range to remove.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.deleteRange(startIndex: Int, endIndex: Int): StringBuilder\n\n/**\n * Copies characters from this string builder into the [destination] character array.\n *\n * @param destination the array to copy to.\n * @param destinationOffset the position in the array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the range to copy, 0 by default.\n * @param endIndex the end (exclusive) of the range to copy, length of this string builder by default.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n *  or when that index is out of the [destination] array indices range.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.toCharArray(destination: CharArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = this.length)\n\n/**\n * Appends characters in a subarray of the specified character array [value] to this string builder and returns this instance.\n *\n * Characters are appended in order, starting at specified [startIndex].\n *\n * @param value the array from which characters are appended.\n * @param startIndex the beginning (inclusive) of the subarray to append.\n * @param endIndex the end (exclusive) of the subarray to append.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] array indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.appendRange(value: CharArray, startIndex: Int, endIndex: Int): StringBuilder\n\n/**\n * Appends a subsequence of the specified character sequence [value] to this string builder and returns this instance.\n *\n * @param value the character sequence from which a subsequence is appended.\n * @param startIndex the beginning (inclusive) of the subsequence to append.\n * @param endIndex the end (exclusive) of the subsequence to append.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.appendRange(value: CharSequence, startIndex: Int, endIndex: Int): StringBuilder\n\n/**\n * Inserts characters in a subarray of the specified character array [value] into this string builder at the specified [index] and returns this instance.\n *\n * The inserted characters go in same order as in the [value] array, starting at [index].\n *\n * @param index the position in this string builder to insert at.\n * @param value the array from which characters are inserted.\n * @param startIndex the beginning (inclusive) of the subarray to insert.\n * @param endIndex the end (exclusive) of the subarray to insert.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.insertRange(index: Int, value: CharArray, startIndex: Int, endIndex: Int): StringBuilder\n\n/**\n * Inserts characters in a subsequence of the specified character sequence [value] into this string builder at the specified [index] and returns this instance.\n *\n * The inserted characters go in the same order as in the [value] character sequence, starting at [index].\n *\n * @param index the position in this string builder to insert at.\n * @param value the character sequence from which a subsequence is inserted.\n * @param startIndex the beginning (inclusive) of the subsequence to insert.\n * @param endIndex the end (exclusive) of the subsequence to insert.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.insertRange(index: Int, value: CharSequence, startIndex: Int, endIndex: Int): StringBuilder\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\n@Deprecated(\"Use append(value: Any?) instead\", ReplaceWith(\"append(value = obj)\"), DeprecationLevel.WARNING)\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.append(obj: Any?): StringBuilder = this.append(obj)\n\n/**\n * Builds new string by populating newly created [StringBuilder] using provided [builderAction]\n * and then converting it to [String].\n */\n@kotlin.internal.InlineOnly\npublic inline fun buildString(builderAction: StringBuilder.() -> Unit): String {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return StringBuilder().apply(builderAction).toString()\n}\n\n/**\n * Builds new string by populating newly created [StringBuilder] initialized with the given [capacity]\n * using provided [builderAction] and then converting it to [String].\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun buildString(capacity: Int, builderAction: StringBuilder.() -> Unit): String {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return StringBuilder(capacity).apply(builderAction).toString()\n}\n\n/**\n * Appends all arguments to the given StringBuilder.\n */\npublic fun StringBuilder.append(vararg value: String?): StringBuilder {\n    for (item in value)\n        append(item)\n    return this\n}\n\n/**\n * Appends all arguments to the given StringBuilder.\n */\npublic fun StringBuilder.append(vararg value: Any?): StringBuilder {\n    for (item in value)\n        append(item)\n    return this\n}\n\n/** Appends a line feed character (`\\n`) to this StringBuilder. */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(): StringBuilder = append('\\n')\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: CharSequence?): StringBuilder = append(value).appendLine()\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: String?): StringBuilder = append(value).appendLine()\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: Any?): StringBuilder = append(value).appendLine()\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: CharArray): StringBuilder = append(value).appendLine()\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: Char): StringBuilder = append(value).appendLine()\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: Boolean): StringBuilder = append(value).appendLine()\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin\n\nimport kotlin.experimental.*\n\n@Suppress(\"NON_PUBLIC_PRIMARY_CONSTRUCTOR_OF_INLINE_CLASS\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline class UByte @PublishedApi internal constructor(@PublishedApi internal val data: Byte) : Comparable<UByte> {\n\n    companion object {\n        /**\n         * A constant holding the minimum value an instance of UByte can have.\n         */\n        public const val MIN_VALUE: UByte = UByte(0)\n\n        /**\n         * A constant holding the maximum value an instance of UByte can have.\n         */\n        public const val MAX_VALUE: UByte = UByte(-1)\n\n        /**\n         * The number of bytes used to represent an instance of UByte in a binary form.\n         */\n        public const val SIZE_BYTES: Int = 1\n\n        /**\n         * The number of bits used to represent an instance of UByte in a binary form.\n         */\n        public const val SIZE_BITS: Int = 8\n    }\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    @Suppress(\"OVERRIDE_BY_INLINE\")\n    public override inline operator fun compareTo(other: UByte): Int = this.toInt().compareTo(other.toInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UShort): Int = this.toInt().compareTo(other.toInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UInt): Int = this.toUInt().compareTo(other)\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: ULong): Int = this.toULong().compareTo(other)\n\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UByte): UInt = this.toUInt().plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UShort): UInt = this.toUInt().plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UInt): UInt = this.toUInt().plus(other)\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: ULong): ULong = this.toULong().plus(other)\n\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UByte): UInt = this.toUInt().minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UShort): UInt = this.toUInt().minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UInt): UInt = this.toUInt().minus(other)\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: ULong): ULong = this.toULong().minus(other)\n\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UByte): UInt = this.toUInt().times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UShort): UInt = this.toUInt().times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UInt): UInt = this.toUInt().times(other)\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: ULong): ULong = this.toULong().times(other)\n\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UByte): UInt = this.toUInt().div(other.toUInt())\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UShort): UInt = this.toUInt().div(other.toUInt())\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UInt): UInt = this.toUInt().div(other)\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: ULong): ULong = this.toULong().div(other)\n\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UByte): UInt = this.toUInt().rem(other.toUInt())\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UShort): UInt = this.toUInt().rem(other.toUInt())\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UInt): UInt = this.toUInt().rem(other)\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: ULong): ULong = this.toULong().rem(other)\n\n    /** Increments this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun inc(): UByte = UByte(data.inc())\n    /** Decrements this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun dec(): UByte = UByte(data.dec())\n\n    /** Creates a range from this value to the specified [other] value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rangeTo(other: UByte): UIntRange = UIntRange(this.toUInt(), other.toUInt())\n\n    /** Performs a bitwise AND operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun and(other: UByte): UByte = UByte(this.data and other.data)\n    /** Performs a bitwise OR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun or(other: UByte): UByte = UByte(this.data or other.data)\n    /** Performs a bitwise XOR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun xor(other: UByte): UByte = UByte(this.data xor other.data)\n    /** Inverts the bits in this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun inv(): UByte = UByte(data.inv())\n\n    /**\n     * Converts this [UByte] value to [Byte].\n     *\n     * If this value is less than or equals to [Byte.MAX_VALUE], the resulting `Byte` value represents\n     * the same numerical value as this `UByte`. Otherwise the result is negative.\n     *\n     * The resulting `Byte` value has the same binary representation as this `UByte` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toByte(): Byte = data\n    /**\n     * Converts this [UByte] value to [Short].\n     *\n     * The resulting `Short` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `Short` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 8 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toShort(): Short = data.toShort() and 0xFF\n    /**\n     * Converts this [UByte] value to [Int].\n     *\n     * The resulting `Int` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `Int` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 24 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toInt(): Int = data.toInt() and 0xFF\n    /**\n     * Converts this [UByte] value to [Long].\n     *\n     * The resulting `Long` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `Long` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 56 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toLong(): Long = data.toLong() and 0xFF\n\n    /** Returns this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun toUByte(): UByte = this\n    /**\n     * Converts this [UByte] value to [UShort].\n     *\n     * The resulting `UShort` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `UShort` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 8 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUShort(): UShort = UShort(data.toShort() and 0xFF)\n    /**\n     * Converts this [UByte] value to [UInt].\n     *\n     * The resulting `UInt` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `UInt` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 24 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUInt(): UInt = UInt(data.toInt() and 0xFF)\n    /**\n     * Converts this [UByte] value to [ULong].\n     *\n     * The resulting `ULong` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `ULong` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 56 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toULong(): ULong = ULong(data.toLong() and 0xFF)\n\n    /**\n     * Converts this [UByte] value to [Float].\n     *\n     * The resulting `Float` value represents the same numerical value as this `UByte`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toFloat(): Float = this.toInt().toFloat()\n    /**\n     * Converts this [UByte] value to [Double].\n     *\n     * The resulting `Double` value represents the same numerical value as this `UByte`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toDouble(): Double = this.toInt().toDouble()\n\n    public override fun toString(): String = toInt().toString()\n\n}\n\n/**\n * Converts this [Byte] value to [UByte].\n *\n * If this value is positive, the resulting `UByte` value represents the same numerical value as this `Byte`.\n *\n * The resulting `UByte` value has the same binary representation as this `Byte` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Byte.toUByte(): UByte = UByte(this)\n/**\n * Converts this [Short] value to [UByte].\n *\n * If this value is positive and less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n * the same numerical value as this `Short`.\n *\n * The resulting `UByte` value is represented by the least significant 8 bits of this `Short` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Short.toUByte(): UByte = UByte(this.toByte())\n/**\n * Converts this [Int] value to [UByte].\n *\n * If this value is positive and less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n * the same numerical value as this `Int`.\n *\n * The resulting `UByte` value is represented by the least significant 8 bits of this `Int` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Int.toUByte(): UByte = UByte(this.toByte())\n/**\n * Converts this [Long] value to [UByte].\n *\n * If this value is positive and less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n * the same numerical value as this `Long`.\n *\n * The resulting `UByte` value is represented by the least significant 8 bits of this `Long` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Long.toUByte(): UByte = UByte(this.toByte())\n","@file:Suppress(\"NOTHING_TO_INLINE\")\n\npackage io.ktor.utils.io.bits\n\nimport io.ktor.utils.io.core.internal.*\n\n\npublic actual inline fun Memory.loadShortAt(offset: Int): Short = view.getInt16(offset, false)\n\npublic actual inline fun Memory.loadShortAt(offset: Long): Short = loadShortAt(offset.toIntOrFail(\"offset\"))\n\npublic actual inline fun Memory.loadIntAt(offset: Int): Int = view.getInt32(offset, false)\n\npublic actual inline fun Memory.loadIntAt(offset: Long): Int = loadIntAt(offset.toIntOrFail(\"offset\"))\n\npublic actual inline fun Memory.loadLongAt(offset: Int): Long =\n    (view.getUint32(offset, false).toLong() shl 32) or\n        view.getUint32(offset + 4, false).toLong()\n\npublic actual inline fun Memory.loadLongAt(offset: Long): Long = loadLongAt(offset.toIntOrFail(\"offset\"))\n\npublic actual inline fun Memory.loadFloatAt(offset: Int): Float = view.getFloat32(offset, false)\n\npublic actual inline fun Memory.loadFloatAt(offset: Long): Float = loadFloatAt(offset.toIntOrFail(\"offset\"))\n\npublic actual inline fun Memory.loadDoubleAt(offset: Int): Double = view.getFloat64(offset, false)\n\npublic actual inline fun Memory.loadDoubleAt(offset: Long): Double = loadDoubleAt(offset.toIntOrFail(\"offset\"))\n\n/**\n * Write regular signed 32bit integer in the network byte order (Big Endian)\n */\npublic actual inline fun Memory.storeIntAt(offset: Int, value: Int) {\n    view.setInt32(offset, value, littleEndian = false)\n}\n\n/**\n * Write regular signed 32bit integer in the network byte order (Big Endian)\n */\npublic actual inline fun Memory.storeIntAt(offset: Long, value: Int) {\n    view.setInt32(offset.toIntOrFail(\"offset\"), value, littleEndian = false)\n}\n\n/**\n * Write short signed 16bit integer in the network byte order (Big Endian)\n */\npublic actual inline fun Memory.storeShortAt(offset: Int, value: Short) {\n    view.setInt16(offset, value, littleEndian = false)\n}\n\n/**\n * Write short signed 16bit integer in the network byte order (Big Endian)\n */\npublic actual inline fun Memory.storeShortAt(offset: Long, value: Short) {\n    view.setInt16(offset.toIntOrFail(\"offset\"), value, littleEndian = false)\n}\n\n/**\n * Write short signed 64bit integer in the network byte order (Big Endian)\n */\npublic actual inline fun Memory.storeLongAt(offset: Int, value: Long) {\n    view.setInt32(offset, (value shr 32).toInt(), littleEndian = false)\n    view.setInt32(offset + 4, (value and 0xffffffffL).toInt(), littleEndian = false)\n}\n\n/**\n * Write short signed 64bit integer in the network byte order (Big Endian)\n */\npublic actual inline fun Memory.storeLongAt(offset: Long, value: Long) {\n    storeLongAt(offset.toIntOrFail(\"offset\"), value)\n}\n\n/**\n * Write short signed 32bit floating point number in the network byte order (Big Endian)\n */\npublic actual inline fun Memory.storeFloatAt(offset: Int, value: Float) {\n    view.setFloat32(offset, value, littleEndian = false)\n}\n\n/**\n * Write short signed 32bit floating point number in the network byte order (Big Endian)\n */\npublic actual inline fun Memory.storeFloatAt(offset: Long, value: Float) {\n    view.setFloat32(offset.toIntOrFail(\"offset\"), value, littleEndian = false)\n}\n\n/**\n * Write short signed 64bit floating point number in the network byte order (Big Endian)\n */\npublic actual inline fun Memory.storeDoubleAt(offset: Int, value: Double) {\n    view.setFloat64(offset, value, littleEndian = false)\n}\n\n/**\n * Write short signed 64bit floating point number in the network byte order (Big Endian)\n */\npublic actual inline fun Memory.storeDoubleAt(offset: Long, value: Double) {\n    view.setFloat64(offset.toIntOrFail(\"offset\"), value, littleEndian = false)\n}\n","package io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.Memory\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Input.readFully(dst: ByteArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFullyBytesTemplate(offset, length) { src, dstOffset, count ->\n        src.readFully(dst, dstOffset, count)\n    }.requireNoRemaining()\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Input.readFully(dst: ShortArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFullyTemplate(offset, length, 2) { src, dstOffset, count ->\n        src.readFully(dst, dstOffset, count)\n    }.requireNoRemaining()\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Input.readFully(dst: IntArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFullyTemplate(offset, length, 4) { src, dstOffset, count ->\n        src.readFully(dst, dstOffset, count)\n    }.requireNoRemaining()\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Input.readFully(dst: LongArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFullyTemplate(offset, length, 8) { src, dstOffset, count ->\n        src.readFully(dst, dstOffset, count)\n    }.requireNoRemaining()\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Input.readFully(dst: FloatArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFullyTemplate(offset, length, 4) { src, dstOffset, count ->\n        src.readFully(dst, dstOffset, count)\n    }.requireNoRemaining()\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Input.readFully(dst: DoubleArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFullyTemplate(offset, length, 8) { src, dstOffset, count ->\n        src.readFully(dst, dstOffset, count)\n    }.requireNoRemaining()\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Input.readFully(dst: Buffer, length: Int = dst.writeRemaining) {\n    readFullyBytesTemplate(0, length) { src, _, count ->\n        src.readFully(dst, count)\n    }.requireNoRemaining()\n}\n\npublic fun Input.readFully(destination: Memory, destinationOffset: Int, length: Int) {\n    readFully(destination, destinationOffset.toLong(), length.toLong())\n}\n\npublic fun Input.readFully(destination: Memory, destinationOffset: Long, length: Long) {\n    if (readAvailable(destination, destinationOffset, length) != length) {\n        prematureEndOfStream(length)\n    }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Input.readAvailable(dst: ByteArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    return length - readFullyBytesTemplate(offset, length) { src, dstOffset, count ->\n        src.readFully(dst, dstOffset, count)\n    }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Input.readAvailable(dst: ShortArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    return length - readFullyTemplate(offset, length, 2) { src, dstOffset, count ->\n        src.readFully(dst, dstOffset, count)\n    }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Input.readAvailable(dst: IntArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    return length - readFullyTemplate(offset, length, 4) { src, dstOffset, count ->\n        src.readFully(dst, dstOffset, count)\n    }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Input.readAvailable(dst: LongArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    return length - readFullyTemplate(offset, length, 8) { src, dstOffset, count ->\n        src.readFully(dst, dstOffset, count)\n    }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Input.readAvailable(dst: FloatArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    return length - readFullyTemplate(offset, length, 4) { src, dstOffset, count ->\n        src.readFully(dst, dstOffset, count)\n    }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Input.readAvailable(dst: DoubleArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    return length - readFullyTemplate(offset, length, 8) { src, dstOffset, count ->\n        src.readFully(dst, dstOffset, count)\n    }\n}\n\npublic fun Input.readAvailable(dst: Buffer, length: Int = dst.writeRemaining): Int {\n    return length - readFullyBytesTemplate(0, length) { src, _, count ->\n        src.readFully(dst, count)\n    }\n}\n\npublic fun Input.readAvailable(destination: Memory, destinationOffset: Int, length: Int): Int {\n    return readAvailable(destination, destinationOffset.toLong(), length.toLong()).toInt()\n}\n\npublic fun Input.readAvailable(destination: Memory, destinationOffset: Long, length: Long): Long {\n    val remaining = readFullyBytesTemplate(destinationOffset, length) { src, srcOffset, dstOffset, count ->\n        src.copyTo(destination, srcOffset, count.toLong(), dstOffset)\n    }\n    val result = length - remaining\n    return when {\n        result == 0L && endOfInput -> -1\n        else -> result\n    }\n}\n\n/**\n * @return number of bytes remaining or 0 if all [length] bytes were copied\n */\nprivate inline fun Input.readFullyBytesTemplate(\n    initialDstOffset: Int,\n    length: Int,\n    readBlock: (src: Buffer, dstOffset: Int, count: Int) -> Unit\n): Int {\n    var remaining = length\n    var dstOffset = initialDstOffset\n\n    takeWhile { buffer ->\n        val count = minOf(remaining, buffer.readRemaining)\n        readBlock(buffer, dstOffset, count)\n        remaining -= count\n        dstOffset += count\n\n        remaining > 0\n    }\n\n    return remaining\n}\n\n/**\n * @return number of bytes remaining or 0 if all [length] bytes were copied\n */\nprivate inline fun Input.readFullyBytesTemplate(\n    initialDstOffset: Long,\n    length: Long,\n    readBlock: (src: Memory, srcOffset: Long, dstOffset: Long, count: Int) -> Unit\n): Long {\n    var remaining = length\n    var dstOffset = initialDstOffset\n\n    takeWhile { buffer ->\n        val count = minOf(remaining, buffer.readRemaining.toLong()).toInt()\n        readBlock(buffer.memory, buffer.readPosition.toLong(), dstOffset, count)\n        buffer.discardExact(count)\n        remaining -= count\n        dstOffset += count\n\n        remaining > 0\n    }\n\n    return remaining\n}\n\n/**\n * @return number of elements remaining or 0 if all [length] elements were copied\n */\nprivate inline fun Input.readFullyTemplate(\n    offset: Int,\n    length: Int,\n    componentSize: Int,\n    readBlock: (src: Buffer, dstOffset: Int, count: Int) -> Unit\n): Int {\n    var remaining = length\n    var dstOffset = offset\n\n    takeWhileSize { buffer ->\n        val count = minOf(remaining, buffer.readRemaining / componentSize)\n        readBlock(buffer, dstOffset, count)\n        remaining -= count\n        dstOffset += count\n\n        when {\n            remaining > 0 -> componentSize\n            else -> 0\n        }\n    }\n\n    return remaining\n}\n\n@Suppress(\"NOTHING_TO_INLINE\")\nprivate inline fun Int.requireNoRemaining() {\n    if (this > 0) {\n        prematureEndOfStream(this)\n    }\n}\n","package io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.Memory\nimport io.ktor.utils.io.core.internal.*\nimport io.ktor.utils.io.pool.*\nimport kotlin.contracts.*\n\n/**\n * A read-write facade to actual buffer of fixed size. Multiple views could share the same actual buffer.\n * Concurrent unsafe. The only concurrent-safe operation is [release].\n * In most cases [ByteReadPacket] and [BytePacketBuilder] should be used instead.\n */\n@Suppress(\"DIFFERENT_NAMES_FOR_THE_SAME_PARAMETER_IN_SUPERTYPES\", \"DEPRECATION\")\n@Deprecated(\"Use Memory, Input or Output instead.\")\npublic expect class IoBuffer : Input, Output, ChunkBuffer {\n\n    @Suppress(\"ConvertSecondaryConstructorToPrimary\")\n    public constructor(memory: Memory, origin: ChunkBuffer?)\n\n    @Deprecated(\n        \"Not supported anymore. All operations are big endian by default. \" +\n            \"Read/write with readXXXLittleEndian/writeXXXLittleEndian or \" +\n            \"do readXXX/writeXXX with X.reverseByteOrder() instead.\",\n        level = DeprecationLevel.ERROR\n    )\n    final override var byteOrder: ByteOrder\n\n    override fun close()\n\n    final override fun flush()\n\n    public fun release(pool: ObjectPool<IoBuffer>)\n\n    @Suppress(\"DEPRECATION\")\n    public companion object {\n        /**\n         * Number of bytes usually reserved in the end of chunk\n         * when several instances of [ChunkBuffer] are connected into a chain (usually inside of [ByteReadPacket]\n         * or [BytePacketBuilder])\n         */\n        @DangerousInternalIoApi\n        public val ReservedSize: Int\n\n        /**\n         * The empty buffer singleton: it has zero capacity for read and write.\n         */\n        public val Empty: IoBuffer\n\n        /**\n         * The default buffer pool\n         */\n        public val Pool: ObjectPool<IoBuffer>\n\n        /**\n         * Pool that always instantiates new buffers instead of reusing it\n         */\n        public val NoPool: ObjectPool<IoBuffer>\n\n        /**\n         * A pool that always returns [IoBuffer.Empty]\n         */\n        public val EmptyPool: ObjectPool<IoBuffer>\n    }\n}\n\n/**\n * Read the specified number of bytes specified (optional, read all remaining by default)\n */\npublic fun Buffer.readBytes(count: Int = readRemaining): ByteArray {\n    if (count == 0) {\n        return EmptyByteArray\n    }\n\n    val result = ByteArray(count)\n    readFully(result)\n    return result\n}\n\n@Suppress(\"DEPRECATION\")\ninternal fun IoBuffer.releaseImpl(pool: ObjectPool<IoBuffer>) {\n    if (release()) {\n        val origin = origin\n        if (origin is IoBuffer) {\n            unlink()\n            origin.release(pool)\n        } else {\n            pool.recycle(this)\n        }\n    }\n}\n\n@Suppress(\"DEPRECATION\", \"DEPRECATION_ERROR\")\ninternal object EmptyBufferPoolImpl : NoPoolImpl<IoBuffer>() {\n    override fun borrow() = IoBuffer.Empty\n}\n\ninternal tailrec fun ChunkBuffer?.releaseAll(pool: ObjectPool<ChunkBuffer>) {\n    if (this == null) return\n    val next = cleanNext()\n    release(pool)\n    next.releaseAll(pool)\n}\n\ninternal inline fun ChunkBuffer.forEachChunk(block: (ChunkBuffer) -> Unit) {\n    contract {\n        callsInPlace(block, InvocationKind.AT_LEAST_ONCE)\n    }\n    var current = this\n    do {\n        block(current)\n        current = current.next ?: break\n    } while (true)\n}\n\n/**\n * Copy every element of the chain starting from this and setup next links.\n */\ninternal fun ChunkBuffer.copyAll(): ChunkBuffer {\n    val copied = duplicate()\n    val next = this.next ?: return copied\n\n    return next.copyAll(copied, copied)\n}\n\nprivate tailrec fun ChunkBuffer.copyAll(head: ChunkBuffer, prev: ChunkBuffer): ChunkBuffer {\n    val copied = duplicate()\n    prev.next = copied\n\n    val next = this.next ?: return head\n\n    return next.copyAll(head, copied)\n}\n\ninternal tailrec fun ChunkBuffer.findTail(): ChunkBuffer {\n    val next = this.next ?: return this\n    return next.findTail()\n}\n\n/**\n * Summarize remainings of all elements of the chain\n */\n@DangerousInternalIoApi\npublic fun ChunkBuffer.remainingAll(): Long = remainingAll(0L)\n\n@Suppress(\"DEPRECATION\", \"UNUSED\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\npublic fun remainingAll(buffer: IoBuffer): Long = buffer.remainingAll()\n\nprivate tailrec fun ChunkBuffer.remainingAll(n: Long): Long {\n    val rem = readRemaining.toLong() + n\n    val next = this.next ?: return rem\n\n    return next.remainingAll(rem)\n}\n\ninternal tailrec fun ChunkBuffer.isEmpty(): Boolean {\n    if (readRemaining > 0) return false\n    val next = this.next ?: return true\n    return next.isEmpty()\n}\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal inline fun Long.coerceAtMostMaxInt(): Int = minOf(this, Int.MAX_VALUE.toLong()).toInt()\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal inline fun Long.coerceAtMostMaxIntOrFail(message: String): Int {\n    if (this > Int.MAX_VALUE.toLong()) throw IllegalArgumentException(message)\n    return this.toInt()\n}\n\ninternal fun Buffer.peekTo(destination: Memory, destinationOffset: Long, offset: Long, min: Long, max: Long): Long {\n    val size = minOf(\n        destination.size - destinationOffset,\n        max,\n        readRemaining.toLong()\n    )\n\n    memory.copyTo(\n        destination,\n        readPosition + offset,\n        size,\n        destinationOffset\n    )\n\n    return size\n}\n\npublic class BufferLimitExceededException(message: String) : Exception(message)\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StandardKt\")\npackage kotlin\n\nimport kotlin.contracts.*\n\n/**\n * An exception is thrown to indicate that a method body remains to be implemented.\n */\npublic class NotImplementedError(message: String = \"An operation is not implemented.\") : Error(message)\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n */\n\n@kotlin.internal.InlineOnly\npublic inline fun TODO(): Nothing = throw NotImplementedError()\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n *\n * @param reason a string explaining why the implementation is missing.\n */\n@kotlin.internal.InlineOnly\npublic inline fun TODO(reason: String): Nothing = throw NotImplementedError(\"An operation is not implemented: $reason\")\n\n\n\n/**\n * Calls the specified function [block] and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <R> run(block: () -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.run(block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with the given [receiver] as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#with).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> with(receiver: T, block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return receiver.block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#apply).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> T.apply(block: T.() -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block()\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#also).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.also(block: (T) -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block(this)\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#let).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.let(block: (T) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block(this)\n}\n\n/**\n * Returns `this` value if it satisfies the given [predicate] or `null`, if it doesn't.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#takeif-and-takeunless).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeIf(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (predicate(this)) this else null\n}\n\n/**\n * Returns `this` value if it _does not_ satisfy the given [predicate] or `null`, if it does.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#takeif-and-takeunless).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeUnless(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (!predicate(this)) this else null\n}\n\n/**\n * Executes the given function [action] specified number of [times].\n *\n * A zero-based index of current iteration is passed as a parameter to [action].\n *\n * @sample samples.misc.ControlFlow.repeat\n */\n@kotlin.internal.InlineOnly\npublic inline fun repeat(times: Int, action: (Int) -> Unit) {\n    contract { callsInPlace(action) }\n\n    for (index in 0 until times) {\n        action(index)\n    }\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines\n\nimport kotlin.contracts.*\nimport kotlin.coroutines.intrinsics.*\nimport kotlin.internal.InlineOnly\n\n/**\n * Interface representing a continuation after a suspension point that returns a value of type `T`.\n */\n@SinceKotlin(\"1.3\")\npublic interface Continuation<in T> {\n    /**\n     * The context of the coroutine that corresponds to this continuation.\n     */\n    public val context: CoroutineContext\n\n    /**\n     * Resumes the execution of the corresponding coroutine passing a successful or failed [result] as the\n     * return value of the last suspension point.\n     */\n    public fun resumeWith(result: Result<T>)\n}\n\n/**\n * Classes and interfaces marked with this annotation are restricted when used as receivers for extension\n * `suspend` functions. These `suspend` extensions can only invoke other member or extension `suspend` functions on this particular\n * receiver and are restricted from calling arbitrary suspension functions.\n */\n@SinceKotlin(\"1.3\")\n@Target(AnnotationTarget.CLASS)\n@Retention(AnnotationRetention.BINARY)\npublic annotation class RestrictsSuspension\n\n/**\n * Resumes the execution of the corresponding coroutine passing [value] as the return value of the last suspension point.\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic inline fun <T> Continuation<T>.resume(value: T): Unit =\n    resumeWith(Result.success(value))\n\n/**\n * Resumes the execution of the corresponding coroutine so that the [exception] is re-thrown right after the\n * last suspension point.\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic inline fun <T> Continuation<T>.resumeWithException(exception: Throwable): Unit =\n    resumeWith(Result.failure(exception))\n\n\n/**\n * Creates a [Continuation] instance with the given [context] and implementation of [resumeWith] method.\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic inline fun <T> Continuation(\n    context: CoroutineContext,\n    crossinline resumeWith: (Result<T>) -> Unit\n): Continuation<T> =\n    object : Continuation<T> {\n        override val context: CoroutineContext\n            get() = context\n\n        override fun resumeWith(result: Result<T>) =\n            resumeWith(result)\n    }\n\n/**\n * Creates a coroutine without a receiver and with result type [T].\n * This function creates a new, fresh instance of suspendable computation every time it is invoked.\n *\n * To start executing the created coroutine, invoke `resume(Unit)` on the returned [Continuation] instance.\n * The [completion] continuation is invoked when the coroutine completes with a result or an exception.\n * Subsequent invocation of any resume function on the resulting continuation will produce an [IllegalStateException].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"UNCHECKED_CAST\")\npublic fun <T> (suspend () -> T).createCoroutine(\n    completion: Continuation<T>\n): Continuation<Unit> =\n    SafeContinuation(createCoroutineUnintercepted(completion).intercepted(), COROUTINE_SUSPENDED)\n\n/**\n * Creates a coroutine with receiver type [R] and result type [T].\n * This function creates a new, fresh instance of suspendable computation every time it is invoked.\n *\n * To start executing the created coroutine, invoke `resume(Unit)` on the returned [Continuation] instance.\n * The [completion] continuation is invoked when the coroutine completes with a result or an exception.\n * Subsequent invocation of any resume function on the resulting continuation will produce an [IllegalStateException].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"UNCHECKED_CAST\")\npublic fun <R, T> (suspend R.() -> T).createCoroutine(\n    receiver: R,\n    completion: Continuation<T>\n): Continuation<Unit> =\n    SafeContinuation(createCoroutineUnintercepted(receiver, completion).intercepted(), COROUTINE_SUSPENDED)\n\n/**\n * Starts a coroutine without a receiver and with result type [T].\n * This function creates and starts a new, fresh instance of suspendable computation every time it is invoked.\n * The [completion] continuation is invoked when the coroutine completes with a result or an exception.\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"UNCHECKED_CAST\")\npublic fun <T> (suspend () -> T).startCoroutine(\n    completion: Continuation<T>\n) {\n    createCoroutineUnintercepted(completion).intercepted().resume(Unit)\n}\n\n/**\n * Starts a coroutine with receiver type [R] and result type [T].\n * This function creates and starts a new, fresh instance of suspendable computation every time it is invoked.\n * The [completion] continuation is invoked when the coroutine completes with a result or an exception.\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"UNCHECKED_CAST\")\npublic fun <R, T> (suspend R.() -> T).startCoroutine(\n    receiver: R,\n    completion: Continuation<T>\n) {\n    createCoroutineUnintercepted(receiver, completion).intercepted().resume(Unit)\n}\n\n/**\n * Obtains the current continuation instance inside suspend functions and suspends\n * the currently running coroutine.\n *\n * In this function both [Continuation.resume] and [Continuation.resumeWithException] can be used either synchronously in\n * the same stack-frame where the suspension function is run or asynchronously later in the same thread or\n * from a different thread of execution. Subsequent invocation of any resume function will produce an [IllegalStateException].\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic suspend inline fun <T> suspendCoroutine(crossinline block: (Continuation<T>) -> Unit): T {\n    contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }\n    return suspendCoroutineUninterceptedOrReturn { c: Continuation<T> ->\n        val safe = SafeContinuation(c.intercepted())\n        block(safe)\n        safe.getOrThrow()\n    }\n}\n\n/**\n * Returns the context of the current coroutine.\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"WRONG_MODIFIER_TARGET\")\n@InlineOnly\npublic suspend inline val coroutineContext: CoroutineContext\n    get() {\n        throw NotImplementedError(\"Implemented as intrinsic\")\n    }\n","/*\n * Copyright 2016-2017 JetBrains s.r.o.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage io.ktor.utils.io\n\nimport kotlinx.coroutines.*\nimport io.ktor.utils.io.charsets.*\nimport io.ktor.utils.io.core.*\n\n/**\n * Channel for asynchronous reading and writing of sequences of bytes.\n * This is a buffered **single-reader single-writer channel**.\n *\n * Read operations can be invoked concurrently with write operations, but multiple reads or multiple writes\n * cannot be invoked concurrently with themselves. Exceptions are [close] and [flush] which can be invoked\n * concurrently with any other operations and between themselves at any time.\n */\npublic interface ByteChannel : ByteReadChannel, ByteWriteChannel {\n    public fun attachJob(job: Job)\n}\n\n/**\n * Creates buffered channel for asynchronous reading and writing of sequences of bytes.\n */\npublic expect fun ByteChannel(autoFlush: Boolean = false): ByteChannel\n\n/**\n * Creates channel for reading from the specified byte array. Please note that it could use [content] directly\n * or copy it's bytes depending on the platform.\n */\npublic fun ByteReadChannel(content: ByteArray): ByteReadChannel =\n    ByteReadChannel(content, 0, content.size)\n\n/**\n * Creates channel for reading from the specified byte array. Please note that it could use [content] directly\n * or copy it's bytes depending on the platform.\n */\npublic fun ByteReadChannel(content: ByteArray, offset: Int): ByteReadChannel =\n    ByteReadChannel(content, offset, content.size)\n\n/**\n * Creates channel for reading from the specified byte array. Please note that it could use [content] directly\n * or copy it's bytes depending on the platform\n */\npublic expect fun ByteReadChannel(content: ByteArray, offset: Int, length: Int): ByteReadChannel\n\npublic fun ByteReadChannel(text: String, charset: Charset = Charsets.UTF_8): ByteReadChannel =\n    ByteReadChannel(text.toByteArray(charset)) // TODO optimize to encode parts on demand\n\n\n/**\n * Byte channel that is always empty.\n */\n@Deprecated(\n    \"Use ByteReadChannel.Empty instead\", ReplaceWith(\"ByteReadChannel.Empty\"),\n    level = DeprecationLevel.ERROR\n)\npublic val EmptyByteReadChannel: ByteReadChannel\n    get() = ByteReadChannel.Empty\n\n","package io.ktor.utils.io.core.internal\n\nimport kotlin.contracts.*\n\n@PublishedApi\ninternal inline fun require(condition: Boolean, crossinline message: () -> String) {\n    contract {\n        returns() implies condition\n    }\n\n    if (!condition) {\n        val m = object : RequireFailureCapture() {\n            override fun doFail(): Nothing {\n                throw IllegalArgumentException(message())\n            }\n        }\n        m.doFail()\n    }\n}\n\n@PublishedApi\ninternal abstract class RequireFailureCapture {\n    abstract fun doFail(): Nothing\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.comparisons\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.js.*\n\n/**\n * Returns the greater of two values.\n * \n * If values are equal, returns the first one.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> maxOf(a: T, b: T): T {\n    return if (a >= b) a else b\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Byte, b: Byte): Byte {\n    return Math.max(a.toInt(), b.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Short, b: Short): Short {\n    return Math.max(a.toInt(), b.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Int, b: Int): Int {\n    return Math.max(a, b)\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@Suppress(\"DEPRECATION_ERROR\", \"NOTHING_TO_INLINE\")\npublic actual inline fun maxOf(a: Long, b: Long): Long {\n    return if (a >= b) a else b\n}\n\n/**\n * Returns the greater of two values.\n * \n * If either value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Float, b: Float): Float {\n    return Math.max(a, b)\n}\n\n/**\n * Returns the greater of two values.\n * \n * If either value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Double, b: Double): Double {\n    return Math.max(a, b)\n}\n\n/**\n * Returns the greater of three values.\n * \n * If there are multiple equal maximal values, returns the first of them.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> maxOf(a: T, b: T, c: T): T {\n    return maxOf(a, maxOf(b, c))\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Byte, b: Byte, c: Byte): Byte {\n    return Math.max(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Short, b: Short, c: Short): Short {\n    return Math.max(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Int, b: Int, c: Int): Int {\n    return Math.max(a, b, c)\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Long, b: Long, c: Long): Long {\n    return maxOf(a, maxOf(b, c))\n}\n\n/**\n * Returns the greater of three values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Float, b: Float, c: Float): Float {\n    return Math.max(a, b, c)\n}\n\n/**\n * Returns the greater of three values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Double, b: Double, c: Double): Double {\n    return Math.max(a, b, c)\n}\n\n/**\n * Returns the greater of the given values.\n * \n * If there are multiple equal maximal values, returns the first of them.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun <T : Comparable<T>> maxOf(a: T, vararg other: T): T {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Byte, vararg other: Byte): Byte {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Short, vararg other: Short): Short {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Int, vararg other: Int): Int {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Long, vararg other: Long): Long {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Float, vararg other: Float): Float {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Double, vararg other: Double): Double {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the smaller of two values.\n * \n * If values are equal, returns the first one.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> minOf(a: T, b: T): T {\n    return if (a <= b) a else b\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Byte, b: Byte): Byte {\n    return Math.min(a.toInt(), b.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Short, b: Short): Short {\n    return Math.min(a.toInt(), b.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Int, b: Int): Int {\n    return Math.min(a, b)\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@Suppress(\"DEPRECATION_ERROR\", \"NOTHING_TO_INLINE\")\npublic actual inline fun minOf(a: Long, b: Long): Long {\n    return if (a <= b) a else b\n}\n\n/**\n * Returns the smaller of two values.\n * \n * If either value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Float, b: Float): Float {\n    return Math.min(a, b)\n}\n\n/**\n * Returns the smaller of two values.\n * \n * If either value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Double, b: Double): Double {\n    return Math.min(a, b)\n}\n\n/**\n * Returns the smaller of three values.\n * \n * If there are multiple equal minimal values, returns the first of them.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> minOf(a: T, b: T, c: T): T {\n    return minOf(a, minOf(b, c))\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Byte, b: Byte, c: Byte): Byte {\n    return Math.min(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Short, b: Short, c: Short): Short {\n    return Math.min(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Int, b: Int, c: Int): Int {\n    return Math.min(a, b, c)\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Long, b: Long, c: Long): Long {\n    return minOf(a, minOf(b, c))\n}\n\n/**\n * Returns the smaller of three values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Float, b: Float, c: Float): Float {\n    return Math.min(a, b, c)\n}\n\n/**\n * Returns the smaller of three values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Double, b: Double, c: Double): Double {\n    return Math.min(a, b, c)\n}\n\n/**\n * Returns the smaller of the given values.\n * \n * If there are multiple equal minimal values, returns the first of them.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun <T : Comparable<T>> minOf(a: T, vararg other: T): T {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Byte, vararg other: Byte): Byte {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Short, vararg other: Short): Short {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Int, vararg other: Int): Int {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Long, vararg other: Long): Long {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Float, vararg other: Float): Float {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Double, vararg other: Double): Double {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n","@file:Suppress(\"NOTHING_TO_INLINE\")\n\npackage io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.concurrent.*\nimport io.ktor.utils.io.core.internal.*\nimport io.ktor.utils.io.errors.EOFException\nimport kotlin.contracts.*\n\n/**\n * Represents a buffer with read and write positions.\n *\n * Concurrent unsafe: the same memory could be shared between different instances of [Buffer] however you can't\n * read/write using the same [Buffer] instance from different threads.\n */\n@DangerousInternalIoApi\npublic open class Buffer(public val memory: Memory) {\n    private val bufferState: BufferSharedState = BufferSharedState(memory.size32)\n\n    /**\n     * Current read position. It is always non-negative and will never run ahead of the [writePosition].\n     * It is usually greater or equal to [startGap] reservation.\n     * This position is affected by [discard], [rewind], [resetForRead], [resetForWrite], [reserveStartGap]\n     * and [reserveEndGap].\n     */\n    public var readPosition: Int\n        get() = bufferState.readPosition\n        private set(value) {\n            bufferState.readPosition = value\n        }\n\n    /**\n     * Current write position. It is always non-negative and will never run ahead of the [limit].\n     * It is always greater or equal to the [readPosition].\n     * * This position is affected by [resetForRead], [resetForWrite], [reserveStartGap]\n     * and [reserveEndGap].\n     */\n    public var writePosition: Int\n        get() = bufferState.writePosition\n        private set(value) {\n            bufferState.writePosition = value\n        }\n    /**\n     * Start gap is a reserved space in the beginning. The reserved space is usually used to write a packet length\n     * in the case when it's not known before the packet constructed.\n     */\n    public var startGap: Int\n        get() = bufferState.startGap\n        private set(value) {\n            bufferState.startGap = value\n        }\n\n    /**\n     * Write position limit. No bytes could be written ahead of this limit. When the limit is less than the [capacity]\n     * then this means that there are reserved bytes in the end ([endGap]). Such a reserved space in the end could be used\n     * to write size, hash and so on. Also it is useful when several buffers are connected into a chain and some\n     * primitive value (e.g. `kotlin.Int`) is separated into two chunks so bytes from the second chain could be copied\n     * to the reserved space of the first chunk and then the whole value could be read at once.\n     */\n    public var limit: Int\n        get() = bufferState.limit\n        private set(value) {\n            bufferState.limit = value\n        }\n\n    /**\n     * Number of bytes reserved in the end.\n     */\n    public inline val endGap: Int get() = capacity - limit\n\n    /**\n     * Buffer's capacity (including reserved [startGap] and [endGap]. Value for released buffer is unspecified.\n     */\n    public val capacity: Int = memory.size32\n\n    /**\n     * Number of bytes available for reading.\n     */\n    public inline val readRemaining: Int get() = writePosition - readPosition\n\n    /**\n     * Size of the free space available for writing in bytes.\n     */\n    public inline val writeRemaining: Int get() = limit - writePosition\n\n    /**\n     * User data: could be a session, connection or anything useful\n     */\n    @Deprecated(\"Will be removed. Inherit Buffer and add required fields instead.\")\n    @ExperimentalIoApi\n    public var attachment: Any?\n        get() = bufferState.attachment\n        set(value) {\n            bufferState.attachment = value\n        }\n\n    /**\n     * Discard [count] readable bytes.\n     *\n     * @throws EOFException if [count] is bigger than available bytes.\n     */\n    public fun discardExact(count: Int = readRemaining) {\n        if (count == 0) return\n\n        val newReadPosition = readPosition + count\n        if (count < 0 || newReadPosition > writePosition) {\n            discardFailed(count, readRemaining)\n        }\n        readPosition = newReadPosition\n    }\n\n    @Deprecated(\"Use discardExact instead.\", level = DeprecationLevel.ERROR)\n    public fun discard(count: Int): Int {\n        val size = minOf(count, readRemaining)\n        discardExact(size)\n        return size\n    }\n\n    @Deprecated(\"Use discardExact instead.\", level = DeprecationLevel.ERROR)\n    public final fun discard(count: Long): Long {\n        val size = minOf(count, readRemaining.toLong()).toInt()\n        discardExact(size)\n        return size.toLong()\n    }\n\n    @DangerousInternalIoApi\n    public fun commitWritten(count: Int) {\n        val newWritePosition = writePosition + count\n        if (count < 0 || newWritePosition > limit) {\n            commitWrittenFailed(count, writeRemaining)\n        }\n        writePosition = newWritePosition\n    }\n\n    /**\n     * @return `true` if there is free space\n     */\n    @PublishedApi\n    internal fun commitWrittenUntilIndex(position: Int): Boolean {\n        val limit = limit\n        if (position < writePosition) {\n            commitWrittenFailed(position - writePosition, writeRemaining)\n        }\n        if (position >= limit) {\n            if (position == limit) {\n                writePosition = position\n                return false\n            }\n            commitWrittenFailed(position - writePosition, writeRemaining)\n        }\n\n        writePosition = position\n        return true\n    }\n\n    internal fun discardUntilIndex(position: Int) {\n        if (position < 0 || position > writePosition) {\n            discardFailed(position - readPosition, readRemaining)\n        }\n\n        if (readPosition != position) {\n            readPosition = position\n        }\n    }\n\n    /**\n     * Rewind [readPosition] backward to make [count] bytes available for reading again.\n     * @throws IllegalArgumentException when [count] is too big and not enough bytes available before the [readPosition]\n     */\n    public fun rewind(count: Int = readPosition - startGap) {\n        val newReadPosition = readPosition - count\n        if (newReadPosition < startGap) {\n            rewindFailed(count, readPosition - startGap)\n        }\n        readPosition = newReadPosition\n    }\n\n    /**\n     * Reserve [startGap] bytes in the beginning.\n     * May move [readPosition] and [writePosition] if no bytes available for reading.\n     */\n    public fun reserveStartGap(startGap: Int) {\n        require(startGap >= 0) { \"startGap shouldn't be negative: $startGap\" }\n\n        if (readPosition >= startGap) {\n            this.startGap = startGap\n            return\n        }\n\n        if (readPosition == writePosition) {\n            if (startGap > limit) {\n                startGapReservationFailedDueToLimit(startGap)\n            }\n\n            this.writePosition = startGap\n            this.readPosition = startGap\n            this.startGap = startGap\n            return\n        }\n\n        startGapReservationFailed(startGap)\n    }\n\n    /**\n     * Reserve [endGap] bytes in the end.\n     * Could move [readPosition] and [writePosition] to reserve space but only when no bytes were written or\n     * all written bytes are marked as consumed (were read or discarded).\n     */\n    public fun reserveEndGap(endGap: Int) {\n        require(endGap >= 0) { \"endGap shouldn't be negative: $endGap\" }\n\n        val newLimit = capacity - endGap\n        if (newLimit >= writePosition) {\n            limit = newLimit\n            return\n        }\n\n        if (newLimit < 0) {\n            endGapReservationFailedDueToCapacity(endGap)\n        }\n        if (newLimit < startGap) {\n            endGapReservationFailedDueToStartGap(endGap)\n        }\n\n        if (readPosition == writePosition) {\n            limit = newLimit\n            readPosition = newLimit\n            writePosition = newLimit\n            return\n        }\n\n        endGapReservationFailedDueToContent(endGap)\n    }\n\n    /**\n     * Marks the whole buffer available for read and no for write\n     */\n    public fun resetForRead() {\n        startGap = 0\n        readPosition = 0\n\n        val capacity = capacity\n        writePosition = capacity\n    }\n\n    /**\n     * Marks all capacity writable except the start gap reserved before. The end gap reservation is discarded.\n     */\n    public fun resetForWrite() {\n        resetForWrite(capacity - startGap)\n    }\n\n    /**\n     * Marks up to [limit] bytes of the buffer available for write and no bytes for read.\n     * It does respect [startGap] already reserved. All extra bytes after the specified [limit]\n     * are considered as [endGap].\n     */\n    public fun resetForWrite(limit: Int) {\n        val startGap = startGap\n        readPosition = startGap\n        writePosition = startGap\n        this.limit = limit\n    }\n\n    /**\n     * Forget start/end gap reservations.\n     */\n    internal fun releaseGaps() {\n        releaseStartGap(0)\n        releaseEndGap()\n    }\n\n    internal fun releaseEndGap() {\n        limit = capacity\n    }\n\n    internal fun releaseStartGap(newReadPosition: Int) {\n        require(newReadPosition >= 0) { \"newReadPosition shouldn't be negative: $newReadPosition\" }\n        require(newReadPosition <= readPosition) {\n            \"newReadPosition shouldn't be ahead of the read position: $newReadPosition > $readPosition\"\n        }\n\n        readPosition = newReadPosition\n        if (startGap > newReadPosition) {\n            startGap = newReadPosition\n        }\n    }\n\n    protected open fun duplicateTo(copy: Buffer) {\n        copy.limit = limit\n        copy.startGap = startGap\n        copy.readPosition = readPosition\n        copy.writePosition = writePosition\n    }\n\n    /**\n     * Create a new [Buffer] instance pointing to the same memory and having the same positions.\n     */\n    public open fun duplicate(): Buffer = Buffer(memory).apply {\n        duplicateTo(this)\n    }\n\n    /**\n     * Peek the next unsigned byte or return `-1` if no more bytes available for reading. No bytes will be marked\n     * as consumed in any case.\n     * @return an unsigned byte or `-1` if not even a byte is available for reading.\n     * @see tryReadByte\n     * @see readByte\n     */\n    public fun tryPeekByte(): Int {\n        val readPosition = readPosition\n        if (readPosition == writePosition) return -1\n        return memory[readPosition].toInt() and 0xff\n    }\n\n    /**\n     * Read the next unsigned byte or return `-1` if no more bytes available for reading. The returned byte is marked\n     * as consumed.\n     * @return an unsigned byte or `-1` if not even a byte is available for reading.\n     * @see tryPeekByte\n     * @see readByte\n     */\n    public fun tryReadByte(): Int {\n        val readPosition = readPosition\n        if (readPosition == writePosition) return -1\n        this.readPosition = readPosition + 1\n        return memory[readPosition].toInt() and 0xff\n    }\n\n    /**\n     * Read the next byte or fail with [EOFException] if it's not available. The returned byte is marked\n     * as consumed.\n     * @throws EOFException when not even a byte is available for reading.\n     * @see tryPeekByte\n     * @see tryReadByte\n     */\n    public fun readByte(): Byte {\n        val readPosition = readPosition\n        if (readPosition == writePosition) {\n            throw EOFException(\"No readable bytes available.\")\n        }\n        this.readPosition = readPosition + 1\n        return memory[readPosition]\n    }\n\n    /**\n     * Write a byte [value] at [writePosition] (incremented when written successfully).\n     * @throws InsufficientSpaceException when no free space in the buffer.\n     */\n    public fun writeByte(value: Byte) {\n        val writePosition = writePosition\n        if (writePosition == limit) {\n            throw InsufficientSpaceException(\"No free space in the buffer to write a byte\")\n        }\n        memory[writePosition] = value\n        this.writePosition = writePosition + 1\n    }\n\n    /**\n     * Clear buffer's state: read/write positions, gaps and so on. Byte content is not cleaned-up.\n     */\n    public open fun reset() {\n        releaseGaps()\n        resetForWrite()\n    }\n\n    override fun toString(): String {\n        return \"Buffer($readRemaining used, $writeRemaining free, ${startGap + endGap} reserved of $capacity)\"\n    }\n\n    public companion object {\n        /**\n         * Number of bytes usually reserved in the end of chunk\n         * when several instances of [io.ktor.utils.io.core.internal.ChunkBuffer] are connected into a chain (usually inside of [ByteReadPacket]\n         * or [BytePacketBuilder])\n         */\n        @DangerousInternalIoApi\n        public const val ReservedSize: Int = 8\n\n        /**\n         * The empty buffer singleton: it has zero capacity for read and write.\n         */\n        @Suppress(\"DEPRECATION\")\n        public val Empty: Buffer get() = IoBuffer.Empty\n    }\n}\n\n/**\n * @return `true` if there are available bytes to be read\n */\npublic inline fun Buffer.canRead(): Boolean = writePosition > readPosition\n\n/**\n * @return `true` if there is free room to for write\n */\npublic inline fun Buffer.canWrite(): Boolean = limit > writePosition\n\n/**\n * Apply [block] of code with buffer's memory providing read range indices. The returned value of [block] lambda should\n * return number of bytes to be marked as consumed.\n * No read/write functions on this buffer should be called inside of [block] otherwise an undefined behaviour may occur\n * including data damage.\n */\n@DangerousInternalIoApi\npublic inline fun Buffer.read(block: (memory: Memory, start: Int, endExclusive: Int) -> Int): Int {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n\n    val rc = block(memory, readPosition, writePosition)\n    discardExact(rc)\n    return rc\n}\n\n/**\n * Apply [block] of code with buffer's memory providing write range indices. The returned value of [block] lambda should\n * return number of bytes were written.\n * o read/write functions on this buffer should be called inside of [block] otherwise an undefined behaviour may occur\n * including data damage.\n */\n@DangerousInternalIoApi\npublic inline fun Buffer.write(block: (memory: Memory, start: Int, endExclusive: Int) -> Int): Int {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n\n    val rc = block(memory, writePosition, limit)\n    commitWritten(rc)\n    return rc\n}\n\ninternal fun discardFailed(count: Int, readRemaining: Int): Nothing {\n    throw EOFException(\"Unable to discard $count bytes: only $readRemaining available for reading\")\n}\n\ninternal fun commitWrittenFailed(count: Int, writeRemaining: Int): Nothing {\n    throw EOFException(\"Unable to discard $count bytes: only $writeRemaining available for writing\")\n}\n\ninternal fun rewindFailed(count: Int, rewindRemaining: Int): Nothing {\n    throw IllegalArgumentException(\"Unable to rewind $count bytes: only $rewindRemaining could be rewinded\")\n}\n\ninternal fun Buffer.startGapReservationFailedDueToLimit(startGap: Int): Nothing {\n    if (startGap > capacity) {\n        throw IllegalArgumentException(\"Start gap $startGap is bigger than the capacity $capacity\")\n    }\n\n    throw IllegalStateException(\n        \"Unable to reserve $startGap start gap: there are already $endGap bytes reserved in the end\"\n    )\n}\n\ninternal fun Buffer.startGapReservationFailed(startGap: Int): Nothing {\n    throw IllegalStateException(\n        \"Unable to reserve $startGap start gap: \" +\n            \"there are already $readRemaining content bytes starting at offset $readPosition\"\n    )\n}\n\ninternal fun Buffer.endGapReservationFailedDueToCapacity(endGap: Int) {\n    throw IllegalArgumentException(\"End gap $endGap is too big: capacity is $capacity\")\n}\n\n\ninternal fun Buffer.endGapReservationFailedDueToStartGap(endGap: Int) {\n    throw IllegalArgumentException(\n        \"End gap $endGap is too big: there are already $startGap bytes reserved in the beginning\"\n    )\n}\n\ninternal fun Buffer.endGapReservationFailedDueToContent(endGap: Int) {\n    throw IllegalArgumentException(\n        \"Unable to reserve end gap $endGap:\" +\n            \" there are already $readRemaining content bytes at offset $readPosition\"\n    )\n}\n\ninternal fun Buffer.restoreStartGap(size: Int) {\n    releaseStartGap(readPosition - size)\n}\n\n@ExperimentalIoApi\npublic class InsufficientSpaceException(message: String = \"Not enough free space\") : Exception(message) {\n    public constructor(\n        size: Int,\n        availableSpace: Int\n    ) : this(\"Not enough free space to write $size bytes, available $availableSpace bytes.\")\n\n    public constructor(\n        name: String,\n        size: Int,\n        availableSpace: Int\n    ) : this(\"Not enough free space to write $name of $size bytes, available $availableSpace bytes.\")\n\n    public constructor(\n        size: Long,\n        availableSpace: Long\n    ) : this(\"Not enough free space to write $size bytes, available $availableSpace bytes.\")\n}\n","package io.ktor.utils.io\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.core.*\n\n/**\n * Channel for asynchronous reading of sequences of bytes.\n * This is a **single-reader channel**.\n *\n * Operations on this channel cannot be invoked concurrently.\n */\npublic expect interface ByteReadChannel {\n    /**\n     * Returns number of bytes that can be read without suspension. Read operations do no suspend and return\n     * immediately when this number is at least the number of bytes requested for read.\n     */\n    public val availableForRead: Int\n\n    /**\n     * Returns `true` if the channel is closed and no remaining bytes are available for read.\n     * It implies that [availableForRead] is zero.\n     */\n    public val isClosedForRead: Boolean\n\n    public val isClosedForWrite: Boolean\n\n    /**\n     * Byte order that is used for multi-byte read operations\n     * (such as [readShort], [readInt], [readLong], [readFloat], and [readDouble]).\n     */\n    @Deprecated(\n        \"Setting byte order is no longer supported. Read/write in big endian and use reverseByteOrder() extensions.\",\n        level = DeprecationLevel.ERROR\n    )\n    public var readByteOrder: ByteOrder\n\n    /**\n     * Number of bytes read from the channel.\n     * It is not guaranteed to be atomic so could be updated in the middle of long running read operation.\n     */\n    public val totalBytesRead: Long\n\n    /**\n     * Reads all available bytes to [dst] buffer and returns immediately or suspends if no bytes available\n     * @return number of bytes were read or `-1` if the channel has been closed\n     */\n    public suspend fun readAvailable(dst: ByteArray, offset: Int, length: Int): Int\n    public suspend fun readAvailable(dst: IoBuffer): Int\n\n    /**\n     * Reads all [length] bytes to [dst] buffer or fails if channel has been closed.\n     * Suspends if not enough bytes available.\n     */\n    public suspend fun readFully(dst: ByteArray, offset: Int, length: Int)\n    public suspend fun readFully(dst: IoBuffer, n: Int)\n\n    /**\n     * Reads the specified amount of bytes and makes a byte packet from them. Fails if channel has been closed\n     * and not enough bytes available. Accepts [headerSizeHint] to be provided, see [BytePacketBuilder].\n     */\n    public suspend fun readPacket(size: Int, headerSizeHint: Int): ByteReadPacket\n\n    /**\n     * Reads up to [limit] bytes and makes a byte packet or until end of stream encountered.\n     * Accepts [headerSizeHint] to be provided, see [BytePacketBuilder].\n     */\n    public suspend fun readRemaining(limit: Long, headerSizeHint: Int): ByteReadPacket\n\n    /**\n     * Reads a long number (suspending if not enough bytes available) or fails if channel has been closed\n     * and not enough bytes.\n     */\n    public suspend fun readLong(): Long\n\n    /**\n     * Reads an int number (suspending if not enough bytes available) or fails if channel has been closed\n     * and not enough bytes.\n     */\n    public suspend fun readInt(): Int\n\n    /**\n     * Reads a short number (suspending if not enough bytes available) or fails if channel has been closed\n     * and not enough bytes.\n     */\n    public suspend fun readShort(): Short\n\n    /**\n     * Reads a byte (suspending if no bytes available yet) or fails if channel has been closed\n     * and not enough bytes.\n     */\n    public suspend fun readByte(): Byte\n\n    /**\n     * Reads a boolean value (suspending if no bytes available yet) or fails if channel has been closed\n     * and not enough bytes.\n     */\n    public suspend fun readBoolean(): Boolean\n\n    /**\n     * Reads double number (suspending if not enough bytes available) or fails if channel has been closed\n     * and not enough bytes.\n     */\n    public suspend fun readDouble(): Double\n\n    /**\n     * Reads float number (suspending if not enough bytes available) or fails if channel has been closed\n     * and not enough bytes.\n     */\n    public suspend fun readFloat(): Float\n\n\n    /**\n     * Starts non-suspendable read session. After channel preparation [consumer] lambda will be invoked immediately\n     * event if there are no bytes available for read yet.\n     */\n    @Suppress(\"DEPRECATION\")\n    @Deprecated(\"Use read { } instead.\")\n    public fun readSession(consumer: ReadSession.() -> Unit)\n\n    /**\n     * Starts a suspendable read session. After channel preparation [consumer] lambda will be invoked immediately\n     * even if there are no bytes available for read yet. [consumer] lambda could suspend as much as needed.\n     */\n    @Suppress(\"DEPRECATION\")\n    @Deprecated(\"Use read { } instead.\")\n    public suspend fun readSuspendableSession(consumer: suspend SuspendableReadSession.() -> Unit)\n\n    /**\n     * Reads a line of UTF-8 characters to the specified [out] buffer up to [limit] characters.\n     * Supports both CR-LF and LF line endings. No line ending characters will be appended to [out] buffer.\n     * Throws an exception if the specified [limit] has been exceeded.\n     *\n     * @return `true` if line has been read (possibly empty) or `false` if channel has been closed\n     * and no characters were read.\n     */\n    public suspend fun <A : Appendable> readUTF8LineTo(out: A, limit: Int): Boolean\n\n    /**\n     * Reads a line of UTF-8 characters up to [limit] characters.\n     * Supports both CR-LF and LF line endings.\n     * Throws an exception if the specified [limit] has been exceeded.\n     *\n     * @return a line string with no line endings or `null` of channel has been closed\n     * and no characters were read.\n     */\n    public suspend fun readUTF8Line(limit: Int): String?\n\n    /**\n     * Close channel with optional [cause] cancellation. Unlike [ByteWriteChannel.close] that could close channel\n     * normally, cancel does always close with error so any operations on this channel will always fail\n     * and all suspensions will be resumed with exception.\n     *\n     * Please note that if the channel has been provided by [reader] or [writer] then the corresponding owning\n     * coroutine will be cancelled as well\n     *\n     * @see ByteWriteChannel.close\n     */\n    public fun cancel(cause: Throwable?): Boolean\n\n    /**\n     * Discard up to [max] bytes\n     *\n     * @return number of bytes were discarded\n     */\n    public suspend fun discard(max: Long): Long\n\n    /**\n     * Try to copy at least [min] but up to [max] bytes to the specified [destination] buffer from this input\n     * skipping [offset] bytes. If there are not enough bytes available to provide [min] bytes after skipping [offset]\n     * bytes then it will trigger the underlying source reading first and after that will\n     * simply copy available bytes even if EOF encountered so [min] is not a requirement but a desired number of bytes.\n     * It is safe to specify [max] greater than the destination free space.\n     * `min` shouldn't be bigger than the [destination] free space.\n     * This function could trigger the underlying source suspending reading.\n     * It is allowed to specify too big [offset] so in this case this function will always return `0` after prefetching\n     * all underlying bytes but note that it may lead to significant memory consumption.\n     * This function usually copy more bytes than [min] (unless `max = min`) but it is not guaranteed.\n     * When `0` is returned with `offset = 0` then it makes sense to check [isClosedForRead].\n     *\n     * @param destination to write bytes\n     * @param offset to skip input\n     * @param min bytes to be copied, shouldn't be greater than the buffer free space. Could be `0`.\n     * @param max bytes to be copied even if there are more bytes buffered, could be [Int.MAX_VALUE].\n     * @return number of bytes copied to the [destination] possibly `0`\n     */\n    public suspend fun peekTo(\n        destination: Memory,\n        destinationOffset: Long,\n        offset: Long = 0,\n        min: Long = 1,\n        max: Long = Long.MAX_VALUE\n    ): Long\n\n    public companion object {\n        public val Empty: ByteReadChannel\n    }\n}\n\n/**\n * Reads the specified amount of bytes and makes a byte packet from them. Fails if channel has been closed\n * and not enough bytes available.\n */\npublic suspend fun ByteReadChannel.readPacket(size: Int): ByteReadPacket = readPacket(size, 0)\n\n/**\n * Reads up to [limit] bytes and makes a byte packet or until end of stream encountered.\n */\npublic suspend fun ByteReadChannel.readRemaining(limit: Long): ByteReadPacket = readRemaining(limit, 0)\n\n/**\n * Reads all remaining bytes and makes a byte packet\n */\npublic suspend fun ByteReadChannel.readRemaining(): ByteReadPacket = readRemaining(Long.MAX_VALUE, 0)\n\npublic suspend fun ByteReadChannel.readFully(dst: IoBuffer) {\n    readFully(dst, dst.writeRemaining)\n}\n\npublic suspend fun ByteReadChannel.readUTF8LineTo(out: Appendable): Boolean {\n    return readUTF8LineTo(out, Int.MAX_VALUE)\n}\n\npublic suspend fun ByteReadChannel.readUTF8Line(): String? {\n    return readUTF8Line(Int.MAX_VALUE)\n}\n\npublic fun ByteReadChannel.cancel(): Boolean = cancel(null)\n\n/**\n * Discards all bytes in the channel and suspends until end of stream.\n */\npublic suspend fun ByteReadChannel.discard(): Long = discard(Long.MAX_VALUE)\n\n/**\n * Discards exactly [n] bytes or fails if not enough bytes in the channel\n */\npublic suspend inline fun ByteReadChannel.discardExact(n: Long) {\n    if (discard(n) != n) throw EOFException(\"Unable to discard $n bytes\")\n}\n\npublic suspend fun ByteReadChannel.readAvailable(dst: ByteArray): Int = readAvailable(dst, 0, dst.size)\n\npublic suspend fun ByteReadChannel.readFully(dst: ByteArray): Unit = readFully(dst, 0, dst.size)\n\npublic expect suspend fun ByteReadChannel.joinTo(dst: ByteWriteChannel, closeOnEnd: Boolean)\n\n/**\n * Reads bytes from receiver channel and writes them to [dst] channel.\n * Closes [dst] channel if fails to read or write with cause exception.\n * @return a number of copied bytes\n */\npublic suspend fun ByteReadChannel.copyTo(dst: ByteWriteChannel): Long = copyTo(dst, limit = Long.MAX_VALUE)\n\n/**\n * Reads up to [limit] bytes from receiver channel and writes them to [dst] channel.\n * Closes [dst] channel if fails to read or write with cause exception.\n * @return a number of copied bytes\n */\npublic expect suspend fun ByteReadChannel.copyTo(dst: ByteWriteChannel, limit: Long): Long\n\n/**\n * Reads all the bytes from receiver channel and writes them to [dst] channel and then closes it.\n * Closes [dst] channel if fails to read or write with cause exception.\n * @return a number of copied bytes\n */\npublic suspend fun ByteReadChannel.copyAndClose(dst: ByteWriteChannel, limit: Long = Long.MAX_VALUE): Long {\n    val count = copyTo(dst, limit)\n    dst.close()\n    return count\n}\n","package io.ktor.utils.io\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.core.*\n\n/**\n * Channel for asynchronous writing of sequences of bytes.\n * This is a **single-writer channel**.\n *\n * Operations on this channel cannot be invoked concurrently, unless explicitly specified otherwise\n * in description. Exceptions are [close] and [flush].\n */\npublic expect interface ByteWriteChannel {\n    /**\n     * Returns number of bytes that can be written without suspension. Write operations do no suspend and return\n     * immediately when this number is at least the number of bytes requested for write.\n     */\n    public val availableForWrite: Int\n\n    /**\n     * Returns `true` is channel has been closed and attempting to write to the channel will cause an exception.\n     */\n    public val isClosedForWrite: Boolean\n\n    /**\n     * Returns `true` if channel flushes automatically all pending bytes after every write function call.\n     * If `false` then flush only happens at manual [flush] invocation or when the buffer is full.\n     */\n    public val autoFlush: Boolean\n\n    /**\n     * Byte order that is used for multi-byte write operations\n     * (such as [writeShort], [writeInt], [writeLong], [writeFloat], and [writeDouble]).\n     */\n    @Deprecated(\n        \"Setting byte order is no longer supported. Read/write in big endian and use reverseByteOrder() extensions.\",\n        level = DeprecationLevel.ERROR\n    )\n    public var writeByteOrder: ByteOrder\n\n    /**\n     * Number of bytes written to the channel.\n     * It is not guaranteed to be atomic so could be updated in the middle of write operation.\n     */\n    public val totalBytesWritten: Long\n\n    /**\n     * An closure cause exception or `null` if closed successfully or not yet closed\n     */\n    public val closedCause: Throwable?\n\n    /**\n     * Writes as much as possible and only suspends if buffer is full\n     */\n    public suspend fun writeAvailable(src: ByteArray, offset: Int, length: Int): Int\n\n    public suspend fun writeAvailable(src: IoBuffer): Int\n\n    /**\n     * Writes all [src] bytes and suspends until all bytes written. Causes flush if buffer filled up or when [autoFlush]\n     * Crashes if channel get closed while writing.\n     */\n    public suspend fun writeFully(src: ByteArray, offset: Int, length: Int)\n\n    public suspend fun writeFully(src: IoBuffer)\n\n    public suspend fun writeFully(src: Buffer)\n\n    public suspend fun writeFully(memory: Memory, startIndex: Int, endIndex: Int)\n\n    @Suppress(\"DEPRECATION\")\n    @Deprecated(\"Use write { } instead.\")\n    public suspend fun writeSuspendSession(visitor: suspend WriterSuspendSession.() -> Unit)\n\n    /**\n     * Writes a [packet] fully or fails if channel get closed before the whole packet has been written\n     */\n    public suspend fun writePacket(packet: ByteReadPacket)\n\n    /**\n     * Writes long number and suspends until written.\n     * Crashes if channel get closed while writing.\n     */\n    public suspend fun writeLong(l: Long)\n\n    /**\n     * Writes int number and suspends until written.\n     * Crashes if channel get closed while writing.\n     */\n    public suspend fun writeInt(i: Int)\n\n    /**\n     * Writes short number and suspends until written.\n     * Crashes if channel get closed while writing.\n     */\n    public suspend fun writeShort(s: Short)\n\n    /**\n     * Writes byte and suspends until written.\n     * Crashes if channel get closed while writing.\n     */\n    public suspend fun writeByte(b: Byte)\n\n    /**\n     * Writes double number and suspends until written.\n     * Crashes if channel get closed while writing.\n     */\n    public suspend fun writeDouble(d: Double)\n\n    /**\n     * Writes float number and suspends until written.\n     * Crashes if channel get closed while writing.\n     */\n    public suspend fun writeFloat(f: Float)\n\n    /**\n     * Invokes [block] when at least 1 byte is available for write.\n     */\n    @ExperimentalIoApi\n    public suspend fun awaitFreeSpace()\n\n    /**\n     * Closes this channel with an optional exceptional [cause].\n     * It flushes all pending write bytes (via [flush]).\n     * This is an idempotent operation -- repeated invocations of this function have no effect and return `false`.\n     *\n     * A channel that was closed without a [cause], is considered to be _closed normally_.\n     * A channel that was closed with non-null [cause] is called a _failed channel_. Attempts to read or\n     * write on a failed channel throw this cause exception.\n     *\n     * After invocation of this operation [isClosedForWrite] starts returning `true` and\n     * all subsequent write operations throw [ClosedWriteChannelException] or the specified [cause].\n     * However, [isClosedForRead][ByteReadChannel.isClosedForRead] on the side of [ByteReadChannel]\n     * starts returning `true` only after all written bytes have been read.\n     *\n     * Please note that if the channel has been closed with cause and it has been provided by [reader] or [writer]\n     * coroutine then the corresponding coroutine will be cancelled with [cause]. If no [cause] provided then no\n     * cancellation will be propagated.\n     */\n    public fun close(cause: Throwable?): Boolean\n\n    /**\n     * Flushes all pending write bytes making them available for read.\n     *\n     * This function is thread-safe and can be invoked in any thread at any time.\n     * It does nothing when invoked on a closed channel.\n     */\n    public fun flush()\n}\n\n\npublic suspend fun ByteWriteChannel.writeAvailable(src: ByteArray): Int = writeAvailable(src, 0, src.size)\npublic suspend fun ByteWriteChannel.writeFully(src: ByteArray): Unit = writeFully(src, 0, src.size)\n\npublic suspend fun ByteWriteChannel.writeShort(s: Int) {\n    return writeShort((s and 0xffff).toShort())\n}\n\npublic suspend fun ByteWriteChannel.writeShort(s: Int, byteOrder: ByteOrder) {\n    return writeShort((s and 0xffff).toShort(), byteOrder)\n}\n\npublic suspend fun ByteWriteChannel.writeByte(b: Int) {\n    return writeByte((b and 0xff).toByte())\n}\n\npublic suspend fun ByteWriteChannel.writeInt(i: Long) {\n    return writeInt(i.toInt())\n}\n\npublic suspend fun ByteWriteChannel.writeInt(i: Long, byteOrder: ByteOrder) {\n    return writeInt(i.toInt(), byteOrder)\n}\n\n/**\n * Closes this channel with no failure (successfully)\n */\npublic fun ByteWriteChannel.close(): Boolean = close(null)\n\npublic suspend fun ByteWriteChannel.writeStringUtf8(s: CharSequence) {\n    val packet = buildPacket {\n        writeStringUtf8(s)\n    }\n\n    return writePacket(packet)\n}\n\n/*\nTODO\npublic suspend fun ByteWriteChannel.writeStringUtf8(s: CharBuffer) {\n    val packet = buildPacket {\n        writeStringUtf8(s)\n    }\n\n    return writePacket(packet)\n}*/\n\npublic suspend fun ByteWriteChannel.writeStringUtf8(s: String) {\n    val packet = buildPacket {\n        writeText(s)\n    }\n\n    return writePacket(packet)\n}\n\npublic suspend fun ByteWriteChannel.writeBoolean(b: Boolean) {\n    return writeByte(if (b) 1 else 0)\n}\n\n/**\n * Writes UTF16 character\n */\npublic suspend fun ByteWriteChannel.writeChar(ch: Char) {\n    return writeShort(ch.toInt())\n}\n\npublic suspend inline fun ByteWriteChannel.writePacket(headerSizeHint: Int = 0, builder: BytePacketBuilder.() -> Unit) {\n    return writePacket(buildPacket(headerSizeHint, builder))\n}\n\npublic suspend fun ByteWriteChannel.writePacketSuspend(builder: suspend BytePacketBuilder.() -> Unit) {\n    return writePacket(buildPacket { builder() })\n}\n\n/**\n * Indicates attempt to write on [isClosedForWrite][ByteWriteChannel.isClosedForWrite] channel\n * that was closed without a cause. A _failed_ channel rethrows the original [close][ByteWriteChannel.close] cause\n * exception on send attempts.\n */\npublic class ClosedWriteChannelException(message: String?) : CancellationException(message)\n\n","package io.ktor.utils.io.core\n\nimport io.ktor.utils.io.core.internal.*\nimport io.ktor.utils.io.pool.*\nimport kotlin.contracts.*\n\npublic expect val PACKET_MAX_COPY_SIZE: Int\n\n/**\n * Build a byte packet in [block] lambda. Creates a temporary builder and releases it in case of failure\n */\npublic inline fun buildPacket(headerSizeHint: Int = 0, block: BytePacketBuilder.() -> Unit): ByteReadPacket {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n\n    val builder = BytePacketBuilder(headerSizeHint)\n    try {\n        block(builder)\n        return builder.build()\n    } catch (t: Throwable) {\n        builder.release()\n        throw t\n    }\n}\n\npublic expect fun BytePacketBuilder(headerSizeHint: Int = 0): BytePacketBuilder\n\n/**\n * Discard all written bytes and prepare to build another packet.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun BytePacketBuilder.reset() {\n    release()\n}\n\n@DangerousInternalIoApi\n@Deprecated(\"Will be removed in future releases.\", level = DeprecationLevel.ERROR)\n@Suppress(\"DEPRECATION_ERROR\")\npublic abstract class BytePacketBuilderPlatformBase\ninternal constructor(pool: ObjectPool<ChunkBuffer>) : BytePacketBuilderBase(pool)\n\n@DangerousInternalIoApi\n@Deprecated(\"Will be removed in future releases\", level = DeprecationLevel.ERROR)\n@Suppress(\"DEPRECATION_ERROR\")\npublic abstract class BytePacketBuilderBase\ninternal constructor(pool: ObjectPool<ChunkBuffer>) : AbstractOutput(pool)\n\n","package io.ktor.utils.io\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.core.*\n\npublic suspend inline fun ByteReadChannel.readShort(byteOrder: ByteOrder): Short {\n    return readShort().reverseIfNeeded(byteOrder) { reverseByteOrder() }\n}\n\npublic suspend inline fun ByteReadChannel.readInt(byteOrder: ByteOrder): Int {\n    return readInt().reverseIfNeeded(byteOrder) { reverseByteOrder() }\n}\n\npublic suspend inline fun ByteReadChannel.readLong(byteOrder: ByteOrder): Long {\n    return readLong().reverseIfNeeded(byteOrder) { reverseByteOrder() }\n}\n\npublic suspend inline fun ByteReadChannel.readFloat(byteOrder: ByteOrder): Float {\n    return readFloat().reverseIfNeeded(byteOrder) { reverseByteOrder() }\n}\n\npublic suspend inline fun ByteReadChannel.readDouble(byteOrder: ByteOrder): Double {\n    return readDouble().reverseIfNeeded(byteOrder) { reverseByteOrder() }\n}\n\npublic suspend inline fun ByteReadChannel.readShortLittleEndian(): Short {\n    return toLittleEndian(readShort()) { reverseByteOrder() }\n}\n\npublic suspend inline fun ByteReadChannel.readIntLittleEndian(): Int {\n    return toLittleEndian(readInt()) { reverseByteOrder() }\n}\n\npublic suspend inline fun ByteReadChannel.readLongLittleEndian(): Long {\n    return toLittleEndian(readLong()) { reverseByteOrder() }\n}\n\npublic suspend inline fun ByteReadChannel.readFloatLittleEndian(): Float {\n    return toLittleEndian(readFloat()) { reverseByteOrder() }\n}\n\npublic suspend inline fun ByteReadChannel.readDoubleLittleEndian(): Double {\n    return toLittleEndian(readDouble()) { reverseByteOrder() }\n}\n\npublic suspend fun ByteWriteChannel.writeShort(value: Short, byteOrder: ByteOrder) {\n    writeShort(value.reverseIfNeeded(byteOrder) { reverseByteOrder() })\n}\n\npublic suspend fun ByteWriteChannel.writeInt(value: Int, byteOrder: ByteOrder) {\n    writeInt(value.reverseIfNeeded(byteOrder) { reverseByteOrder() })\n}\n\npublic suspend fun ByteWriteChannel.writeLong(value: Long, byteOrder: ByteOrder) {\n    writeLong(value.reverseIfNeeded(byteOrder) { reverseByteOrder() })\n}\n\npublic suspend fun ByteWriteChannel.writeFloat(value: Float, byteOrder: ByteOrder) {\n    writeFloat(value.reverseIfNeeded(byteOrder) { reverseByteOrder() })\n}\n\npublic suspend fun ByteWriteChannel.writeDouble(value: Double, byteOrder: ByteOrder) {\n    writeDouble(value.reverseIfNeeded(byteOrder) { reverseByteOrder() })\n}\n\npublic suspend fun ByteWriteChannel.writeShortLittleEndian(value: Short) {\n    writeShort(toLittleEndian(value) { reverseByteOrder() })\n}\n\npublic suspend fun ByteWriteChannel.writeIntLittleEndian(value: Int) {\n    writeInt(toLittleEndian(value) { reverseByteOrder() })\n}\n\npublic suspend fun ByteWriteChannel.writeLongLittleEndian(value: Long) {\n    writeLong(toLittleEndian(value) { reverseByteOrder() })\n}\n\npublic suspend fun ByteWriteChannel.writeFloatLittleEndian(value: Float) {\n    writeFloat(toLittleEndian(value) { reverseByteOrder() })\n}\n\npublic suspend fun ByteWriteChannel.writeDoubleLittleEndian(value: Double) {\n    writeDouble(toLittleEndian(value) { reverseByteOrder() })\n}\n\n@PublishedApi\n@Suppress(\"DEPRECATION_ERROR\")\ninternal inline fun <T> ByteReadChannel.toLittleEndian(value: T, reverseBlock: T.() -> T): T {\n    return when (readByteOrder) {\n        ByteOrder.LITTLE_ENDIAN -> value\n        else -> value.reverseBlock()\n    }\n}\n\n@Suppress(\"DEPRECATION_ERROR\")\nprivate inline fun <T> ByteWriteChannel.toLittleEndian(value: T, reverseBlock: T.() -> T): T {\n    return when (writeByteOrder) {\n        ByteOrder.LITTLE_ENDIAN -> value\n        else -> value.reverseBlock()\n    }\n}\n\n@PublishedApi\ninternal inline fun <T> T.reverseIfNeeded(byteOrder: ByteOrder, reverseBlock: T.() -> T): T {\n    return when (byteOrder) {\n        ByteOrder.BIG_ENDIAN -> this\n        else -> reverseBlock()\n    }\n}\n","package io.ktor.utils.io\n\nimport kotlinx.coroutines.*\nimport kotlin.coroutines.*\n\n/**\n * A coroutine job that is reading from a byte channel\n */\npublic interface ReaderJob : Job {\n    /**\n     * A reference to the channel that this coroutine is reading from\n     */\n    public val channel: ByteWriteChannel\n}\n\n/**\n * A coroutine job that is writing to a byte channel\n */\npublic interface WriterJob : Job {\n    /**\n     * A reference to the channel that this coroutine is writing to\n     */\n    public val channel: ByteReadChannel\n}\n\npublic interface ReaderScope : CoroutineScope {\n    public val channel: ByteReadChannel\n}\n\npublic interface WriterScope : CoroutineScope {\n    public val channel: ByteWriteChannel\n}\n\npublic fun CoroutineScope.reader(\n    coroutineContext: CoroutineContext = EmptyCoroutineContext,\n    channel: ByteChannel,\n    block: suspend ReaderScope.() -> Unit\n): ReaderJob = launchChannel(coroutineContext, channel, attachJob = false, block = block)\n\npublic fun CoroutineScope.reader(\n    coroutineContext: CoroutineContext = EmptyCoroutineContext,\n    autoFlush: Boolean = false,\n    block: suspend ReaderScope.() -> Unit\n): ReaderJob = launchChannel(coroutineContext, ByteChannel(autoFlush), attachJob = true, block = block)\n\n@Deprecated(\"Use scope.reader instead\")\npublic fun reader(\n    coroutineContext: CoroutineContext,\n    channel: ByteChannel,\n    parent: Job? = null,\n    block: suspend ReaderScope.() -> Unit\n): ReaderJob {\n    val newContext = if (parent != null) GlobalScope.newCoroutineContext(coroutineContext + parent)\n    else GlobalScope.newCoroutineContext(coroutineContext)\n\n    return CoroutineScope(newContext).reader(EmptyCoroutineContext, channel, block)\n}\n\n@Suppress(\"DEPRECATION\")\n@Deprecated(\"Use scope.reader instead\")\npublic fun reader(\n    coroutineContext: CoroutineContext,\n    autoFlush: Boolean = false, parent: Job? = null,\n    block: suspend ReaderScope.() -> Unit\n): ReaderJob {\n    val channel = ByteChannel(autoFlush)\n    return reader(coroutineContext, channel, parent, block).also {\n        channel.attachJob(it)\n    }\n}\n\npublic fun CoroutineScope.writer(\n    coroutineContext: CoroutineContext = EmptyCoroutineContext,\n    channel: ByteChannel,\n    block: suspend WriterScope.() -> Unit\n): WriterJob = launchChannel(coroutineContext, channel, attachJob = false, block = block)\n\npublic fun CoroutineScope.writer(\n    coroutineContext: CoroutineContext = EmptyCoroutineContext,\n    autoFlush: Boolean = false,\n    block: suspend WriterScope.() -> Unit\n): WriterJob = launchChannel(coroutineContext, ByteChannel(autoFlush), attachJob = true, block = block)\n\n@Deprecated(\"Use scope.writer instead\")\npublic fun writer(\n    coroutineContext: CoroutineContext,\n    channel: ByteChannel, parent: Job? = null,\n    block: suspend WriterScope.() -> Unit\n): WriterJob {\n    val newContext = if (parent != null) GlobalScope.newCoroutineContext(coroutineContext + parent)\n    else GlobalScope.newCoroutineContext(coroutineContext)\n\n    return CoroutineScope(newContext).writer(EmptyCoroutineContext, channel, block)\n}\n\n@Suppress(\"DEPRECATION\")\n@Deprecated(\"Use scope.writer instead\")\npublic fun writer(\n    coroutineContext: CoroutineContext,\n    autoFlush: Boolean = false, parent: Job? = null,\n    block: suspend WriterScope.() -> Unit\n): WriterJob {\n    val channel = ByteChannel(autoFlush)\n    return writer(coroutineContext, channel, parent, block).also {\n        channel.attachJob(it)\n    }\n}\n\n/**\n * @param S not exactly safe (unchecked cast is used) so should be [ReaderScope] or [WriterScope]\n */\n@OptIn(ExperimentalStdlibApi::class)\nprivate fun <S : CoroutineScope> CoroutineScope.launchChannel(\n    context: CoroutineContext,\n    channel: ByteChannel,\n    attachJob: Boolean,\n    block: suspend S.() -> Unit\n): ChannelJob {\n    val dispatcher = coroutineContext[CoroutineDispatcher]\n    val job = launch(context) {\n        if (attachJob) {\n            channel.attachJob(coroutineContext[Job]!!)\n        }\n\n        @Suppress(\"UNCHECKED_CAST\")\n        val scope = ChannelScope(this, channel) as S\n\n        try {\n            block(scope)\n        } catch (cause: Throwable) {\n            if (dispatcher != Dispatchers.Unconfined && dispatcher != null) {\n                throw cause\n            }\n\n            channel.cancel(cause)\n        }\n    }\n\n    job.invokeOnCompletion { cause ->\n        channel.close(cause)\n    }\n\n    return ChannelJob(job, channel)\n}\n\nprivate class ChannelScope(\n    delegate: CoroutineScope,\n    override val channel: ByteChannel\n) : ReaderScope, WriterScope, CoroutineScope by delegate\n\nprivate class ChannelJob(\n    private val delegate: Job,\n    override val channel: ByteChannel\n) : ReaderJob, WriterJob, Job by delegate {\n    override fun toString(): String = \"ChannelJob[$delegate]\"\n}\n","package io.ktor.utils.io\n\nimport io.ktor.utils.io.bits.Memory\nimport io.ktor.utils.io.core.*\nimport io.ktor.utils.io.core.internal.*\n\n/**\n * Await until at least [desiredSize] is available for read or EOF and invoke [block] function. The block function\n * should never capture a provided [Memory] instance outside otherwise an undefined behaviour may occur including\n * accidental crash or data corruption. Block function should return number of bytes consumed or 0.\n *\n * Specifying [desiredSize] larger than the channel's capacity leads to block function invocation earlier\n * when the channel is full. So specifying too big [desiredSize] is identical to specifying [desiredSize] equal to\n * the channel's capacity. The other case when a provided memory range could be less than [desiredSize] is that\n * all the requested bytes couldn't be represented as a single memory range due to internal implementation reasons.\n *\n * @return number of bytes consumed, possibly 0\n */\n@ExperimentalIoApi\npublic suspend inline fun ByteReadChannel.read(\n    desiredSize: Int = 1,\n    block: (source: Memory, start: Long, endExclusive: Long) -> Int\n): Int {\n    val buffer = requestBuffer(desiredSize) ?: Buffer.Empty\n\n    try {\n        val bytesRead = block(buffer.memory, buffer.readPosition.toLong(), buffer.writePosition.toLong())\n        completeReadingFromBuffer(buffer, bytesRead)\n        return bytesRead\n    } catch (cause: Throwable) {\n        completeReadingFromBuffer(buffer, 0)\n        throw cause\n    }\n\n    // we don't use finally here because of KT-37279\n}\n\n@Deprecated(\"Use read { } instead.\")\npublic interface ReadSession {\n    /**\n     * Number of bytes available for read. However it doesn't necessarily means that all available bytes could be\n     * requested at once\n     */\n    public val availableForRead: Int\n\n    /**\n     * Discard at most [n] available bytes or 0 if no bytes available yet\n     * @return number of bytes actually discarded, could be 0\n     */\n    public fun discard(n: Int): Int\n\n    /**\n     * Request buffer range [atLeast] bytes length\n     *\n     * There are the following reasons for this function to return `null`:\n     * - not enough bytes available yet (should be at least `atLeast` bytes available)\n     * - due to buffer fragmentation it is impossible to represent the requested range as a single buffer range\n     * - end of stream encountered and all bytes were consumed\n     *\n     * @return buffer for the requested range or `null` if it is impossible to provide such a buffer view\n     * @throws Throwable if the channel has been closed with an exception or cancelled\n     */\n    @Suppress(\"DEPRECATION\")\n    public fun request(atLeast: Int = 1): IoBuffer?\n}\n\n@Suppress(\"DEPRECATION\")\n@Deprecated(\"Use read { } instead.\")\npublic interface SuspendableReadSession : ReadSession {\n    /**\n     * Suspend until [atLeast] bytes become available or end of stream encountered (possibly due to exceptional close)\n     *\n     * @return true if there are [atLeast] bytes available or false if end of stream encountered (there still could be\n     * bytes available but less than [atLeast])\n     * @throws Throwable if the channel has been closed with an exception or cancelled\n     * @throws IllegalArgumentException if [atLeast] is negative to too big (usually bigger that 4088)\n     */\n    public suspend fun await(atLeast: Int = 1): Boolean\n}\n\n@PublishedApi\ninternal suspend fun ByteReadChannel.requestBuffer(desiredSize: Int): Buffer? {\n    @Suppress(\"DEPRECATION\")\n    val readSession: SuspendableReadSession? = when {\n        this is SuspendableReadSession -> this\n        this is HasReadSession -> startReadSession()\n        else -> null\n    }\n\n    if (readSession != null) {\n        val buffer = readSession.request(desiredSize.coerceAtMost(Buffer.ReservedSize))\n        if (buffer != null) {\n            return buffer\n        }\n\n        return readSession.requestBufferSuspend(desiredSize)\n    }\n\n    return requestBufferFallback(desiredSize)\n}\n\n@PublishedApi\ninternal suspend fun ByteReadChannel.completeReadingFromBuffer(buffer: Buffer?, bytesRead: Int) {\n    check(bytesRead >= 0) { \"bytesRead shouldn't be negative: $bytesRead\" }\n    @Suppress(\"DEPRECATION\")\n    val readSession: SuspendableReadSession? = readSessionFor()\n\n    if (readSession != null) {\n        readSession.discard(bytesRead)\n        if (this is HasReadSession) {\n            endReadSession()\n        }\n        return\n    }\n\n    if (buffer is ChunkBuffer && buffer !== ChunkBuffer.Empty) {\n        buffer.release(ChunkBuffer.Pool)\n        discard(bytesRead.toLong())\n    }\n}\n\n@Suppress(\"DEPRECATION\")\nprivate suspend fun SuspendableReadSession.requestBufferSuspend(desiredSize: Int): Buffer? {\n    await(desiredSize)\n    return request(1)\n}\n\nprivate suspend fun ByteReadChannel.requestBufferFallback(desiredSize: Int): ChunkBuffer {\n    val chunk = ChunkBuffer.Pool.borrow()\n    val copied =\n        peekTo(chunk.memory, chunk.writePosition.toLong(), 0L, desiredSize.toLong(), chunk.writeRemaining.toLong())\n    chunk.commitWritten(copied.toInt())\n\n    return chunk\n}\n\ninternal interface HasReadSession {\n    @Suppress(\"DEPRECATION\")\n    public fun startReadSession(): SuspendableReadSession\n\n    public fun endReadSession()\n}\n\n@Suppress(\"DEPRECATION\", \"NOTHING_TO_INLINE\")\nprivate inline fun ByteReadChannel.readSessionFor(): SuspendableReadSession? = when {\n    this is HasReadSession -> startReadSession()\n    else -> null\n}\n","package io.ktor.utils.io\n\nimport io.ktor.utils.io.bits.Memory\nimport io.ktor.utils.io.core.*\nimport io.ktor.utils.io.core.internal.ChunkBuffer\n\n/**\n * Await for [desiredSpace] will be available for write and invoke [block] function providing [Memory] instance and\n * the corresponding range suitable for wiring in the memory. The block function should return number of bytes were\n * written, possibly 0.\n *\n * Similar to [ByteReadChannel.read], this function may invoke block function with lesser memory range when the\n * specified [desiredSpace] is bigger that the buffer's capacity\n * or when it is impossible to represent all [desiredSpace] bytes as a single memory range\n * due to internal implementation reasons.\n */\n@ExperimentalIoApi\npublic suspend inline fun ByteWriteChannel.write(\n    desiredSpace: Int = 1,\n    block: (freeSpace: Memory, startOffset: Long, endExclusive: Long) -> Int\n): Int {\n    val buffer = requestWriteBuffer(desiredSpace) ?: Buffer.Empty\n    var bytesWritten = 0\n    try {\n        bytesWritten = block(buffer.memory, buffer.writePosition.toLong(), buffer.limit.toLong())\n        buffer.commitWritten(bytesWritten)\n        return bytesWritten\n    } finally {\n        completeWriting(buffer, bytesWritten)\n    }\n}\n\n@Suppress(\"DEPRECATION\")\n@Deprecated(\"Use writeMemory instead.\")\npublic interface WriterSession {\n    public fun request(min: Int): IoBuffer?\n    public fun written(n: Int)\n    public fun flush()\n}\n\n@Suppress(\"DEPRECATION\")\n@Deprecated(\"Use writeMemory instead.\")\npublic interface WriterSuspendSession : WriterSession {\n    public suspend fun tryAwait(n: Int)\n}\n\n@Suppress(\"DEPRECATION\")\ninternal interface HasWriteSession {\n    public fun beginWriteSession(): WriterSuspendSession?\n    public fun endWriteSession(written: Int)\n}\n\n@PublishedApi\ninternal suspend fun ByteWriteChannel.requestWriteBuffer(desiredSpace: Int): Buffer? {\n    val session = writeSessionFor()\n    if (session != null) {\n        val buffer = session.request(desiredSpace)\n        if (buffer != null) {\n            return buffer\n        }\n\n        return writeBufferSuspend(session, desiredSpace)\n    }\n\n    return writeBufferFallback()\n}\n\n@PublishedApi\ninternal suspend fun ByteWriteChannel.completeWriting(buffer: Buffer, written: Int) {\n    if (this is HasWriteSession) {\n        endWriteSession(written)\n        return\n    }\n\n    return completeWritingFallback(buffer)\n}\n\n@Suppress(\"DEPRECATION\")\nprivate suspend fun ByteWriteChannel.completeWritingFallback(buffer: Buffer) {\n    if (buffer is IoBuffer) {\n        writeFully(buffer)\n        buffer.release(IoBuffer.Pool)\n        return\n    }\n\n    throw UnsupportedOperationException(\"Only IoBuffer instance is supported.\")\n}\n\n@Suppress(\"DEPRECATION\")\nprivate suspend fun writeBufferSuspend(session: WriterSuspendSession, desiredSpace: Int): Buffer? {\n    session.tryAwait(desiredSpace)\n    return session.request(desiredSpace) ?: session.request(1)\n}\n\nprivate fun writeBufferFallback(): Buffer? {\n    return ChunkBuffer.Pool.borrow().also { it.resetForWrite(); it.reserveEndGap(Buffer.ReservedSize) }\n}\n\n@Suppress(\"DEPRECATION\", \"NOTHING_TO_INLINE\")\nprivate inline fun ByteWriteChannel.writeSessionFor(): WriterSuspendSession? = when {\n    this is HasWriteSession -> beginWriteSession()\n    else -> null\n}\n\n","@file:Suppress(\"NOTHING_TO_INLINE\")\n\npackage io.ktor.utils.io.bits\n\n/**\n * Read short signed 16bit integer in the network byte order (Big Endian)\n */\npublic expect inline fun Memory.loadShortAt(offset: Int): Short\n\n/**\n * Read short signed 16bit integer in the network byte order (Big Endian)\n */\npublic expect inline fun Memory.loadShortAt(offset: Long): Short\n\n/**\n * Write short signed 16bit integer in the network byte order (Big Endian)\n */\npublic expect inline fun Memory.storeShortAt(offset: Int, value: Short)\n\n/**\n * Write short signed 16bit integer in the network byte order (Big Endian)\n */\npublic expect inline fun Memory.storeShortAt(offset: Long, value: Short)\n\n/**\n * Read short unsigned 16bit integer in the network byte order (Big Endian)\n */\npublic inline fun Memory.loadUShortAt(offset: Int): UShort = loadShortAt(offset).toUShort()\n\n/**\n * Read short unsigned 16bit integer in the network byte order (Big Endian)\n */\npublic inline fun Memory.loadUShortAt(offset: Long): UShort = loadShortAt(offset).toUShort()\n\n/**\n * Write short unsigned 16bit integer in the network byte order (Big Endian)\n */\npublic inline fun Memory.storeUShortAt(offset: Int, value: UShort): Unit = storeShortAt(offset, value.toShort())\n\n/**\n * Write short unsigned 16bit integer in the network byte order (Big Endian)\n */\npublic inline fun Memory.storeUShortAt(offset: Long, value: UShort): Unit = storeShortAt(offset, value.toShort())\n\n/**\n * Read regular signed 32bit integer in the network byte order (Big Endian)\n */\npublic expect inline fun Memory.loadIntAt(offset: Int): Int\n\n/**\n * Read regular signed 32bit integer in the network byte order (Big Endian)\n */\npublic expect inline fun Memory.loadIntAt(offset: Long): Int\n\n/**\n * Write regular signed 32bit integer in the network byte order (Big Endian)\n */\npublic expect inline fun Memory.storeIntAt(offset: Int, value: Int)\n\n/**\n * Write regular signed 32bit integer in the network byte order (Big Endian)\n */\npublic expect inline fun Memory.storeIntAt(offset: Long, value: Int)\n\n/**\n * Read regular unsigned 32bit integer in the network byte order (Big Endian)\n */\npublic inline fun Memory.loadUIntAt(offset: Int): UInt = loadIntAt(offset).toUInt()\n\n/**\n * Read regular unsigned 32bit integer in the network byte order (Big Endian)\n */\npublic inline fun Memory.loadUIntAt(offset: Long): UInt = loadIntAt(offset).toUInt()\n\n/**\n * Write regular unsigned 32bit integer in the network byte order (Big Endian)\n */\npublic inline fun Memory.storeUIntAt(offset: Int, value: UInt): Unit = storeIntAt(offset, value.toInt())\n\n/**\n * Write regular unsigned 32bit integer in the network byte order (Big Endian)\n */\npublic inline fun Memory.storeUIntAt(offset: Long, value: UInt): Unit = storeIntAt(offset, value.toInt())\n\n/**\n * Read short signed 64bit integer in the network byte order (Big Endian)\n */\npublic expect inline fun Memory.loadLongAt(offset: Int): Long\n\n/**\n * Read short signed 64bit integer in the network byte order (Big Endian)\n */\npublic expect inline fun Memory.loadLongAt(offset: Long): Long\n\n/**\n * Write short signed 64bit integer in the network byte order (Big Endian)\n */\npublic expect inline fun Memory.storeLongAt(offset: Int, value: Long)\n\n/**\n * write short signed 64bit integer in the network byte order (Big Endian)\n */\npublic expect inline fun Memory.storeLongAt(offset: Long, value: Long)\n\n/**\n * Read short signed 64bit integer in the network byte order (Big Endian)\n */\npublic inline fun Memory.loadULongAt(offset: Int): ULong = loadLongAt(offset).toULong()\n\n/**\n * Read short signed 64bit integer in the network byte order (Big Endian)\n */\npublic inline fun Memory.loadULongAt(offset: Long): ULong = loadLongAt(offset).toULong()\n\n/**\n * Write short signed 64bit integer in the network byte order (Big Endian)\n */\npublic inline fun Memory.storeULongAt(offset: Int, value: ULong): Unit = storeLongAt(offset, value.toLong())\n\n/**\n * Write short signed 64bit integer in the network byte order (Big Endian)\n */\npublic inline fun Memory.storeULongAt(offset: Long, value: ULong): Unit = storeLongAt(offset, value.toLong())\n\n/**\n * Read short signed 32bit floating point number in the network byte order (Big Endian)\n */\npublic expect inline fun Memory.loadFloatAt(offset: Int): Float\n\n/**\n * Read short signed 32bit floating point number in the network byte order (Big Endian)\n */\npublic expect inline fun Memory.loadFloatAt(offset: Long): Float\n\n/**\n * Write short signed 32bit floating point number in the network byte order (Big Endian)\n */\npublic expect inline fun Memory.storeFloatAt(offset: Int, value: Float)\n\n/**\n * Write short signed 32bit floating point number in the network byte order (Big Endian)\n */\npublic expect inline fun Memory.storeFloatAt(offset: Long, value: Float)\n\n/**\n * Read short signed 64bit floating point number in the network byte order (Big Endian)\n */\npublic expect inline fun Memory.loadDoubleAt(offset: Int): Double\n\n/**\n * Read short signed 64bit floating point number in the network byte order (Big Endian)\n */\npublic expect inline fun Memory.loadDoubleAt(offset: Long): Double\n\n/**\n * Write short signed 64bit floating point number in the network byte order (Big Endian)\n */\npublic expect inline fun Memory.storeDoubleAt(offset: Int, value: Double)\n\n/**\n * Write short signed 64bit floating point number in the network byte order (Big Endian)\n */\npublic expect inline fun Memory.storeDoubleAt(offset: Long, value: Double)\n","package io.ktor.utils.io.core.internal\n\n@PublishedApi\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal inline fun Long.toIntOrFail(name: String): Int {\n    if (this >= Int.MAX_VALUE) failLongToIntConversion(this, name)\n    return toInt()\n}\n\n@PublishedApi\ninternal fun failLongToIntConversion(value: Long, name: String): Nothing =\n    throw IllegalArgumentException(\"Long value $value of $name doesn't fit into 32-bit integer\")\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin\n\nimport kotlin.experimental.*\n\n@Suppress(\"NON_PUBLIC_PRIMARY_CONSTRUCTOR_OF_INLINE_CLASS\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline class ULong @PublishedApi internal constructor(@PublishedApi internal val data: Long) : Comparable<ULong> {\n\n    companion object {\n        /**\n         * A constant holding the minimum value an instance of ULong can have.\n         */\n        public const val MIN_VALUE: ULong = ULong(0)\n\n        /**\n         * A constant holding the maximum value an instance of ULong can have.\n         */\n        public const val MAX_VALUE: ULong = ULong(-1)\n\n        /**\n         * The number of bytes used to represent an instance of ULong in a binary form.\n         */\n        public const val SIZE_BYTES: Int = 8\n\n        /**\n         * The number of bits used to represent an instance of ULong in a binary form.\n         */\n        public const val SIZE_BITS: Int = 64\n    }\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UByte): Int = this.compareTo(other.toULong())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UShort): Int = this.compareTo(other.toULong())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UInt): Int = this.compareTo(other.toULong())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    @Suppress(\"OVERRIDE_BY_INLINE\")\n    public override inline operator fun compareTo(other: ULong): Int = ulongCompare(this.data, other.data)\n\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UByte): ULong = this.plus(other.toULong())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UShort): ULong = this.plus(other.toULong())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UInt): ULong = this.plus(other.toULong())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: ULong): ULong = ULong(this.data.plus(other.data))\n\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UByte): ULong = this.minus(other.toULong())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UShort): ULong = this.minus(other.toULong())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UInt): ULong = this.minus(other.toULong())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: ULong): ULong = ULong(this.data.minus(other.data))\n\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UByte): ULong = this.times(other.toULong())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UShort): ULong = this.times(other.toULong())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UInt): ULong = this.times(other.toULong())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: ULong): ULong = ULong(this.data.times(other.data))\n\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UByte): ULong = this.div(other.toULong())\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UShort): ULong = this.div(other.toULong())\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UInt): ULong = this.div(other.toULong())\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: ULong): ULong = ulongDivide(this, other)\n\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UByte): ULong = this.rem(other.toULong())\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UShort): ULong = this.rem(other.toULong())\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UInt): ULong = this.rem(other.toULong())\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: ULong): ULong = ulongRemainder(this, other)\n\n    /** Increments this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun inc(): ULong = ULong(data.inc())\n    /** Decrements this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun dec(): ULong = ULong(data.dec())\n\n    /** Creates a range from this value to the specified [other] value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rangeTo(other: ULong): ULongRange = ULongRange(this, other)\n\n    /** Shifts this value left by the [bitCount] number of bits. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun shl(bitCount: Int): ULong = ULong(data shl bitCount)\n    /** Shifts this value right by the [bitCount] number of bits, filling the leftmost bits with zeros. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun shr(bitCount: Int): ULong = ULong(data ushr bitCount)\n    /** Performs a bitwise AND operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun and(other: ULong): ULong = ULong(this.data and other.data)\n    /** Performs a bitwise OR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun or(other: ULong): ULong = ULong(this.data or other.data)\n    /** Performs a bitwise XOR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun xor(other: ULong): ULong = ULong(this.data xor other.data)\n    /** Inverts the bits in this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun inv(): ULong = ULong(data.inv())\n\n    /**\n     * Converts this [ULong] value to [Byte].\n     *\n     * If this value is less than or equals to [Byte.MAX_VALUE], the resulting `Byte` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `Byte` value is represented by the least significant 8 bits of this `ULong` value.\n     * Note that the resulting `Byte` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toByte(): Byte = data.toByte()\n    /**\n     * Converts this [ULong] value to [Short].\n     *\n     * If this value is less than or equals to [Short.MAX_VALUE], the resulting `Short` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `Short` value is represented by the least significant 16 bits of this `ULong` value.\n     * Note that the resulting `Short` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toShort(): Short = data.toShort()\n    /**\n     * Converts this [ULong] value to [Int].\n     *\n     * If this value is less than or equals to [Int.MAX_VALUE], the resulting `Int` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `Int` value is represented by the least significant 32 bits of this `ULong` value.\n     * Note that the resulting `Int` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toInt(): Int = data.toInt()\n    /**\n     * Converts this [ULong] value to [Long].\n     *\n     * If this value is less than or equals to [Long.MAX_VALUE], the resulting `Long` value represents\n     * the same numerical value as this `ULong`. Otherwise the result is negative.\n     *\n     * The resulting `Long` value has the same binary representation as this `ULong` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toLong(): Long = data\n\n    /**\n     * Converts this [ULong] value to [UByte].\n     *\n     * If this value is less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `UByte` value is represented by the least significant 8 bits of this `ULong` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUByte(): UByte = data.toUByte()\n    /**\n     * Converts this [ULong] value to [UShort].\n     *\n     * If this value is less than or equals to [UShort.MAX_VALUE], the resulting `UShort` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `UShort` value is represented by the least significant 16 bits of this `ULong` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUShort(): UShort = data.toUShort()\n    /**\n     * Converts this [ULong] value to [UInt].\n     *\n     * If this value is less than or equals to [UInt.MAX_VALUE], the resulting `UInt` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `UInt` value is represented by the least significant 32 bits of this `ULong` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUInt(): UInt = data.toUInt()\n    /** Returns this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun toULong(): ULong = this\n\n    /**\n     * Converts this [ULong] value to [Float].\n     *\n     * The resulting value is the closest `Float` to this `ULong` value.\n     * In case when this `ULong` value is exactly between two `Float`s,\n     * the one with zero at least significant bit of mantissa is selected.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toFloat(): Float = this.toDouble().toFloat()\n    /**\n     * Converts this [ULong] value to [Double].\n     *\n     * The resulting value is the closest `Double` to this `ULong` value.\n     * In case when this `ULong` value is exactly between two `Double`s,\n     * the one with zero at least significant bit of mantissa is selected.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toDouble(): Double = ulongToDouble(data)\n\n    public override fun toString(): String = ulongToString(data)\n\n}\n\n/**\n * Converts this [Byte] value to [ULong].\n *\n * If this value is positive, the resulting `ULong` value represents the same numerical value as this `Byte`.\n *\n * The least significant 8 bits of the resulting `ULong` value are the same as the bits of this `Byte` value,\n * whereas the most significant 56 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Byte.toULong(): ULong = ULong(this.toLong())\n/**\n * Converts this [Short] value to [ULong].\n *\n * If this value is positive, the resulting `ULong` value represents the same numerical value as this `Short`.\n *\n * The least significant 16 bits of the resulting `ULong` value are the same as the bits of this `Short` value,\n * whereas the most significant 48 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Short.toULong(): ULong = ULong(this.toLong())\n/**\n * Converts this [Int] value to [ULong].\n *\n * If this value is positive, the resulting `ULong` value represents the same numerical value as this `Int`.\n *\n * The least significant 32 bits of the resulting `ULong` value are the same as the bits of this `Int` value,\n * whereas the most significant 32 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Int.toULong(): ULong = ULong(this.toLong())\n/**\n * Converts this [Long] value to [ULong].\n *\n * If this value is positive, the resulting `ULong` value represents the same numerical value as this `Long`.\n *\n * The resulting `ULong` value has the same binary representation as this `Long` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Long.toULong(): ULong = ULong(this)\n\n/**\n * Converts this [Float] value to [ULong].\n *\n * The fractional part, if any, is rounded down towards zero.\n * Returns zero if this `Float` value is negative or `NaN`, [ULong.MAX_VALUE] if it's bigger than `ULong.MAX_VALUE`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Float.toULong(): ULong = doubleToULong(this.toDouble())\n/**\n * Converts this [Double] value to [ULong].\n *\n * The fractional part, if any, is rounded down towards zero.\n * Returns zero if this `Double` value is negative or `NaN`, [ULong.MAX_VALUE] if it's bigger than `ULong.MAX_VALUE`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Double.toULong(): ULong = doubleToULong(this)\n","@file:Suppress(\"NOTHING_TO_INLINE\")\n\npackage io.ktor.utils.io.bits\n\n/**\n * Copies bytes from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset].\n */\npublic inline fun Memory.loadByteArray(\n    offset: Int,\n    destination: ByteArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n) {\n    copyTo(destination, offset, count, destinationOffset)\n}\n\n/**\n * Copies unsigned shorts integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic inline fun Memory.loadByteArray(\n    offset: Long,\n    destination: ByteArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n) {\n    copyTo(destination, offset, count, destinationOffset)\n}\n\n/**\n * Copies unsigned shorts integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic inline fun Memory.loadUByteArray(\n    offset: Int,\n    destination: UByteArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n) {\n    copyTo(destination.asByteArray(), offset, count, destinationOffset)\n}\n\n/**\n * Copies unsigned shorts integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic inline fun Memory.loadUByteArray(\n    offset: Long,\n    destination: UByteArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n) {\n    copyTo(destination.asByteArray(), offset, count, destinationOffset)\n}\n\n/**\n * Copies shorts integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic expect fun Memory.loadShortArray(\n    offset: Int,\n    destination: ShortArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n)\n\n/**\n * Copies shorts integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic expect fun Memory.loadShortArray(\n    offset: Long,\n    destination: ShortArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n)\n\n/**\n * Copies unsigned shorts integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic inline fun Memory.loadUShortArray(\n    offset: Int,\n    destination: UShortArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n) {\n    loadShortArray(offset, destination.asShortArray(), destinationOffset, count)\n}\n\n/**\n * Copies unsigned shorts integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic inline fun Memory.loadUShortArray(\n    offset: Long,\n    destination: UShortArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n) {\n    loadShortArray(offset, destination.asShortArray(), destinationOffset, count)\n}\n\n/**\n * Copies regular integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic expect fun Memory.loadIntArray(\n    offset: Int,\n    destination: IntArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n)\n\n/**\n * Copies regular integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic expect fun Memory.loadIntArray(\n    offset: Long,\n    destination: IntArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n)\n\n/**\n * Copies unsigned integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic inline fun Memory.loadUIntArray(\n    offset: Int,\n    destination: UIntArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n) {\n    loadIntArray(offset, destination.asIntArray(), destinationOffset, count)\n}\n\n/**\n * Copies unsigned integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic inline fun Memory.loadUIntArray(\n    offset: Long,\n    destination: UIntArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n) {\n    loadIntArray(offset, destination.asIntArray(), destinationOffset, count)\n}\n\n/**\n * Copies long integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic expect fun Memory.loadLongArray(\n    offset: Int,\n    destination: LongArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n)\n\n/**\n * Copies long integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic expect fun Memory.loadLongArray(\n    offset: Long,\n    destination: LongArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n)\n\n/**\n * Copies unsigned long integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic inline fun Memory.loadULongArray(\n    offset: Int,\n    destination: ULongArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n) {\n    loadLongArray(offset, destination.asLongArray(), destinationOffset, count)\n}\n\n/**\n * Copies unsigned long integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic inline fun Memory.loadULongArray(\n    offset: Long,\n    destination: ULongArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n) {\n    loadLongArray(offset, destination.asLongArray(), destinationOffset, count)\n}\n\n/**\n * Copies floating point numbers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic expect fun Memory.loadFloatArray(\n    offset: Int,\n    destination: FloatArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n)\n\n/**\n * Copies floating point numbers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic expect fun Memory.loadFloatArray(\n    offset: Long,\n    destination: FloatArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n)\n\n/**\n * Copies floating point numbers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic expect fun Memory.loadDoubleArray(\n    offset: Int,\n    destination: DoubleArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n)\n\n/**\n * Copies floating point numbers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic expect fun Memory.loadDoubleArray(\n    offset: Long,\n    destination: DoubleArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n)\n\n/**\n * Copies unsigned shorts integers from the [source] array at [sourceOffset] to this memory at the specified [offset].\n * @param sourceOffset items\n */\npublic inline fun Memory.storeByteArray(\n    offset: Int,\n    source: ByteArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n) {\n    source.useMemory(sourceOffset, count) { sourceMemory ->\n        sourceMemory.copyTo(this, 0, count, offset)\n    }\n}\n\n/**\n * Copies unsigned shorts integers from the [source] array at [sourceOffset] to this memory at the specified [offset].\n * @param sourceOffset items\n */\npublic inline fun Memory.storeByteArray(\n    offset: Long,\n    source: ByteArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n) {\n    source.useMemory(sourceOffset, count) { sourceMemory ->\n        sourceMemory.copyTo(this, 0L, count.toLong(), offset)\n    }\n}\n\n/**\n * Copies unsigned shorts integers from the [source] array at [sourceOffset] to this memory at the specified [offset].\n * @param sourceOffset items\n */\npublic inline fun Memory.storeUByteArray(\n    offset: Int,\n    source: UByteArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n) {\n    storeByteArray(offset, source.asByteArray(), sourceOffset, count)\n}\n\n/**\n * Copies unsigned shorts integers from the [source] array at [sourceOffset] to this memory at the specified [offset].\n * @param sourceOffset items\n */\npublic inline fun Memory.storeUByteArray(\n    offset: Long,\n    source: UByteArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n) {\n    storeByteArray(offset, source.asByteArray(), sourceOffset, count)\n}\n\n/**\n * Copies shorts integers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic expect fun Memory.storeShortArray(\n    offset: Int,\n    source: ShortArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n)\n\n/**\n * Copies shorts integers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic expect fun Memory.storeShortArray(\n    offset: Long,\n    source: ShortArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n)\n\n/**\n * Copies unsigned shorts integers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic inline fun Memory.storeUShortArray(\n    offset: Int,\n    source: UShortArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n) {\n    storeShortArray(offset, source.asShortArray(), sourceOffset, count)\n}\n\n/**\n * Copies unsigned shorts integers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic inline fun Memory.storeUShortArray(\n    offset: Long,\n    source: UShortArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n) {\n    storeShortArray(offset, source.asShortArray(), sourceOffset, count)\n}\n\n/**\n * Copies regular integers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic expect fun Memory.storeIntArray(\n    offset: Int,\n    source: IntArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n)\n\n/**\n * Copies regular integers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic expect fun Memory.storeIntArray(\n    offset: Long,\n    source: IntArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n)\n\n/**\n * Copies unsigned integers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic inline fun Memory.storeUIntArray(\n    offset: Int,\n    source: UIntArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n) {\n    storeIntArray(offset, source.asIntArray(), sourceOffset, count)\n}\n\n/**\n * Copies unsigned integers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic inline fun Memory.storeUIntArray(\n    offset: Long,\n    source: UIntArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n) {\n    storeIntArray(offset, source.asIntArray(), sourceOffset, count)\n}\n\n/**\n * Copies long integers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic expect fun Memory.storeLongArray(\n    offset: Int,\n    source: LongArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n)\n\n/**\n * Copies long integers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic expect fun Memory.storeLongArray(\n    offset: Long,\n    source: LongArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n)\n\n/**\n * Copies unsigned long integers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic inline fun Memory.storeULongArray(\n    offset: Int,\n    source: ULongArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n) {\n    storeLongArray(offset, source.asLongArray(), sourceOffset, count)\n}\n\n/**\n * Copies unsigned long integers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic inline fun Memory.storeULongArray(\n    offset: Long,\n    source: ULongArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n) {\n    storeLongArray(offset, source.asLongArray(), sourceOffset, count)\n}\n\n/**\n * Copies floating point numbers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic expect fun Memory.storeFloatArray(\n    offset: Int,\n    source: FloatArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n)\n\n/**\n * Copies floating point numbers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic expect fun Memory.storeFloatArray(\n    offset: Long,\n    source: FloatArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n)\n\n/**\n * Copies floating point numbers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic expect fun Memory.storeDoubleArray(\n    offset: Int,\n    source: DoubleArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n)\n\n/**\n * Copies floating point numbers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic expect fun Memory.storeDoubleArray(\n    offset: Long,\n    source: DoubleArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n)\n\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"UArraysKt\")\n@file:kotlin.jvm.JvmPackageName(\"kotlin.collections.unsigned\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UIntArray.component1(): UInt {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun ULongArray.component1(): ULong {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UByteArray.component1(): UByte {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UShortArray.component1(): UShort {\n    return get(0)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UIntArray.component2(): UInt {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun ULongArray.component2(): ULong {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UByteArray.component2(): UByte {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UShortArray.component2(): UShort {\n    return get(1)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UIntArray.component3(): UInt {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun ULongArray.component3(): ULong {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UByteArray.component3(): UByte {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UShortArray.component3(): UShort {\n    return get(2)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UIntArray.component4(): UInt {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun ULongArray.component4(): ULong {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UByteArray.component4(): UByte {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UShortArray.component4(): UShort {\n    return get(3)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UIntArray.component5(): UInt {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun ULongArray.component5(): ULong {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UByteArray.component5(): UByte {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UShortArray.component5(): UShort {\n    return get(4)\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic expect fun UIntArray.elementAt(index: Int): UInt\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic expect fun ULongArray.elementAt(index: Int): ULong\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic expect fun UByteArray.elementAt(index: Int): UByte\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic expect fun UShortArray.elementAt(index: Int): UShort\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.elementAtOrElse(index: Int, defaultValue: (Int) -> UInt): UInt {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.elementAtOrElse(index: Int, defaultValue: (Int) -> ULong): ULong {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.elementAtOrElse(index: Int, defaultValue: (Int) -> UByte): UByte {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.elementAtOrElse(index: Int, defaultValue: (Int) -> UShort): UShort {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.elementAtOrNull(index: Int): UInt? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.elementAtOrNull(index: Int): ULong? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.elementAtOrNull(index: Int): UByte? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.elementAtOrNull(index: Int): UShort? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.find(predicate: (UInt) -> Boolean): UInt? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.find(predicate: (ULong) -> Boolean): ULong? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.find(predicate: (UByte) -> Boolean): UByte? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.find(predicate: (UShort) -> Boolean): UShort? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.findLast(predicate: (UInt) -> Boolean): UInt? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.findLast(predicate: (ULong) -> Boolean): ULong? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.findLast(predicate: (UByte) -> Boolean): UByte? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.findLast(predicate: (UShort) -> Boolean): UShort? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.first(): UInt {\n    return storage.first().toUInt()\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.first(): ULong {\n    return storage.first().toULong()\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.first(): UByte {\n    return storage.first().toUByte()\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.first(): UShort {\n    return storage.first().toUShort()\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.first(predicate: (UInt) -> Boolean): UInt {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.first(predicate: (ULong) -> Boolean): ULong {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.first(predicate: (UByte) -> Boolean): UByte {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.first(predicate: (UShort) -> Boolean): UShort {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.firstOrNull(): UInt? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.firstOrNull(): ULong? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.firstOrNull(): UByte? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.firstOrNull(): UShort? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.firstOrNull(predicate: (UInt) -> Boolean): UInt? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.firstOrNull(predicate: (ULong) -> Boolean): ULong? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.firstOrNull(predicate: (UByte) -> Boolean): UByte? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.firstOrNull(predicate: (UShort) -> Boolean): UShort? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.getOrElse(index: Int, defaultValue: (Int) -> UInt): UInt {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.getOrElse(index: Int, defaultValue: (Int) -> ULong): ULong {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.getOrElse(index: Int, defaultValue: (Int) -> UByte): UByte {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.getOrElse(index: Int, defaultValue: (Int) -> UShort): UShort {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.getOrNull(index: Int): UInt? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.getOrNull(index: Int): ULong? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.getOrNull(index: Int): UByte? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.getOrNull(index: Int): UShort? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.indexOf(element: UInt): Int {\n    return storage.indexOf(element.toInt())\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.indexOf(element: ULong): Int {\n    return storage.indexOf(element.toLong())\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.indexOf(element: UByte): Int {\n    return storage.indexOf(element.toByte())\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.indexOf(element: UShort): Int {\n    return storage.indexOf(element.toShort())\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.indexOfFirst(predicate: (UInt) -> Boolean): Int {\n    return storage.indexOfFirst { predicate(it.toUInt()) }\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.indexOfFirst(predicate: (ULong) -> Boolean): Int {\n    return storage.indexOfFirst { predicate(it.toULong()) }\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.indexOfFirst(predicate: (UByte) -> Boolean): Int {\n    return storage.indexOfFirst { predicate(it.toUByte()) }\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.indexOfFirst(predicate: (UShort) -> Boolean): Int {\n    return storage.indexOfFirst { predicate(it.toUShort()) }\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.indexOfLast(predicate: (UInt) -> Boolean): Int {\n    return storage.indexOfLast { predicate(it.toUInt()) }\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.indexOfLast(predicate: (ULong) -> Boolean): Int {\n    return storage.indexOfLast { predicate(it.toULong()) }\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.indexOfLast(predicate: (UByte) -> Boolean): Int {\n    return storage.indexOfLast { predicate(it.toUByte()) }\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.indexOfLast(predicate: (UShort) -> Boolean): Int {\n    return storage.indexOfLast { predicate(it.toUShort()) }\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.last(): UInt {\n    return storage.last().toUInt()\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.last(): ULong {\n    return storage.last().toULong()\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.last(): UByte {\n    return storage.last().toUByte()\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.last(): UShort {\n    return storage.last().toUShort()\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.last(predicate: (UInt) -> Boolean): UInt {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.last(predicate: (ULong) -> Boolean): ULong {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.last(predicate: (UByte) -> Boolean): UByte {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.last(predicate: (UShort) -> Boolean): UShort {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.lastIndexOf(element: UInt): Int {\n    return storage.lastIndexOf(element.toInt())\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.lastIndexOf(element: ULong): Int {\n    return storage.lastIndexOf(element.toLong())\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.lastIndexOf(element: UByte): Int {\n    return storage.lastIndexOf(element.toByte())\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.lastIndexOf(element: UShort): Int {\n    return storage.lastIndexOf(element.toShort())\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.lastOrNull(): UInt? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.lastOrNull(): ULong? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.lastOrNull(): UByte? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.lastOrNull(): UShort? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.lastOrNull(predicate: (UInt) -> Boolean): UInt? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.lastOrNull(predicate: (ULong) -> Boolean): ULong? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.lastOrNull(predicate: (UByte) -> Boolean): UByte? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.lastOrNull(predicate: (UShort) -> Boolean): UShort? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.random(): UInt {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.random(): ULong {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.random(): UByte {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.random(): UShort {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.random(random: Random): UInt {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.random(random: Random): ULong {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.random(random: Random): UByte {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.random(random: Random): UShort {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.randomOrNull(): UInt? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.randomOrNull(): ULong? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.randomOrNull(): UByte? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.randomOrNull(): UShort? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@ExperimentalUnsignedTypes\npublic fun UIntArray.randomOrNull(random: Random): UInt? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@ExperimentalUnsignedTypes\npublic fun ULongArray.randomOrNull(random: Random): ULong? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@ExperimentalUnsignedTypes\npublic fun UByteArray.randomOrNull(random: Random): UByte? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@ExperimentalUnsignedTypes\npublic fun UShortArray.randomOrNull(random: Random): UShort? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.single(): UInt {\n    return storage.single().toUInt()\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.single(): ULong {\n    return storage.single().toULong()\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.single(): UByte {\n    return storage.single().toUByte()\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.single(): UShort {\n    return storage.single().toUShort()\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.single(predicate: (UInt) -> Boolean): UInt {\n    var single: UInt? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as UInt\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.single(predicate: (ULong) -> Boolean): ULong {\n    var single: ULong? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as ULong\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.single(predicate: (UByte) -> Boolean): UByte {\n    var single: UByte? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as UByte\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.single(predicate: (UShort) -> Boolean): UShort {\n    var single: UShort? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as UShort\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.singleOrNull(): UInt? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.singleOrNull(): ULong? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.singleOrNull(): UByte? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.singleOrNull(): UShort? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.singleOrNull(predicate: (UInt) -> Boolean): UInt? {\n    var single: UInt? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.singleOrNull(predicate: (ULong) -> Boolean): ULong? {\n    var single: ULong? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.singleOrNull(predicate: (UByte) -> Boolean): UByte? {\n    var single: UByte? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.singleOrNull(predicate: (UShort) -> Boolean): UShort? {\n    var single: UShort? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.drop(n: Int): List<UInt> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.drop(n: Int): List<ULong> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.drop(n: Int): List<UByte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.drop(n: Int): List<UShort> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.dropLast(n: Int): List<UInt> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.dropLast(n: Int): List<ULong> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.dropLast(n: Int): List<UByte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.dropLast(n: Int): List<UShort> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.dropLastWhile(predicate: (UInt) -> Boolean): List<UInt> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.dropLastWhile(predicate: (ULong) -> Boolean): List<ULong> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.dropLastWhile(predicate: (UByte) -> Boolean): List<UByte> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.dropLastWhile(predicate: (UShort) -> Boolean): List<UShort> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.dropWhile(predicate: (UInt) -> Boolean): List<UInt> {\n    var yielding = false\n    val list = ArrayList<UInt>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.dropWhile(predicate: (ULong) -> Boolean): List<ULong> {\n    var yielding = false\n    val list = ArrayList<ULong>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.dropWhile(predicate: (UByte) -> Boolean): List<UByte> {\n    var yielding = false\n    val list = ArrayList<UByte>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.dropWhile(predicate: (UShort) -> Boolean): List<UShort> {\n    var yielding = false\n    val list = ArrayList<UShort>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.filter(predicate: (UInt) -> Boolean): List<UInt> {\n    return filterTo(ArrayList<UInt>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.filter(predicate: (ULong) -> Boolean): List<ULong> {\n    return filterTo(ArrayList<ULong>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.filter(predicate: (UByte) -> Boolean): List<UByte> {\n    return filterTo(ArrayList<UByte>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.filter(predicate: (UShort) -> Boolean): List<UShort> {\n    return filterTo(ArrayList<UShort>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.filterIndexed(predicate: (index: Int, UInt) -> Boolean): List<UInt> {\n    return filterIndexedTo(ArrayList<UInt>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.filterIndexed(predicate: (index: Int, ULong) -> Boolean): List<ULong> {\n    return filterIndexedTo(ArrayList<ULong>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.filterIndexed(predicate: (index: Int, UByte) -> Boolean): List<UByte> {\n    return filterIndexedTo(ArrayList<UByte>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.filterIndexed(predicate: (index: Int, UShort) -> Boolean): List<UShort> {\n    return filterIndexedTo(ArrayList<UShort>(), predicate)\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in UInt>> UIntArray.filterIndexedTo(destination: C, predicate: (index: Int, UInt) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in ULong>> ULongArray.filterIndexedTo(destination: C, predicate: (index: Int, ULong) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in UByte>> UByteArray.filterIndexedTo(destination: C, predicate: (index: Int, UByte) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in UShort>> UShortArray.filterIndexedTo(destination: C, predicate: (index: Int, UShort) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.filterNot(predicate: (UInt) -> Boolean): List<UInt> {\n    return filterNotTo(ArrayList<UInt>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.filterNot(predicate: (ULong) -> Boolean): List<ULong> {\n    return filterNotTo(ArrayList<ULong>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.filterNot(predicate: (UByte) -> Boolean): List<UByte> {\n    return filterNotTo(ArrayList<UByte>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.filterNot(predicate: (UShort) -> Boolean): List<UShort> {\n    return filterNotTo(ArrayList<UShort>(), predicate)\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in UInt>> UIntArray.filterNotTo(destination: C, predicate: (UInt) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in ULong>> ULongArray.filterNotTo(destination: C, predicate: (ULong) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in UByte>> UByteArray.filterNotTo(destination: C, predicate: (UByte) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in UShort>> UShortArray.filterNotTo(destination: C, predicate: (UShort) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in UInt>> UIntArray.filterTo(destination: C, predicate: (UInt) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in ULong>> ULongArray.filterTo(destination: C, predicate: (ULong) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in UByte>> UByteArray.filterTo(destination: C, predicate: (UByte) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in UShort>> UShortArray.filterTo(destination: C, predicate: (UShort) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.slice(indices: IntRange): List<UInt> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.slice(indices: IntRange): List<ULong> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.slice(indices: IntRange): List<UByte> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.slice(indices: IntRange): List<UShort> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.slice(indices: Iterable<Int>): List<UInt> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<UInt>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.slice(indices: Iterable<Int>): List<ULong> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<ULong>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.slice(indices: Iterable<Int>): List<UByte> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<UByte>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.slice(indices: Iterable<Int>): List<UShort> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<UShort>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.sliceArray(indices: Collection<Int>): UIntArray {\n    return UIntArray(storage.sliceArray(indices))\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.sliceArray(indices: Collection<Int>): ULongArray {\n    return ULongArray(storage.sliceArray(indices))\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.sliceArray(indices: Collection<Int>): UByteArray {\n    return UByteArray(storage.sliceArray(indices))\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.sliceArray(indices: Collection<Int>): UShortArray {\n    return UShortArray(storage.sliceArray(indices))\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.sliceArray(indices: IntRange): UIntArray {\n    return UIntArray(storage.sliceArray(indices))\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.sliceArray(indices: IntRange): ULongArray {\n    return ULongArray(storage.sliceArray(indices))\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.sliceArray(indices: IntRange): UByteArray {\n    return UByteArray(storage.sliceArray(indices))\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.sliceArray(indices: IntRange): UShortArray {\n    return UShortArray(storage.sliceArray(indices))\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.take(n: Int): List<UInt> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<UInt>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.take(n: Int): List<ULong> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<ULong>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.take(n: Int): List<UByte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<UByte>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.take(n: Int): List<UShort> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<UShort>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.takeLast(n: Int): List<UInt> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<UInt>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.takeLast(n: Int): List<ULong> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<ULong>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.takeLast(n: Int): List<UByte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<UByte>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.takeLast(n: Int): List<UShort> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<UShort>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.takeLastWhile(predicate: (UInt) -> Boolean): List<UInt> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.takeLastWhile(predicate: (ULong) -> Boolean): List<ULong> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.takeLastWhile(predicate: (UByte) -> Boolean): List<UByte> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.takeLastWhile(predicate: (UShort) -> Boolean): List<UShort> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.takeWhile(predicate: (UInt) -> Boolean): List<UInt> {\n    val list = ArrayList<UInt>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.takeWhile(predicate: (ULong) -> Boolean): List<ULong> {\n    val list = ArrayList<ULong>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.takeWhile(predicate: (UByte) -> Boolean): List<UByte> {\n    val list = ArrayList<UByte>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.takeWhile(predicate: (UShort) -> Boolean): List<UShort> {\n    val list = ArrayList<UShort>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Reverses elements in the array in-place.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.reverse(): Unit {\n    storage.reverse()\n}\n\n/**\n * Reverses elements in the array in-place.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.reverse(): Unit {\n    storage.reverse()\n}\n\n/**\n * Reverses elements in the array in-place.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.reverse(): Unit {\n    storage.reverse()\n}\n\n/**\n * Reverses elements in the array in-place.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.reverse(): Unit {\n    storage.reverse()\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    storage.reverse(fromIndex, toIndex)\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    storage.reverse(fromIndex, toIndex)\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    storage.reverse(fromIndex, toIndex)\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    storage.reverse(fromIndex, toIndex)\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.reversed(): List<UInt> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.reversed(): List<ULong> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.reversed(): List<UByte> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.reversed(): List<UShort> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.reversedArray(): UIntArray {\n    return UIntArray(storage.reversedArray())\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.reversedArray(): ULongArray {\n    return ULongArray(storage.reversedArray())\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.reversedArray(): UByteArray {\n    return UByteArray(storage.reversedArray())\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.reversedArray(): UShortArray {\n    return UShortArray(storage.reversedArray())\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.sorted(): List<UInt> {\n    return copyOf().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.sorted(): List<ULong> {\n    return copyOf().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.sorted(): List<UByte> {\n    return copyOf().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.sorted(): List<UShort> {\n    return copyOf().apply { sort() }.asList()\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.sortedArray(): UIntArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.sortedArray(): ULongArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.sortedArray(): UByteArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.sortedArray(): UShortArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.sortedArrayDescending(): UIntArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.sortedArrayDescending(): ULongArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.sortedArrayDescending(): UByteArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.sortedArrayDescending(): UShortArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.sortedDescending(): List<UInt> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.sortedDescending(): List<ULong> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.sortedDescending(): List<UByte> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.sortedDescending(): List<UShort> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns an array of type [ByteArray], which is a view of this array where each element is a signed reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.asByteArray(): ByteArray {\n    return storage\n}\n\n/**\n * Returns an array of type [IntArray], which is a view of this array where each element is a signed reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.asIntArray(): IntArray {\n    return storage\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic expect fun UIntArray.asList(): List<UInt>\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic expect fun ULongArray.asList(): List<ULong>\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic expect fun UByteArray.asList(): List<UByte>\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic expect fun UShortArray.asList(): List<UShort>\n\n/**\n * Returns an array of type [LongArray], which is a view of this array where each element is a signed reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.asLongArray(): LongArray {\n    return storage\n}\n\n/**\n * Returns an array of type [ShortArray], which is a view of this array where each element is a signed reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.asShortArray(): ShortArray {\n    return storage\n}\n\n/**\n * Returns an array of type [UByteArray], which is a view of this array where each element is an unsigned reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.asUByteArray(): UByteArray {\n    return UByteArray(this)\n}\n\n/**\n * Returns an array of type [UIntArray], which is a view of this array where each element is an unsigned reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.asUIntArray(): UIntArray {\n    return UIntArray(this)\n}\n\n/**\n * Returns an array of type [ULongArray], which is a view of this array where each element is an unsigned reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.asULongArray(): ULongArray {\n    return ULongArray(this)\n}\n\n/**\n * Returns an array of type [UShortArray], which is a view of this array where each element is an unsigned reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.asUShortArray(): UShortArray {\n    return UShortArray(this)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.3\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\n@ExperimentalUnsignedTypes\npublic infix fun UIntArray.contentEquals(other: UIntArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.3\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\n@ExperimentalUnsignedTypes\npublic infix fun ULongArray.contentEquals(other: ULongArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.3\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\n@ExperimentalUnsignedTypes\npublic infix fun UByteArray.contentEquals(other: UByteArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.3\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\n@ExperimentalUnsignedTypes\npublic infix fun UShortArray.contentEquals(other: UShortArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic infix fun UIntArray?.contentEquals(other: UIntArray?): Boolean {\n    return this?.storage.contentEquals(other?.storage)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic infix fun ULongArray?.contentEquals(other: ULongArray?): Boolean {\n    return this?.storage.contentEquals(other?.storage)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic infix fun UByteArray?.contentEquals(other: UByteArray?): Boolean {\n    return this?.storage.contentEquals(other?.storage)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic infix fun UShortArray?.contentEquals(other: UShortArray?): Boolean {\n    return this?.storage.contentEquals(other?.storage)\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.3\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.3\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.3\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.3\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray?.contentHashCode(): Int {\n    return this?.storage.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray?.contentHashCode(): Int {\n    return this?.storage.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray?.contentHashCode(): Int {\n    return this?.storage.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray?.contentHashCode(): Int {\n    return this?.storage.contentHashCode()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.3\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.3\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.3\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.3\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray?.contentToString(): String {\n    return this?.joinToString(\", \", \"[\", \"]\") ?: \"null\"\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray?.contentToString(): String {\n    return this?.joinToString(\", \", \"[\", \"]\") ?: \"null\"\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray?.contentToString(): String {\n    return this?.joinToString(\", \", \"[\", \"]\") ?: \"null\"\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray?.contentToString(): String {\n    return this?.joinToString(\", \", \"[\", \"]\") ?: \"null\"\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.copyInto(destination: UIntArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): UIntArray {\n    storage.copyInto(destination.storage, destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.copyInto(destination: ULongArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): ULongArray {\n    storage.copyInto(destination.storage, destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.copyInto(destination: UByteArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): UByteArray {\n    storage.copyInto(destination.storage, destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.copyInto(destination: UShortArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): UShortArray {\n    storage.copyInto(destination.storage, destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.copyOf(): UIntArray {\n    return UIntArray(storage.copyOf())\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.copyOf(): ULongArray {\n    return ULongArray(storage.copyOf())\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.copyOf(): UByteArray {\n    return UByteArray(storage.copyOf())\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.copyOf(): UShortArray {\n    return UShortArray(storage.copyOf())\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.copyOf(newSize: Int): UIntArray {\n    return UIntArray(storage.copyOf(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.copyOf(newSize: Int): ULongArray {\n    return ULongArray(storage.copyOf(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.copyOf(newSize: Int): UByteArray {\n    return UByteArray(storage.copyOf(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.copyOf(newSize: Int): UShortArray {\n    return UShortArray(storage.copyOf(newSize))\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.copyOfRange(fromIndex: Int, toIndex: Int): UIntArray {\n    return UIntArray(storage.copyOfRange(fromIndex, toIndex))\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.copyOfRange(fromIndex: Int, toIndex: Int): ULongArray {\n    return ULongArray(storage.copyOfRange(fromIndex, toIndex))\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.copyOfRange(fromIndex: Int, toIndex: Int): UByteArray {\n    return UByteArray(storage.copyOfRange(fromIndex, toIndex))\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.copyOfRange(fromIndex: Int, toIndex: Int): UShortArray {\n    return UShortArray(storage.copyOfRange(fromIndex, toIndex))\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.fill(element: UInt, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    storage.fill(element.toInt(), fromIndex, toIndex)\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.fill(element: ULong, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    storage.fill(element.toLong(), fromIndex, toIndex)\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.fill(element: UByte, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    storage.fill(element.toByte(), fromIndex, toIndex)\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.fill(element: UShort, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    storage.fill(element.toShort(), fromIndex, toIndex)\n}\n\n/**\n * Returns the range of valid indices for the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline val UIntArray.indices: IntRange\n    get() = storage.indices\n\n/**\n * Returns the range of valid indices for the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline val ULongArray.indices: IntRange\n    get() = storage.indices\n\n/**\n * Returns the range of valid indices for the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline val UByteArray.indices: IntRange\n    get() = storage.indices\n\n/**\n * Returns the range of valid indices for the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline val UShortArray.indices: IntRange\n    get() = storage.indices\n\n/**\n * Returns the last valid index for the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline val UIntArray.lastIndex: Int\n    get() = storage.lastIndex\n\n/**\n * Returns the last valid index for the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline val ULongArray.lastIndex: Int\n    get() = storage.lastIndex\n\n/**\n * Returns the last valid index for the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline val UByteArray.lastIndex: Int\n    get() = storage.lastIndex\n\n/**\n * Returns the last valid index for the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline val UShortArray.lastIndex: Int\n    get() = storage.lastIndex\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UIntArray.plus(element: UInt): UIntArray {\n    return UIntArray(storage + element.toInt())\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun ULongArray.plus(element: ULong): ULongArray {\n    return ULongArray(storage + element.toLong())\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UByteArray.plus(element: UByte): UByteArray {\n    return UByteArray(storage + element.toByte())\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UShortArray.plus(element: UShort): UShortArray {\n    return UShortArray(storage + element.toShort())\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic operator fun UIntArray.plus(elements: Collection<UInt>): UIntArray {\n    var index = size\n    val result = storage.copyOf(size + elements.size)\n    for (element in elements) result[index++] = element.toInt()\n    return UIntArray(result)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic operator fun ULongArray.plus(elements: Collection<ULong>): ULongArray {\n    var index = size\n    val result = storage.copyOf(size + elements.size)\n    for (element in elements) result[index++] = element.toLong()\n    return ULongArray(result)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic operator fun UByteArray.plus(elements: Collection<UByte>): UByteArray {\n    var index = size\n    val result = storage.copyOf(size + elements.size)\n    for (element in elements) result[index++] = element.toByte()\n    return UByteArray(result)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic operator fun UShortArray.plus(elements: Collection<UShort>): UShortArray {\n    var index = size\n    val result = storage.copyOf(size + elements.size)\n    for (element in elements) result[index++] = element.toShort()\n    return UShortArray(result)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UIntArray.plus(elements: UIntArray): UIntArray {\n    return UIntArray(storage + elements.storage)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun ULongArray.plus(elements: ULongArray): ULongArray {\n    return ULongArray(storage + elements.storage)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UByteArray.plus(elements: UByteArray): UByteArray {\n    return UByteArray(storage + elements.storage)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UShortArray.plus(elements: UShortArray): UShortArray {\n    return UShortArray(storage + elements.storage)\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.sort(): Unit {\n    if (size > 1) sortArray(this, 0, size)\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.sort(): Unit {\n    if (size > 1) sortArray(this, 0, size)\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.sort(): Unit {\n    if (size > 1) sortArray(this, 0, size)\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.sort(): Unit {\n    if (size > 1) sortArray(this, 0, size)\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    sortArray(this, fromIndex, toIndex)\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    sortArray(this, fromIndex, toIndex)\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    sortArray(this, fromIndex, toIndex)\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    sortArray(this, fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Returns an array of type [ByteArray], which is a copy of this array where each element is a signed reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.toByteArray(): ByteArray {\n    return storage.copyOf()\n}\n\n/**\n * Returns an array of type [IntArray], which is a copy of this array where each element is a signed reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.toIntArray(): IntArray {\n    return storage.copyOf()\n}\n\n/**\n * Returns an array of type [LongArray], which is a copy of this array where each element is a signed reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.toLongArray(): LongArray {\n    return storage.copyOf()\n}\n\n/**\n * Returns an array of type [ShortArray], which is a copy of this array where each element is a signed reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.toShortArray(): ShortArray {\n    return storage.copyOf()\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.toTypedArray(): Array<UInt> {\n    return Array(size) { index -> this[index] }\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.toTypedArray(): Array<ULong> {\n    return Array(size) { index -> this[index] }\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.toTypedArray(): Array<UByte> {\n    return Array(size) { index -> this[index] }\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.toTypedArray(): Array<UShort> {\n    return Array(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of UByte containing all of the elements of this generic array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun Array<out UByte>.toUByteArray(): UByteArray {\n    return UByteArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of type [UByteArray], which is a copy of this array where each element is an unsigned reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.toUByteArray(): UByteArray {\n    return UByteArray(this.copyOf())\n}\n\n/**\n * Returns an array of UInt containing all of the elements of this generic array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun Array<out UInt>.toUIntArray(): UIntArray {\n    return UIntArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of type [UIntArray], which is a copy of this array where each element is an unsigned reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.toUIntArray(): UIntArray {\n    return UIntArray(this.copyOf())\n}\n\n/**\n * Returns an array of ULong containing all of the elements of this generic array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun Array<out ULong>.toULongArray(): ULongArray {\n    return ULongArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of type [ULongArray], which is a copy of this array where each element is an unsigned reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.toULongArray(): ULongArray {\n    return ULongArray(this.copyOf())\n}\n\n/**\n * Returns an array of UShort containing all of the elements of this generic array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun Array<out UShort>.toUShortArray(): UShortArray {\n    return UShortArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of type [UShortArray], which is a copy of this array where each element is an unsigned reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.toUShortArray(): UShortArray {\n    return UShortArray(this.copyOf())\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <V> UIntArray.associateWith(valueSelector: (UInt) -> V): Map<UInt, V> {\n    val result = LinkedHashMap<UInt, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <V> ULongArray.associateWith(valueSelector: (ULong) -> V): Map<ULong, V> {\n    val result = LinkedHashMap<ULong, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <V> UByteArray.associateWith(valueSelector: (UByte) -> V): Map<UByte, V> {\n    val result = LinkedHashMap<UByte, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <V> UShortArray.associateWith(valueSelector: (UShort) -> V): Map<UShort, V> {\n    val result = LinkedHashMap<UShort, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in UInt, in V>> UIntArray.associateWithTo(destination: M, valueSelector: (UInt) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in ULong, in V>> ULongArray.associateWithTo(destination: M, valueSelector: (ULong) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in UByte, in V>> UByteArray.associateWithTo(destination: M, valueSelector: (UByte) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in UShort, in V>> UShortArray.associateWithTo(destination: M, valueSelector: (UShort) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.flatMap(transform: (UInt) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.flatMap(transform: (ULong) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.flatMap(transform: (UByte) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.flatMap(transform: (UShort) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.flatMapIndexed(transform: (index: Int, UInt) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.flatMapIndexed(transform: (index: Int, ULong) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.flatMapIndexed(transform: (index: Int, UByte) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.flatMapIndexed(transform: (index: Int, UShort) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UIntArray.flatMapIndexedTo(destination: C, transform: (index: Int, UInt) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> ULongArray.flatMapIndexedTo(destination: C, transform: (index: Int, ULong) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UByteArray.flatMapIndexedTo(destination: C, transform: (index: Int, UByte) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UShortArray.flatMapIndexedTo(destination: C, transform: (index: Int, UShort) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UIntArray.flatMapTo(destination: C, transform: (UInt) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> ULongArray.flatMapTo(destination: C, transform: (ULong) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UByteArray.flatMapTo(destination: C, transform: (UByte) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UShortArray.flatMapTo(destination: C, transform: (UShort) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K> UIntArray.groupBy(keySelector: (UInt) -> K): Map<K, List<UInt>> {\n    return groupByTo(LinkedHashMap<K, MutableList<UInt>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K> ULongArray.groupBy(keySelector: (ULong) -> K): Map<K, List<ULong>> {\n    return groupByTo(LinkedHashMap<K, MutableList<ULong>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K> UByteArray.groupBy(keySelector: (UByte) -> K): Map<K, List<UByte>> {\n    return groupByTo(LinkedHashMap<K, MutableList<UByte>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K> UShortArray.groupBy(keySelector: (UShort) -> K): Map<K, List<UShort>> {\n    return groupByTo(LinkedHashMap<K, MutableList<UShort>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> UIntArray.groupBy(keySelector: (UInt) -> K, valueTransform: (UInt) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> ULongArray.groupBy(keySelector: (ULong) -> K, valueTransform: (ULong) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> UByteArray.groupBy(keySelector: (UByte) -> K, valueTransform: (UByte) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> UShortArray.groupBy(keySelector: (UShort) -> K, valueTransform: (UShort) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, M : MutableMap<in K, MutableList<UInt>>> UIntArray.groupByTo(destination: M, keySelector: (UInt) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<UInt>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, M : MutableMap<in K, MutableList<ULong>>> ULongArray.groupByTo(destination: M, keySelector: (ULong) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<ULong>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, M : MutableMap<in K, MutableList<UByte>>> UByteArray.groupByTo(destination: M, keySelector: (UByte) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<UByte>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, M : MutableMap<in K, MutableList<UShort>>> UShortArray.groupByTo(destination: M, keySelector: (UShort) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<UShort>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> UIntArray.groupByTo(destination: M, keySelector: (UInt) -> K, valueTransform: (UInt) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> ULongArray.groupByTo(destination: M, keySelector: (ULong) -> K, valueTransform: (ULong) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> UByteArray.groupByTo(destination: M, keySelector: (UByte) -> K, valueTransform: (UByte) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> UShortArray.groupByTo(destination: M, keySelector: (UShort) -> K, valueTransform: (UShort) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.map(transform: (UInt) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.map(transform: (ULong) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.map(transform: (UByte) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.map(transform: (UShort) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.mapIndexed(transform: (index: Int, UInt) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.mapIndexed(transform: (index: Int, ULong) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.mapIndexed(transform: (index: Int, UByte) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.mapIndexed(transform: (index: Int, UShort) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UIntArray.mapIndexedTo(destination: C, transform: (index: Int, UInt) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> ULongArray.mapIndexedTo(destination: C, transform: (index: Int, ULong) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UByteArray.mapIndexedTo(destination: C, transform: (index: Int, UByte) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UShortArray.mapIndexedTo(destination: C, transform: (index: Int, UShort) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UIntArray.mapTo(destination: C, transform: (UInt) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> ULongArray.mapTo(destination: C, transform: (ULong) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UByteArray.mapTo(destination: C, transform: (UByte) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UShortArray.mapTo(destination: C, transform: (UShort) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.withIndex(): Iterable<IndexedValue<UInt>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.withIndex(): Iterable<IndexedValue<ULong>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.withIndex(): Iterable<IndexedValue<UByte>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.withIndex(): Iterable<IndexedValue<UShort>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.all(predicate: (UInt) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.all(predicate: (ULong) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.all(predicate: (UByte) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.all(predicate: (UShort) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.any(): Boolean {\n    return storage.any()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.any(): Boolean {\n    return storage.any()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.any(): Boolean {\n    return storage.any()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.any(): Boolean {\n    return storage.any()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.any(predicate: (UInt) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.any(predicate: (ULong) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.any(predicate: (UByte) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.any(predicate: (UShort) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.count(predicate: (UInt) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.count(predicate: (ULong) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.count(predicate: (UByte) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.count(predicate: (UShort) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.fold(initial: R, operation: (acc: R, UInt) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.fold(initial: R, operation: (acc: R, ULong) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.fold(initial: R, operation: (acc: R, UByte) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.fold(initial: R, operation: (acc: R, UShort) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.foldIndexed(initial: R, operation: (index: Int, acc: R, UInt) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.foldIndexed(initial: R, operation: (index: Int, acc: R, ULong) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.foldIndexed(initial: R, operation: (index: Int, acc: R, UByte) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.foldIndexed(initial: R, operation: (index: Int, acc: R, UShort) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.foldRight(initial: R, operation: (UInt, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.foldRight(initial: R, operation: (ULong, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.foldRight(initial: R, operation: (UByte, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.foldRight(initial: R, operation: (UShort, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.foldRightIndexed(initial: R, operation: (index: Int, UInt, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.foldRightIndexed(initial: R, operation: (index: Int, ULong, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.foldRightIndexed(initial: R, operation: (index: Int, UByte, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.foldRightIndexed(initial: R, operation: (index: Int, UShort, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.forEach(action: (UInt) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.forEach(action: (ULong) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.forEach(action: (UByte) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.forEach(action: (UShort) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.forEachIndexed(action: (index: Int, UInt) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.forEachIndexed(action: (index: Int, ULong) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.forEachIndexed(action: (index: Int, UByte) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.forEachIndexed(action: (index: Int, UShort) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.max(): UInt? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.max(): ULong? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.max(): UByte? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.max(): UShort? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UIntArray.maxBy(selector: (UInt) -> R): UInt? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ULongArray.maxBy(selector: (ULong) -> R): ULong? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UByteArray.maxBy(selector: (UByte) -> R): UByte? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UShortArray.maxBy(selector: (UShort) -> R): UShort? {\n    return maxByOrNull(selector)\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UIntArray.maxByOrNull(selector: (UInt) -> R): UInt? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ULongArray.maxByOrNull(selector: (ULong) -> R): ULong? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UByteArray.maxByOrNull(selector: (UByte) -> R): UByte? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UShortArray.maxByOrNull(selector: (UShort) -> R): UShort? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.maxOf(selector: (UInt) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.maxOf(selector: (ULong) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.maxOf(selector: (UByte) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.maxOf(selector: (UShort) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.maxOf(selector: (UInt) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.maxOf(selector: (ULong) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.maxOf(selector: (UByte) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.maxOf(selector: (UShort) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UIntArray.maxOf(selector: (UInt) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ULongArray.maxOf(selector: (ULong) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UByteArray.maxOf(selector: (UByte) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UShortArray.maxOf(selector: (UShort) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.maxOfOrNull(selector: (UInt) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.maxOfOrNull(selector: (ULong) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.maxOfOrNull(selector: (UByte) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.maxOfOrNull(selector: (UShort) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.maxOfOrNull(selector: (UInt) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.maxOfOrNull(selector: (ULong) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.maxOfOrNull(selector: (UByte) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.maxOfOrNull(selector: (UShort) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UIntArray.maxOfOrNull(selector: (UInt) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ULongArray.maxOfOrNull(selector: (ULong) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UByteArray.maxOfOrNull(selector: (UByte) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UShortArray.maxOfOrNull(selector: (UShort) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.maxOfWith(comparator: Comparator<in R>, selector: (UInt) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.maxOfWith(comparator: Comparator<in R>, selector: (ULong) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.maxOfWith(comparator: Comparator<in R>, selector: (UByte) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.maxOfWith(comparator: Comparator<in R>, selector: (UShort) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (UInt) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (ULong) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (UByte) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (UShort) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.maxOrNull(): UInt? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.maxOrNull(): ULong? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.maxOrNull(): UByte? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.maxOrNull(): UShort? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.maxWith(comparator: Comparator<in UInt>): UInt? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.maxWith(comparator: Comparator<in ULong>): ULong? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.maxWith(comparator: Comparator<in UByte>): UByte? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.maxWith(comparator: Comparator<in UShort>): UShort? {\n    return maxWithOrNull(comparator)\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.maxWithOrNull(comparator: Comparator<in UInt>): UInt? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.maxWithOrNull(comparator: Comparator<in ULong>): ULong? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.maxWithOrNull(comparator: Comparator<in UByte>): UByte? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.maxWithOrNull(comparator: Comparator<in UShort>): UShort? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.min(): UInt? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.min(): ULong? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.min(): UByte? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.min(): UShort? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UIntArray.minBy(selector: (UInt) -> R): UInt? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ULongArray.minBy(selector: (ULong) -> R): ULong? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UByteArray.minBy(selector: (UByte) -> R): UByte? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UShortArray.minBy(selector: (UShort) -> R): UShort? {\n    return minByOrNull(selector)\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UIntArray.minByOrNull(selector: (UInt) -> R): UInt? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ULongArray.minByOrNull(selector: (ULong) -> R): ULong? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UByteArray.minByOrNull(selector: (UByte) -> R): UByte? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UShortArray.minByOrNull(selector: (UShort) -> R): UShort? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.minOf(selector: (UInt) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.minOf(selector: (ULong) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.minOf(selector: (UByte) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.minOf(selector: (UShort) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.minOf(selector: (UInt) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.minOf(selector: (ULong) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.minOf(selector: (UByte) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.minOf(selector: (UShort) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UIntArray.minOf(selector: (UInt) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ULongArray.minOf(selector: (ULong) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UByteArray.minOf(selector: (UByte) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UShortArray.minOf(selector: (UShort) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.minOfOrNull(selector: (UInt) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.minOfOrNull(selector: (ULong) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.minOfOrNull(selector: (UByte) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.minOfOrNull(selector: (UShort) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.minOfOrNull(selector: (UInt) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.minOfOrNull(selector: (ULong) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.minOfOrNull(selector: (UByte) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.minOfOrNull(selector: (UShort) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UIntArray.minOfOrNull(selector: (UInt) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ULongArray.minOfOrNull(selector: (ULong) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UByteArray.minOfOrNull(selector: (UByte) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UShortArray.minOfOrNull(selector: (UShort) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.minOfWith(comparator: Comparator<in R>, selector: (UInt) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.minOfWith(comparator: Comparator<in R>, selector: (ULong) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.minOfWith(comparator: Comparator<in R>, selector: (UByte) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.minOfWith(comparator: Comparator<in R>, selector: (UShort) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (UInt) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (ULong) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (UByte) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (UShort) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.minOrNull(): UInt? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.minOrNull(): ULong? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.minOrNull(): UByte? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.minOrNull(): UShort? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.minWith(comparator: Comparator<in UInt>): UInt? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.minWith(comparator: Comparator<in ULong>): ULong? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.minWith(comparator: Comparator<in UByte>): UByte? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.minWith(comparator: Comparator<in UShort>): UShort? {\n    return minWithOrNull(comparator)\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.minWithOrNull(comparator: Comparator<in UInt>): UInt? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.minWithOrNull(comparator: Comparator<in ULong>): ULong? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.minWithOrNull(comparator: Comparator<in UByte>): UByte? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.minWithOrNull(comparator: Comparator<in UShort>): UShort? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.none(predicate: (UInt) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.none(predicate: (ULong) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.none(predicate: (UByte) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.none(predicate: (UShort) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.onEach(action: (UInt) -> Unit): UIntArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.onEach(action: (ULong) -> Unit): ULongArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.onEach(action: (UByte) -> Unit): UByteArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.onEach(action: (UShort) -> Unit): UShortArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.onEachIndexed(action: (index: Int, UInt) -> Unit): UIntArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.onEachIndexed(action: (index: Int, ULong) -> Unit): ULongArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.onEachIndexed(action: (index: Int, UByte) -> Unit): UByteArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.onEachIndexed(action: (index: Int, UShort) -> Unit): UShortArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.reduce(operation: (acc: UInt, UInt) -> UInt): UInt {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.reduce(operation: (acc: ULong, ULong) -> ULong): ULong {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.reduce(operation: (acc: UByte, UByte) -> UByte): UByte {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.reduce(operation: (acc: UShort, UShort) -> UShort): UShort {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.reduceIndexed(operation: (index: Int, acc: UInt, UInt) -> UInt): UInt {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.reduceIndexed(operation: (index: Int, acc: ULong, ULong) -> ULong): ULong {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.reduceIndexed(operation: (index: Int, acc: UByte, UByte) -> UByte): UByte {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.reduceIndexed(operation: (index: Int, acc: UShort, UShort) -> UShort): UShort {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.reduceIndexedOrNull(operation: (index: Int, acc: UInt, UInt) -> UInt): UInt? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.reduceIndexedOrNull(operation: (index: Int, acc: ULong, ULong) -> ULong): ULong? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.reduceIndexedOrNull(operation: (index: Int, acc: UByte, UByte) -> UByte): UByte? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.reduceIndexedOrNull(operation: (index: Int, acc: UShort, UShort) -> UShort): UShort? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.reduceOrNull(operation: (acc: UInt, UInt) -> UInt): UInt? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.reduceOrNull(operation: (acc: ULong, ULong) -> ULong): ULong? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.reduceOrNull(operation: (acc: UByte, UByte) -> UByte): UByte? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.reduceOrNull(operation: (acc: UShort, UShort) -> UShort): UShort? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.reduceRight(operation: (UInt, acc: UInt) -> UInt): UInt {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.reduceRight(operation: (ULong, acc: ULong) -> ULong): ULong {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.reduceRight(operation: (UByte, acc: UByte) -> UByte): UByte {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.reduceRight(operation: (UShort, acc: UShort) -> UShort): UShort {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.reduceRightIndexed(operation: (index: Int, UInt, acc: UInt) -> UInt): UInt {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.reduceRightIndexed(operation: (index: Int, ULong, acc: ULong) -> ULong): ULong {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.reduceRightIndexed(operation: (index: Int, UByte, acc: UByte) -> UByte): UByte {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.reduceRightIndexed(operation: (index: Int, UShort, acc: UShort) -> UShort): UShort {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.reduceRightIndexedOrNull(operation: (index: Int, UInt, acc: UInt) -> UInt): UInt? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.reduceRightIndexedOrNull(operation: (index: Int, ULong, acc: ULong) -> ULong): ULong? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.reduceRightIndexedOrNull(operation: (index: Int, UByte, acc: UByte) -> UByte): UByte? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.reduceRightIndexedOrNull(operation: (index: Int, UShort, acc: UShort) -> UShort): UShort? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.reduceRightOrNull(operation: (UInt, acc: UInt) -> UInt): UInt? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.reduceRightOrNull(operation: (ULong, acc: ULong) -> ULong): ULong? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.reduceRightOrNull(operation: (UByte, acc: UByte) -> UByte): UByte? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.reduceRightOrNull(operation: (UShort, acc: UShort) -> UShort): UShort? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.runningFold(initial: R, operation: (acc: R, UInt) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.runningFold(initial: R, operation: (acc: R, ULong) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.runningFold(initial: R, operation: (acc: R, UByte) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.runningFold(initial: R, operation: (acc: R, UShort) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, UInt) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, ULong) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, UByte) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, UShort) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.runningReduce(operation: (acc: UInt, UInt) -> UInt): List<UInt> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<UInt>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.runningReduce(operation: (acc: ULong, ULong) -> ULong): List<ULong> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<ULong>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.runningReduce(operation: (acc: UByte, UByte) -> UByte): List<UByte> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<UByte>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.runningReduce(operation: (acc: UShort, UShort) -> UShort): List<UShort> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<UShort>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.runningReduceIndexed(operation: (index: Int, acc: UInt, UInt) -> UInt): List<UInt> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<UInt>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.runningReduceIndexed(operation: (index: Int, acc: ULong, ULong) -> ULong): List<ULong> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<ULong>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.runningReduceIndexed(operation: (index: Int, acc: UByte, UByte) -> UByte): List<UByte> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<UByte>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.runningReduceIndexed(operation: (index: Int, acc: UShort, UShort) -> UShort): List<UShort> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<UShort>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.scan(initial: R, operation: (acc: R, UInt) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.scan(initial: R, operation: (acc: R, ULong) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.scan(initial: R, operation: (acc: R, UByte) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.scan(initial: R, operation: (acc: R, UShort) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.scanIndexed(initial: R, operation: (index: Int, acc: R, UInt) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.scanIndexed(initial: R, operation: (index: Int, acc: R, ULong) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.scanIndexed(initial: R, operation: (index: Int, acc: R, UByte) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.scanIndexed(initial: R, operation: (index: Int, acc: R, UShort) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n@Deprecated(\"Use runningReduce instead.\", ReplaceWith(\"runningReduce(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.scanReduce(operation: (acc: UInt, UInt) -> UInt): List<UInt> {\n    return runningReduce(operation)\n}\n\n@Deprecated(\"Use runningReduce instead.\", ReplaceWith(\"runningReduce(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.scanReduce(operation: (acc: ULong, ULong) -> ULong): List<ULong> {\n    return runningReduce(operation)\n}\n\n@Deprecated(\"Use runningReduce instead.\", ReplaceWith(\"runningReduce(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.scanReduce(operation: (acc: UByte, UByte) -> UByte): List<UByte> {\n    return runningReduce(operation)\n}\n\n@Deprecated(\"Use runningReduce instead.\", ReplaceWith(\"runningReduce(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.scanReduce(operation: (acc: UShort, UShort) -> UShort): List<UShort> {\n    return runningReduce(operation)\n}\n\n@Deprecated(\"Use runningReduceIndexed instead.\", ReplaceWith(\"runningReduceIndexed(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.scanReduceIndexed(operation: (index: Int, acc: UInt, UInt) -> UInt): List<UInt> {\n    return runningReduceIndexed(operation)\n}\n\n@Deprecated(\"Use runningReduceIndexed instead.\", ReplaceWith(\"runningReduceIndexed(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.scanReduceIndexed(operation: (index: Int, acc: ULong, ULong) -> ULong): List<ULong> {\n    return runningReduceIndexed(operation)\n}\n\n@Deprecated(\"Use runningReduceIndexed instead.\", ReplaceWith(\"runningReduceIndexed(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.scanReduceIndexed(operation: (index: Int, acc: UByte, UByte) -> UByte): List<UByte> {\n    return runningReduceIndexed(operation)\n}\n\n@Deprecated(\"Use runningReduceIndexed instead.\", ReplaceWith(\"runningReduceIndexed(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.scanReduceIndexed(operation: (index: Int, acc: UShort, UShort) -> UShort): List<UShort> {\n    return runningReduceIndexed(operation)\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.sumBy(selector: (UInt) -> UInt): UInt {\n    var sum: UInt = 0u\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.sumBy(selector: (ULong) -> UInt): UInt {\n    var sum: UInt = 0u\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.sumBy(selector: (UByte) -> UInt): UInt {\n    var sum: UInt = 0u\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.sumBy(selector: (UShort) -> UInt): UInt {\n    var sum: UInt = 0u\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.sumByDouble(selector: (UInt) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.sumByDouble(selector: (ULong) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.sumByDouble(selector: (UByte) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.sumByDouble(selector: (UShort) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.sumOf(selector: (UInt) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.sumOf(selector: (ULong) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.sumOf(selector: (UByte) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.sumOf(selector: (UShort) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.sumOf(selector: (UInt) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.sumOf(selector: (ULong) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.sumOf(selector: (UByte) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.sumOf(selector: (UShort) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.sumOf(selector: (UInt) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.sumOf(selector: (ULong) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.sumOf(selector: (UByte) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.sumOf(selector: (UShort) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.sumOf(selector: (UInt) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.sumOf(selector: (ULong) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.sumOf(selector: (UByte) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.sumOf(selector: (UShort) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.sumOf(selector: (UInt) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.sumOf(selector: (ULong) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.sumOf(selector: (UByte) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.sumOf(selector: (UShort) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun <R> UIntArray.zip(other: Array<out R>): List<Pair<UInt, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun <R> ULongArray.zip(other: Array<out R>): List<Pair<ULong, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun <R> UByteArray.zip(other: Array<out R>): List<Pair<UByte, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun <R> UShortArray.zip(other: Array<out R>): List<Pair<UShort, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, V> UIntArray.zip(other: Array<out R>, transform: (a: UInt, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, V> ULongArray.zip(other: Array<out R>, transform: (a: ULong, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, V> UByteArray.zip(other: Array<out R>, transform: (a: UByte, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, V> UShortArray.zip(other: Array<out R>, transform: (a: UShort, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun <R> UIntArray.zip(other: Iterable<R>): List<Pair<UInt, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun <R> ULongArray.zip(other: Iterable<R>): List<Pair<ULong, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun <R> UByteArray.zip(other: Iterable<R>): List<Pair<UByte, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun <R> UShortArray.zip(other: Iterable<R>): List<Pair<UShort, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, V> UIntArray.zip(other: Iterable<R>, transform: (a: UInt, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, V> ULongArray.zip(other: Iterable<R>, transform: (a: ULong, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, V> UByteArray.zip(other: Iterable<R>, transform: (a: UByte, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, V> UShortArray.zip(other: Iterable<R>, transform: (a: UShort, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun UIntArray.zip(other: UIntArray): List<Pair<UInt, UInt>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun ULongArray.zip(other: ULongArray): List<Pair<ULong, ULong>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun UByteArray.zip(other: UByteArray): List<Pair<UByte, UByte>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun UShortArray.zip(other: UShortArray): List<Pair<UShort, UShort>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <V> UIntArray.zip(other: UIntArray, transform: (a: UInt, b: UInt) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <V> ULongArray.zip(other: ULongArray, transform: (a: ULong, b: ULong) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <V> UByteArray.zip(other: UByteArray, transform: (a: UByte, b: UByte) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <V> UShortArray.zip(other: UShortArray, transform: (a: UShort, b: UShort) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun Array<out UInt>.sum(): UInt {\n    var sum: UInt = 0u\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun Array<out ULong>.sum(): ULong {\n    var sum: ULong = 0uL\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfUByte\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun Array<out UByte>.sum(): UInt {\n    var sum: UInt = 0u\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfUShort\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun Array<out UShort>.sum(): UInt {\n    var sum: UInt = 0u\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.sum(): UInt {\n    return storage.sum().toUInt()\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.sum(): ULong {\n    return storage.sum().toULong()\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.sum(): UInt {\n    return sumBy { it.toUInt() }\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.sum(): UInt {\n    return sumBy { it.toUInt() }\n}\n\n","package io.ktor.utils.io.bits\n\nimport io.ktor.utils.io.core.internal.*\nimport org.khronos.webgl.*\nimport kotlin.contracts.*\n\n/**\n * Execute [block] of code providing a temporary instance of [Memory] view of this byte array range\n * starting at the specified [offset] and having the specified bytes [length].\n * By default, if neither [offset] nor [length] specified, the whole array is used.\n * An instance of [Memory] provided into the [block] should be never captured and used outside of lambda.\n */\npublic actual inline fun <R> ByteArray.useMemory(offset: Int, length: Int, block: (Memory) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return Memory.of(this, offset, length).let(block)\n}\n\n/**\n * Create [Memory] view for the specified [array] range starting at [offset] and the specified bytes [length].\n */\npublic fun Memory.Companion.of(array: ByteArray, offset: Int = 0, length: Int = array.size - offset): Memory {\n    @Suppress(\"UnsafeCastFromDynamic\")\n    val typedArray: Int8Array = array.asDynamic()\n    return Memory.of(typedArray, offset, length)\n}\n\n/**\n * Create [Memory] view for the specified [buffer] range starting at [offset] and the specified bytes [length].\n */\npublic fun Memory.Companion.of(buffer: ArrayBuffer, offset: Int = 0, length: Int = buffer.byteLength - offset): Memory {\n    return Memory(DataView(buffer, offset, length))\n}\n\n/**\n * Create [Memory] view for the specified [view].\n */\npublic fun Memory.Companion.of(view: DataView): Memory {\n    return Memory(view)\n}\n\n/**\n * Create [Memory] view for the specified [view] range starting at [offset] and the specified bytes [length].\n */\npublic fun Memory.Companion.of(view: ArrayBufferView, offset: Int = 0, length: Int = view.byteLength): Memory {\n    return Memory.of(view.buffer, view.byteOffset + offset, length)\n}\n\n@PublishedApi\ninternal actual object DefaultAllocator : Allocator {\n    override fun alloc(size: Int): Memory = Memory(DataView(ArrayBuffer(size)))\n    override fun alloc(size: Long): Memory = Memory(DataView(ArrayBuffer(size.toIntOrFail(\"size\"))))\n    override fun free(instance: Memory) {\n    }\n}\n","package io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.core.internal.*\n\n/**\n * This shouldn't be implemented directly. Inherit [AbstractOutput] instead.\n */\npublic expect interface Output : Appendable, Closeable {\n    @Deprecated(\n        \"This is no longer supported. All operations are big endian by default. Use writeXXXLittleEndian \" +\n            \"to write primitives in little endian order\" +\n            \" or do X.reverseByteOrder() and then writeXXX instead.\",\n        level = DeprecationLevel.ERROR\n    )\n    public var byteOrder: ByteOrder\n\n    public fun writeByte(v: Byte)\n\n    public fun flush()\n\n    override fun close()\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun writeShort(v: Short) {\n        writeShort(v)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun writeInt(v: Int) {\n        writeInt(v)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun writeLong(v: Long) {\n        writeLong(v)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun writeFloat(v: Float) {\n        writeFloat(v)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun writeDouble(v: Double) {\n        writeDouble(v)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun writeFully(src: ByteArray, offset: Int, length: Int) {\n        writeFully(src, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun writeFully(src: ShortArray, offset: Int, length: Int) {\n        writeFully(src, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun writeFully(src: IntArray, offset: Int, length: Int) {\n        writeFully(src, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun writeFully(src: LongArray, offset: Int, length: Int) {\n        writeFully(src, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun writeFully(src: FloatArray, offset: Int, length: Int) {\n        writeFully(src, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun writeFully(src: DoubleArray, offset: Int, length: Int) {\n        writeFully(src, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\", \"DEPRECATION\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun writeFully(src: IoBuffer, length: Int) {\n        writeFully(src, length)\n    }\n\n    public fun append(csq: CharArray, start: Int, end: Int): Appendable\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\", \"DEPRECATION\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun fill(n: Long, v: Byte) {\n        fill(n, v)\n    }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Output.append(csq: CharSequence, start: Int = 0, end: Int = csq.length): Appendable {\n    return append(csq, start, end)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Output.append(csq: CharArray, start: Int = 0, end: Int = csq.size): Appendable {\n    return append(csq, start, end)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Output.writeFully(src: ByteArray, offset: Int = 0, length: Int = src.size - offset) {\n    writeFullyBytesTemplate(offset, length) { buffer, currentOffset, count ->\n        buffer.writeFully(src, currentOffset, count)\n    }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Output.writeFully(src: ShortArray, offset: Int = 0, length: Int = src.size - offset) {\n    writeFullyTemplate(2, offset, length) { buffer, currentOffset, count ->\n        buffer.writeFully(src, currentOffset, count)\n    }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Output.writeFully(src: IntArray, offset: Int = 0, length: Int = src.size - offset) {\n    writeFullyTemplate(4, offset, length) { buffer, currentOffset, count ->\n        buffer.writeFully(src, currentOffset, count)\n    }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Output.writeFully(src: LongArray, offset: Int = 0, length: Int = src.size - offset) {\n    writeFullyTemplate(8, offset, length) { buffer, currentOffset, count ->\n        buffer.writeFully(src, currentOffset, count)\n    }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Output.writeFully(src: FloatArray, offset: Int = 0, length: Int = src.size - offset) {\n    writeFullyTemplate(4, offset, length) { buffer, currentOffset, count ->\n        buffer.writeFully(src, currentOffset, count)\n    }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Output.writeFully(src: DoubleArray, offset: Int = 0, length: Int = src.size - offset) {\n    writeFullyTemplate(8, offset, length) { buffer, currentOffset, count ->\n        buffer.writeFully(src, currentOffset, count)\n    }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\npublic fun Output.writeFully(src: IoBuffer, length: Int = src.readRemaining) {\n    writeFully(src as Buffer, length)\n}\n\npublic fun Output.writeFully(src: Buffer, length: Int = src.readRemaining) {\n    writeFullyBytesTemplate(0, length) { buffer, _, count ->\n        buffer.writeFully(src, count)\n    }\n}\n\npublic fun Output.writeFully(src: Memory, offset: Int, length: Int) {\n    writeFully(src, offset.toLong(), length.toLong())\n}\n\npublic fun Output.writeFully(src: Memory, offset: Long, length: Long) {\n    writeFullyBytesTemplate(offset, length) { memory, destinationOffset, sourceOffset, count ->\n        src.copyTo(memory, sourceOffset, count, destinationOffset)\n    }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Output.fill(times: Long, value: Byte = 0) {\n    if (this is AbstractOutput) {\n        var written = 0L\n        writeWhile { buffer ->\n            val partTimes = minOf(buffer.writeRemaining.toLong(), times - written).toInt()\n            buffer.fill(partTimes, value)\n            written += partTimes\n            written < times\n        }\n    } else {\n        fillFallback(times, value)\n    }\n}\n\nprivate fun Output.fillFallback(times: Long, value: Byte) {\n    for (iterate in 0 until times) {\n        writeByte(value)\n    }\n}\n\n/**\n * Append number of chunks invoking [block] function while the returned value is true.\n * Depending on the output underlying implementation it could invoke [block] function with the same buffer several times\n * however it is guaranteed that it is always non-empty.\n */\n@DangerousInternalIoApi\npublic inline fun Output.writeWhile(block: (Buffer) -> Boolean) {\n    var tail: ChunkBuffer = prepareWriteHead(1, null)\n    try {\n        while (true) {\n            if (!block(tail)) break\n            tail = prepareWriteHead(1, tail)\n        }\n    } finally {\n        afterHeadWrite(tail)\n    }\n}\n\n/**\n * Append number of chunks invoking [block] function while the returned value is positive.\n * If returned value is positive then it will be invoked again with a buffer having at least requested number of\n * bytes space (could be the same buffer as before if it complies to the restriction).\n * @param initialSize for the first buffer passed to [block] function\n */\n@DangerousInternalIoApi\npublic inline fun Output.writeWhileSize(initialSize: Int = 1, block: (Buffer) -> Int) {\n    var tail = prepareWriteHead(initialSize, null)\n\n    try {\n        var size: Int\n        while (true) {\n            size = block(tail)\n            if (size <= 0) break\n            tail = prepareWriteHead(size, tail)\n        }\n    } finally {\n        afterHeadWrite(tail)\n    }\n}\n\npublic fun Output.writePacket(packet: ByteReadPacket) {\n    @Suppress(\"DEPRECATION_ERROR\")\n    if (this is BytePacketBuilderBase) {\n        writePacket(packet)\n        return\n    }\n\n    packet.takeWhile { from ->\n        writeFully(from)\n        true\n    }\n}\n\nprivate inline fun Output.writeFullyBytesTemplate(\n    offset: Int,\n    length: Int,\n    block: (Buffer, currentOffset: Int, count: Int) -> Unit\n) {\n    var currentOffset = offset\n    var remaining = length\n\n    writeWhile { buffer ->\n        val size = minOf(remaining, buffer.writeRemaining)\n        block(buffer, currentOffset, size)\n        currentOffset += size\n        remaining -= size\n        remaining > 0\n    }\n}\n\nprivate inline fun Output.writeFullyBytesTemplate(\n    initialOffset: Long,\n    length: Long,\n    block: (destination: Memory, destinationOffset: Long, currentOffset: Long, count: Long) -> Unit\n) {\n    var currentOffset = initialOffset\n    var remaining = length\n\n    writeWhile { buffer ->\n        val size = minOf(remaining, buffer.writeRemaining.toLong())\n        block(buffer.memory, buffer.writePosition.toLong(), currentOffset, size)\n        buffer.commitWritten(size.toInt())\n        currentOffset += size\n        remaining -= size\n        remaining > 0\n    }\n}\n\nprivate inline fun Output.writeFullyTemplate(\n    componentSize: Int,\n    offset: Int,\n    length: Int,\n    block: (Buffer, currentOffset: Int, count: Int) -> Unit\n) {\n    var currentOffset = offset\n    var remaining = length\n\n    writeWhileSize(componentSize) { buffer ->\n        val size = minOf(remaining, buffer.writeRemaining)\n        block(buffer, currentOffset, size)\n        currentOffset += size\n        remaining -= size\n        remaining * componentSize\n    }\n}\n\n","@file:Suppress(\"RedundantModalityModifier\")\n\npackage io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.core.internal.*\nimport io.ktor.utils.io.core.internal.require\nimport io.ktor.utils.io.pool.*\n\n/**\n * The default abstract base class implementing [Input] interface.\n * @see [AbstractInput.fill] and [AbstractInput.closeSource].\n */\npublic abstract class AbstractInput(\n    head: ChunkBuffer = ChunkBuffer.Empty,\n    remaining: Long = head.remainingAll(),\n    public val pool: ObjectPool<ChunkBuffer> = ChunkBuffer.Pool\n) : Input {\n    private val state = AbstractInputSharedState(head, remaining)\n\n    @Suppress(\"DEPRECATION\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public constructor(head: IoBuffer = IoBuffer.Empty,\n                remaining: Long = head.remainingAll(),\n                pool: ObjectPool<ChunkBuffer> = ChunkBuffer.Pool) : this(head as ChunkBuffer, remaining, pool)\n\n    /**\n     * Read the next bytes into the [destination] starting at [offset] at most [length] bytes.\n     * May block until at least one byte is available.\n     * Usually bypass all exceptions from the underlying source.\n     *\n     * @param offset in bytes where result should be written\n     * @param length should be at least one byte\n     *\n     * @return number of bytes were copied or `0` if EOF encountered\n     */\n    protected abstract fun fill(destination: Memory, offset: Int, length: Int): Int\n\n    /**\n     * Should close the underlying bytes source. Could do nothing or throw exceptions.\n     */\n    protected abstract fun closeSource()\n\n    /**\n     * Current head chunk reference\n     */\n    private final var _head: ChunkBuffer\n        get() = state.head\n        set(newHead) {\n            state.head = newHead\n            state.headMemory = newHead.memory\n            state.headPosition = newHead.readPosition\n            state.headEndExclusive = newHead.writePosition\n        }\n\n    @PublishedApi\n    @Suppress(\"CanBePrimaryConstructorProperty\")\n    internal var head: ChunkBuffer\n        get() = _head.also { it.discardUntilIndex(headPosition) }\n        @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.ERROR)\n        set(newHead) {\n            _head = newHead\n        }\n\n    @PublishedApi\n    internal final var headMemory: Memory\n        get() = state.headMemory\n        set(value) {\n            state.headMemory = value\n        }\n\n    @PublishedApi\n    internal final var headPosition: Int\n        get() = state.headPosition\n        set(value) {\n            state.headPosition = value\n        }\n\n    @PublishedApi\n    internal final var headEndExclusive: Int\n        get() = state.headEndExclusive\n        set(value) {\n            state.headEndExclusive = value\n        }\n\n    @PublishedApi\n    @Suppress(\"DEPRECATION_ERROR\")\n    internal final var headRemaining: Int\n        inline get() = headEndExclusive - headPosition\n        @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n        set(newRemaining) {\n            updateHeadRemaining(newRemaining)\n        }\n\n    private var tailRemaining: Long\n        get() = state.tailRemaining\n        set(newValue) {\n            require(newValue >= 0) { \"tailRemaining shouldn't be negative: $newValue\" }\n            state.tailRemaining = newValue\n        }\n\n    @Deprecated(\n        \"Not supported anymore. All operations are big endian by default.\",\n        level = DeprecationLevel.ERROR\n    )\n    final override var byteOrder: ByteOrder\n        get() = ByteOrder.BIG_ENDIAN\n        set(newOrder) {\n            if (newOrder != ByteOrder.BIG_ENDIAN) {\n                throw IllegalArgumentException(\"Only BIG_ENDIAN is supported.\")\n            }\n        }\n\n    internal final fun prefetch(min: Long): Boolean {\n        if (min <= 0) return true\n        val headRemaining = headRemaining\n        if (headRemaining >= min || headRemaining + tailRemaining >= min) return true\n\n        return doPrefetch(min)\n    }\n\n    final override fun peekTo(destination: Memory, destinationOffset: Long, offset: Long, min: Long, max: Long): Long {\n        prefetch(min + offset)\n\n        var current: ChunkBuffer = head\n        var copied = 0L\n        var skip = offset\n        var writePosition = destinationOffset\n        val maxCopySize = minOf(max, destination.size - destinationOffset)\n\n        while (copied < min && copied < maxCopySize) {\n            val chunkSize = current.readRemaining\n            if (chunkSize > skip) {\n                val size = minOf(chunkSize - skip, maxCopySize - copied)\n                current.memory.copyTo(\n                    destination,\n                    current.readPosition + skip,\n                    size,\n                    writePosition\n                )\n                skip = 0\n                copied += size\n                writePosition += size\n            } else {\n                skip -= chunkSize\n            }\n\n            current = current.next ?: break\n        }\n\n        return copied\n    }\n\n    /**\n     * @see doFill for similar logic\n     * @see appendView for similar logic\n     */\n    private fun doPrefetch(min: Long): Boolean {\n        var tail = _head.findTail()\n        var available = headRemaining + tailRemaining\n\n        do {\n            val next = fill()\n            if (next == null) {\n                noMoreChunksAvailable = true\n                return false\n            }\n\n            val chunkSize = next.readRemaining\n            if (tail === ChunkBuffer.Empty) {\n                _head = next\n                tail = next\n            } else {\n                tail.next = next\n                tailRemaining += chunkSize\n            }\n\n            available += chunkSize\n        } while (available < min)\n\n        return true\n    }\n\n    /**\n     * Number of bytes available for read\n     */\n    public final val remaining: Long get() = headRemaining.toLong() + tailRemaining\n\n    /**\n     * @return `true` if there is at least one byte to read\n     */\n    public final fun canRead(): Boolean = headPosition != headEndExclusive || tailRemaining != 0L\n\n    /**\n     * @return `true` if there are at least [n] bytes to read\n     */\n    public final fun hasBytes(n: Int): Boolean = headRemaining + tailRemaining >= n\n\n    /**\n     * `true` if no bytes available for read\n     */\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public final val isEmpty: Boolean\n        get() = endOfInput\n\n    @Suppress(\"DEPRECATION\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public final val isNotEmpty: Boolean\n        get() = isNotEmpty\n\n    private var noMoreChunksAvailable = false\n\n    final override val endOfInput: Boolean\n        get() = headRemaining == 0 && tailRemaining == 0L && (noMoreChunksAvailable || doFill() == null)\n\n    /**\n     * Release packet. After this function invocation the packet becomes empty.\n     * If it has been copied via [ByteReadPacket.copy]\n     * then the copy should be released as well.\n     */\n    public final fun release() {\n        val head = head\n        val empty = ChunkBuffer.Empty\n\n        if (head !== empty) {\n            this._head = empty\n            tailRemaining = 0\n            head.releaseAll(pool)\n        }\n    }\n\n    final override fun close() {\n        release()\n        if (!noMoreChunksAvailable) {\n            noMoreChunksAvailable = true\n        }\n        closeSource()\n    }\n\n    internal final fun stealAll(): ChunkBuffer? {\n        val head = head\n        val empty = ChunkBuffer.Empty\n\n        if (head === empty) return null\n        this._head = empty\n        tailRemaining = 0\n        return head\n    }\n\n    internal final fun steal(): ChunkBuffer? {\n        val head = head\n        val next = head.next\n        val empty = ChunkBuffer.Empty\n        if (head === empty) return null\n\n        if (next == null) {\n            this._head = empty\n            this.tailRemaining = 0\n        } else {\n            this._head = next\n            this.tailRemaining -= next.readRemaining\n        }\n\n        head.next = null\n        return head\n    }\n\n    internal final fun append(chain: ChunkBuffer) {\n        if (chain === ChunkBuffer.Empty) return\n\n        val size = chain.remainingAll()\n        if (_head === ChunkBuffer.Empty) {\n            _head = chain\n            tailRemaining = size - headRemaining\n        } else {\n            _head.findTail().next = chain\n            tailRemaining += size\n        }\n    }\n\n    internal final fun tryWriteAppend(chain: ChunkBuffer): Boolean {\n        val tail = head.findTail()\n        val size = chain.readRemaining\n\n        if (size == 0 || tail.writeRemaining < size) return false\n        tail.writeBufferAppend(chain, size)\n\n        if (head === tail) {\n            headEndExclusive = tail.writePosition\n        } else {\n            tailRemaining += size\n        }\n\n        return true\n    }\n\n    final override fun readByte(): Byte {\n        val index = headPosition\n        val nextIndex = index + 1\n        if (nextIndex < headEndExclusive) {\n            // fast-path when we are not reading the last byte\n            headPosition = nextIndex\n            return headMemory[index]\n        }\n\n        return readByteSlow()\n    }\n\n    private fun readByteSlow(): Byte {\n        val index = headPosition\n        if (index < headEndExclusive) {\n            val value = headMemory[index]\n            headPosition = index\n            val head = _head\n            head.discardUntilIndex(index)\n            ensureNext(head)\n            return value\n        }\n\n        val head = prepareRead(1) ?: prematureEndOfStream(1)\n        val byte = head.readByte()\n        completeReadHead(head)\n        return byte\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    final override fun readShort(): Short = readShort()\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    final override fun readFloat(): Float = readFloat()\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    final override fun readDouble(): Double = readDouble()\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    final override fun readInt(): Int {\n        return readInt()\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    final override fun readLong(): Long {\n        return readLong()\n    }\n\n    /**\n     * Read exactly [length] bytes to [dst] array at specified [offset]\n     */\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    final override fun readFully(dst: ByteArray, offset: Int, length: Int) {\n        val rc = readAvailable(dst, offset, length)\n        if (rc != length) throw EOFException(\"Not enough data in packet to fill buffer: ${length - rc} more bytes required\")\n    }\n\n    /**\n     * Discards at most [n] bytes\n     * @return number of bytes has been discarded\n     */\n    public final fun discard(n: Int): Int {\n        require(n >= 0) { \"Negative discard is not allowed: $n\" }\n        return discardAsMuchAsPossible(n, 0)\n    }\n\n    /**\n     * Discards exactly [n] bytes or fails with [EOFException]\n     */\n    public final fun discardExact(n: Int) {\n        if (discard(n) != n) throw EOFException(\"Unable to discard $n bytes due to end of packet\")\n    }\n\n    @PublishedApi\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    internal inline fun read(block: (Buffer) -> Unit) {\n        read(block = block)\n    }\n\n    @PublishedApi\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    internal inline fun read(n: Int, block: (Buffer) -> Unit) {\n        read(n, block)\n    }\n\n    /**\n     * Returns next byte (unsigned) or `-1` if no more bytes available\n     */\n    final override fun tryPeek(): Int {\n        val head = head\n        if (headRemaining > 0) {\n            return head.tryPeekByte()\n        }\n\n        if (tailRemaining == 0L && noMoreChunksAvailable) return -1\n\n        return prepareReadLoop(1, head)?.tryPeekByte() ?: -1\n    }\n\n    @Suppress(\"DEPRECATION\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    final override fun peekTo(buffer: IoBuffer): Int {\n        val head = prepareReadHead(1) ?: return -1\n\n        val size = minOf(buffer.writeRemaining, head.readRemaining)\n        (buffer as Buffer).writeFully(head, size)\n\n        return size\n    }\n\n    final override fun discard(n: Long): Long {\n        if (n <= 0) return 0L\n        return discardAsMuchAsPossible(n, 0)\n    }\n\n    internal fun readAvailableCharacters(destination: CharArray, off: Int, len: Int): Int {\n        if (endOfInput) return -1\n\n        val out = object : Appendable {\n            private var idx = off\n\n            override fun append(c: Char): Appendable {\n                destination[idx++] = c\n                return this\n            }\n\n            override fun append(csq: CharSequence?): Appendable {\n                if (csq is String) {\n                    csq.getCharsInternal(destination, idx)\n                    idx += csq.length\n                } else if (csq != null) {\n                    for (i in 0 until csq.length) {\n                        destination[idx++] = csq[i]\n                    }\n                }\n\n                return this\n            }\n\n            override fun append(csq: CharSequence?, start: Int, end: Int): Appendable {\n                throw UnsupportedOperationException()\n            }\n        }\n\n        return readText(out, 0, len)\n    }\n\n    /**\n     * Read at least [min] and at most [max] characters and append them to [out]\n     * @return number of characters appended\n     */\n    public fun readText(out: Appendable, min: Int = 0, max: Int = Int.MAX_VALUE): Int {\n        if (max.toLong() >= remaining) {\n            val s = readTextExactBytes(bytesCount = remaining.toInt() )\n            out.append(s)\n            return s.length\n        }\n        return readASCII(out, min, max)\n    }\n\n    /**\n     * Read exactly [exactCharacters] characters and append them to [out]\n     */\n    public fun readTextExact(out: Appendable, exactCharacters: Int) {\n        readText(out, exactCharacters, exactCharacters)\n    }\n\n    /**\n     * Read a string at last [min] and at most [max] characters length\n     */\n    public fun readText(min: Int = 0, max: Int = Int.MAX_VALUE): String {\n        if (min == 0 && (max == 0 || endOfInput)) return \"\"\n        val remaining = remaining\n        if (remaining > 0 && max.toLong() >= remaining) return readTextExactBytes(bytesCount = remaining.toInt() )\n\n        return buildString(min.coerceAtLeast(16).coerceAtMost(max)) {\n            readASCII(this, min, max)\n        }\n    }\n\n    /**\n     * Read a string exactly [exactCharacters] length\n     */\n    public fun readTextExact(exactCharacters: Int): String {\n        return readText(exactCharacters, exactCharacters)\n    }\n\n    private fun readASCII(out: Appendable, min: Int, max: Int): Int {\n        when {\n            max == 0 && min == 0 -> return 0\n            endOfInput -> if (min == 0) return 0 else atLeastMinCharactersRequire(min)\n            max < min -> minShouldBeLess(min, max)\n        }\n\n        var copied = 0\n        var utf8 = false\n\n        takeWhile { buffer ->\n            val rc = buffer.decodeASCII {\n                if (copied == max) false\n                else {\n                    out.append(it)\n                    copied++\n                    true\n                }\n            }\n\n            when {\n                rc -> true\n                copied == max -> false\n                else -> {\n                    utf8 = true\n                    false\n                }\n            }\n        }\n\n        if (utf8) {\n            return copied + readUtf8(out, min - copied, max - copied)\n        }\n        if (copied < min) prematureEndOfStreamChars(min, copied)\n        return copied\n    }\n\n    private fun atLeastMinCharactersRequire(min: Int): Nothing =\n        throw EOFException(\"at least $min characters required but no bytes available\")\n\n    private fun minShouldBeLess(min: Int, max: Int): Nothing =\n        throw IllegalArgumentException(\"min should be less or equal to max but min = $min, max = $max\")\n\n    private fun prematureEndOfStreamChars(min: Int, copied: Int): Nothing = throw MalformedUTF8InputException(\n        \"Premature end of stream: expected at least $min chars but had only $copied\"\n    )\n\n    private fun readUtf8(out: Appendable, min: Int, max: Int): Int {\n        var copied = 0\n\n        takeWhileSize { buffer ->\n            val size = buffer.decodeUTF8 {\n                if (copied == max) false\n                else {\n                    out.append(it)\n                    copied++\n                    true\n                }\n            }\n\n            when {\n                size == 0 -> 1\n                size > 0 -> size\n                else -> 0\n            }\n        }\n\n        if (copied < min) prematureEndOfStreamChars(min, copied)\n\n        return copied\n    }\n\n    private tailrec fun discardAsMuchAsPossible(n: Long, skipped: Long): Long {\n        if (n == 0L) return skipped\n        val current = prepareRead(1) ?: return skipped\n        val size = minOf(current.readRemaining.toLong(), n).toInt()\n        current.discardExact(size)\n        headPosition += size\n        afterRead(current)\n\n        return discardAsMuchAsPossible(n - size, skipped + size)\n    }\n\n    private tailrec fun discardAsMuchAsPossible(n: Int, skipped: Int): Int {\n        if (n == 0) return skipped\n        val current = prepareRead(1) ?: return skipped\n        val size = minOf(current.readRemaining, n)\n        current.discardExact(size)\n        headPosition += size\n        afterRead(current)\n\n        return discardAsMuchAsPossible(n - size, skipped + size)\n    }\n\n    private tailrec fun readAsMuchAsPossible(array: ByteArray, offset: Int, length: Int, copied: Int): Int {\n        if (length == 0) return copied\n        val current = prepareRead(1) ?: return copied\n        val size = minOf(length, current.readRemaining)\n\n        current.readFully(array, offset, size)\n        headPosition = current.readPosition\n\n        return if (size != length || current.readRemaining == 0) {\n            afterRead(current)\n            readAsMuchAsPossible(array, offset + size, length - size, copied + size)\n        } else {\n            copied + size\n        }\n    }\n\n    private fun notEnoughBytesAvailable(n: Int): Nothing {\n        throw EOFException(\"Not enough data in packet ($remaining) to read $n byte(s)\")\n    }\n\n    @Deprecated(\"Not supported anymore.\", level = DeprecationLevel.ERROR)\n    public fun updateHeadRemaining(remaining: Int) {\n        // the only external usages are from readDirect\n        // so after using head chunk directly we should fix positions instead\n        val newPosition = headEndExclusive - remaining\n\n        if (newPosition < 0) {\n            throw IllegalArgumentException(\"Unable to update position to negative. newRemaining is too big.\")\n        }\n\n        headPosition = newPosition\n    }\n\n    @DangerousInternalIoApi\n    public fun prepareReadHead(minSize: Int): ChunkBuffer? = prepareReadLoop(minSize, head)\n\n    @DangerousInternalIoApi\n    public fun ensureNextHead(current: ChunkBuffer): ChunkBuffer? = ensureNext(current)\n\n    @PublishedApi\n    internal fun ensureNext(current: ChunkBuffer): ChunkBuffer? = ensureNext(\n        current,\n        ChunkBuffer.Empty\n    )\n\n    @DangerousInternalIoApi\n    public fun fixGapAfterRead(current: ChunkBuffer) {\n        val next = current.next ?: return fixGapAfterReadFallback(current)\n\n        val remaining = current.readRemaining\n        val overrunSize = minOf(remaining, Buffer.ReservedSize - current.endGap)\n        if (next.startGap < overrunSize) {\n            return fixGapAfterReadFallback(current)\n        }\n\n        next.restoreStartGap(overrunSize)\n\n        if (remaining > overrunSize) {\n            current.releaseEndGap()\n\n            this.headEndExclusive = current.writePosition\n            this.tailRemaining += overrunSize\n        } else {\n            this._head = next\n            this.tailRemaining -= next.readRemaining - overrunSize\n            current.cleanNext()\n            current.release(pool)\n        }\n    }\n\n    private fun fixGapAfterReadFallback(current: ChunkBuffer) {\n        if (noMoreChunksAvailable && current.next == null) {\n            this.headPosition = current.readPosition\n            this.headEndExclusive = current.writePosition\n            this.tailRemaining = 0\n            return\n        }\n\n        val size = current.readRemaining\n        val overrun = minOf(size, Buffer.ReservedSize - current.endGap)\n\n        if (size > overrun) {\n            fixGapAfterReadFallbackUnreserved(current, size, overrun)\n        } else {\n            val new = pool.borrow()\n            new.reserveEndGap(Buffer.ReservedSize)\n            new.next = current.cleanNext()\n\n            new.writeBufferAppend(current, size)\n            this._head = new\n        }\n\n        current.release(pool)\n    }\n\n    private fun fixGapAfterReadFallbackUnreserved(current: ChunkBuffer, size: Int, overrun: Int) {\n        // if we have a chunk with no end reservation\n        // we can split it into two to fix it\n\n        val chunk1 = pool.borrow()\n        val chunk2 = pool.borrow()\n\n        chunk1.reserveEndGap(Buffer.ReservedSize)\n        chunk2.reserveEndGap(Buffer.ReservedSize)\n        chunk1.next = chunk2\n        chunk2.next = current.cleanNext()\n\n        chunk1.writeBufferAppend(current, size - overrun)\n        chunk2.writeBufferAppend(current, overrun)\n\n        this._head = chunk1\n        this.tailRemaining = chunk2.remainingAll()\n    }\n\n    private tailrec fun ensureNext(current: ChunkBuffer, empty: ChunkBuffer): ChunkBuffer? {\n        if (current === empty) {\n            return doFill()\n        }\n\n        val next = current.cleanNext()\n        current.release(pool)\n\n        return when {\n            next == null -> {\n                this._head = empty\n                this.tailRemaining = 0L\n                ensureNext(empty, empty)\n            }\n            next.canRead() -> {\n                _head = next\n                tailRemaining -= next.readRemaining\n                next\n            }\n            else -> ensureNext(next, empty)\n        }\n    }\n\n    /**\n     * Reads the next chunk suitable for reading or `null` if no more chunks available. It is also allowed\n     * to return a chain of chunks linked through [ChunkBuffer.next]. The last chunk should have `null` next reference.\n     * Could rethrow exceptions from the underlying source.\n     */\n    protected open fun fill(): ChunkBuffer? {\n        val buffer = pool.borrow()\n        try {\n            buffer.reserveEndGap(Buffer.ReservedSize)\n            val copied = fill(buffer.memory, buffer.writePosition, buffer.writeRemaining)\n\n            if (copied == 0) {\n                noMoreChunksAvailable = true\n\n                if (!buffer.canRead()) {\n                    buffer.release(pool)\n                    return null\n                }\n            }\n\n            buffer.commitWritten(copied)\n\n            return buffer\n        } catch (t: Throwable) {\n            buffer.release(pool)\n            throw t\n        }\n    }\n\n    protected final fun markNoMoreChunksAvailable() {\n        if (!noMoreChunksAvailable) {\n            noMoreChunksAvailable = true\n        }\n    }\n\n    /**\n     * see [prefetch] for similar logic\n     */\n    private final fun doFill(): ChunkBuffer? {\n        if (noMoreChunksAvailable) return null\n        val chunk = fill()\n        if (chunk == null) {\n            noMoreChunksAvailable = true\n            return null\n        }\n        appendView(chunk)\n        return chunk\n    }\n\n    private final fun appendView(chunk: ChunkBuffer) {\n        val tail = _head.findTail()\n        if (tail === ChunkBuffer.Empty) {\n            _head = chunk\n            require(tailRemaining == 0L) {\n                throw IllegalStateException(\"It should be no tail remaining bytes if current tail is EmptyBuffer\")\n            }\n            tailRemaining = chunk.next?.remainingAll() ?: 0L\n        } else {\n            tail.next = chunk\n            tailRemaining += chunk.remainingAll()\n        }\n    }\n\n    @PublishedApi\n    internal fun prepareRead(minSize: Int): ChunkBuffer? {\n        val head = head\n        if (headEndExclusive - headPosition >= minSize) return head\n        return prepareReadLoop(minSize, head)\n    }\n\n    @PublishedApi\n    internal final fun prepareRead(minSize: Int, head: ChunkBuffer): ChunkBuffer? {\n        if (headEndExclusive - headPosition >= minSize) return head\n        return prepareReadLoop(minSize, head)\n    }\n\n    private tailrec fun prepareReadLoop(minSize: Int, head: ChunkBuffer): ChunkBuffer? {\n        val headSize = headRemaining\n        if (headSize >= minSize) return head\n\n        val next = head.next ?: doFill() ?: return null\n\n        if (headSize == 0) {\n            if (head !== ChunkBuffer.Empty) {\n                releaseHead(head)\n            }\n\n            return prepareReadLoop(minSize, next)\n        } else {\n            val desiredExtraBytes = minSize - headSize\n            val copied = head.writeBufferAppend(next, desiredExtraBytes)\n            headEndExclusive = head.writePosition\n            tailRemaining -= copied\n            if (!next.canRead()) {\n                head.next = null\n                head.next = next.cleanNext()\n                next.release(pool)\n            } else {\n                next.reserveStartGap(copied)\n            }\n        }\n\n        if (head.readRemaining >= minSize) return head\n        if (minSize > Buffer.ReservedSize) minSizeIsTooBig(minSize)\n\n        return prepareReadLoop(minSize, head)\n    }\n\n    private fun minSizeIsTooBig(minSize: Int): Nothing {\n        throw IllegalStateException(\"minSize of $minSize is too big (should be less than ${Buffer.ReservedSize})\")\n    }\n\n    private fun afterRead(head: ChunkBuffer) {\n        if (head.readRemaining == 0) {\n            releaseHead(head)\n        }\n    }\n\n    internal final fun releaseHead(head: ChunkBuffer): ChunkBuffer {\n        val next = head.cleanNext() ?: ChunkBuffer.Empty\n        this._head = next\n        this.tailRemaining -= next.readRemaining\n        head.release(pool)\n\n        return next\n    }\n\n    public companion object\n}\n","@file:Suppress(\"NOTHING_TO_INLINE\")\n\npackage io.ktor.utils.io.bits\n\nimport io.ktor.utils.io.core.internal.*\nimport org.khronos.webgl.*\nimport kotlin.require\n\n/**\n * Represents a linear range of bytes.\n */\npublic actual class Memory @DangerousInternalIoApi constructor(public val view: DataView) {\n    /**\n     * Size of memory range in bytes.\n     */\n    public actual inline val size: Long get() = view.byteLength.toLong()\n\n    /**\n     * Size of memory range in bytes represented as signed 32bit integer\n     * @throws IllegalStateException when size doesn't fit into a signed 32bit integer\n     */\n    public actual inline val size32: Int get() = view.byteLength\n\n    /**\n     * Returns byte at [index] position.\n     */\n    public actual inline fun loadAt(index: Int): Byte {\n        return view.getInt8(index)\n    }\n\n    /**\n     * Returns byte at [index] position.\n     */\n    public actual inline fun loadAt(index: Long): Byte {\n        return view.getInt8(index.toIntOrFail(\"index\"))\n    }\n\n    /**\n     * Write [value] at the specified [index].\n     */\n    public actual inline fun storeAt(index: Int, value: Byte) {\n        view.setInt8(index, value)\n    }\n\n    /**\n     * Write [value] at the specified [index]\n     */\n    public actual inline fun storeAt(index: Long, value: Byte) {\n        view.setInt8(index.toIntOrFail(\"index\"), value)\n    }\n\n    /**\n     * Returns memory's subrange. On some platforms it could do range checks but it is not guaranteed to be safe.\n     * It also could lead to memory allocations on some platforms.\n     */\n    public actual fun slice(offset: Int, length: Int): Memory {\n        require(offset >= 0) { \"offset shouldn't be negative: $offset\" }\n        require(length >= 0) { \"length shouldn't be negative: $length\" }\n        if (offset + length > size) {\n            throw IndexOutOfBoundsException(\"offset + length > size: $offset + $length > $size\")\n        }\n\n        return Memory(\n            DataView(\n                view.buffer,\n                view.byteOffset + offset,\n                length\n            )\n        )\n    }\n\n    /**\n     * Returns memory's subrange. On some platforms it could do range checks but it is not guaranteed to be safe.\n     * It also could lead to memory allocations on some platforms.\n     */\n    public actual fun slice(offset: Long, length: Long): Memory {\n        return slice(offset.toIntOrFail(\"offset\"), length.toIntOrFail(\"length\"))\n    }\n\n    /**\n     * Copies bytes from this memory range from the specified [offset] and [length]\n     * to the [destination] at [destinationOffset].\n     * Copying bytes from a memory to itself is allowed.\n     */\n    public actual fun copyTo(\n        destination: Memory,\n        offset: Int,\n        length: Int,\n        destinationOffset: Int\n    ) {\n        val src = Int8Array(view.buffer, view.byteOffset + offset, length)\n        val dst = Int8Array(destination.view.buffer, destination.view.byteOffset + destinationOffset, length)\n\n        dst.set(src)\n    }\n\n    /**\n     * Copies bytes from this memory range from the specified [offset] and [length]\n     * to the [destination] at [destinationOffset].\n     * Copying bytes from a memory to itself is allowed.\n     */\n    public actual fun copyTo(\n        destination: Memory,\n        offset: Long,\n        length: Long,\n        destinationOffset: Long\n    ) {\n        copyTo(\n            destination,\n            offset.toIntOrFail(\"offset\"),\n            length.toIntOrFail(\"length\"),\n            destinationOffset.toIntOrFail(\"destinationOffset\")\n        )\n    }\n\n    public actual companion object {\n        /**\n         * Represents an empty memory region\n         */\n        public actual val Empty: Memory = Memory(DataView(ArrayBuffer(0)))\n    }\n}\n\n/**\n * Copies bytes from this memory range from the specified [offset] and [length]\n * to the [destination] at [destinationOffset].\n */\npublic actual fun Memory.copyTo(\n    destination: ByteArray,\n    offset: Int,\n    length: Int,\n    destinationOffset: Int\n) {\n    @Suppress(\"UnsafeCastFromDynamic\")\n    val to: Int8Array = destination.asDynamic()\n\n    val from = Int8Array(view.buffer, view.byteOffset + offset, length)\n\n    to.set(from, destinationOffset)\n}\n\n/**\n * Copies bytes from this memory range from the specified [offset] and [length]\n * to the [destination] at [destinationOffset].\n */\npublic actual fun Memory.copyTo(\n    destination: ByteArray,\n    offset: Long,\n    length: Int,\n    destinationOffset: Int\n) {\n    copyTo(destination, offset.toIntOrFail(\"offset\"), length, destinationOffset)\n}\n\n/**\n * Fill memory range starting at the specified [offset] with [value] repeated [count] times.\n */\npublic actual fun Memory.fill(offset: Int, count: Int, value: Byte) {\n    for (index in offset until offset + count) {\n        this[index] = value\n    }\n}\n\n/**\n * Fill memory range starting at the specified [offset] with [value] repeated [count] times.\n */\npublic actual fun Memory.fill(offset: Long, count: Long, value: Byte) {\n    fill(offset.toIntOrFail(\"offset\"), count.toIntOrFail(\"count\"), value)\n}\n\n/**\n * Copies bytes from this memory range from the specified [offset] and [length]\n * to the [destination] at [destinationOffset].\n */\npublic fun Memory.copyTo(destination: ArrayBuffer, offset: Int, length: Int, destinationOffset: Int) {\n    @Suppress(\"UnsafeCastFromDynamic\")\n    val to = Int8Array(destination, destinationOffset, length)\n    val from = Int8Array(view.buffer, view.byteOffset + offset, length)\n\n    to.set(from, 0)\n}\n\n/**\n * Copies bytes from this memory range from the specified [offset] and [length]\n * to the [destination] at [destinationOffset].\n */\npublic fun Memory.copyTo(destination: ArrayBufferView, offset: Int, length: Int, destinationOffset: Int) {\n    @Suppress(\"UnsafeCastFromDynamic\")\n    val to = Int8Array(destination.buffer, destinationOffset + destination.byteOffset, length)\n    val from = Int8Array(view.buffer, view.byteOffset + offset, length)\n\n    to.set(from, 0)\n}\n\n/**\n * Copies bytes from this memory range from the specified [offset] and [length]\n * to the [destination] at [destinationOffset].\n */\npublic fun ArrayBuffer.copyTo(destination: Memory, offset: Int, length: Int, destinationOffset: Int) {\n    val from = Int8Array(this, offset, length)\n    val to = Int8Array(destination.view.buffer, destination.view.byteOffset + destinationOffset, length)\n\n    to.set(from, 0)\n}\n\n/**\n * Copies bytes from this memory range from the specified [offset] and [length]\n * to the [destination] at [destinationOffset].\n */\npublic fun ArrayBufferView.copyTo(destination: Memory, offset: Int, length: Int, destinationOffset: Int) {\n    buffer.copyTo(destination, offset + byteOffset, length, destinationOffset)\n}\n\ninternal val Memory.Int8ArrayView: Int8Array get() = Int8Array(view.buffer, view.byteOffset, view.byteLength)\n","package io.ktor.utils.io.core\n\nimport kotlin.contracts.*\n\n@PublishedApi\ninternal inline fun AbstractInput.read(n: Int = 1, block: (Buffer) -> Unit) {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n\n    val buffer = prepareRead(n) ?: prematureEndOfStream(n)\n    val positionBefore = buffer.readPosition\n    try {\n        block(buffer)\n    } finally {\n        val positionAfter = buffer.readPosition\n        if (positionAfter < positionBefore) {\n            throw IllegalStateException(\"Buffer's position shouldn't be rewinded\")\n        }\n        if (positionAfter == buffer.writePosition) {\n            ensureNext(buffer)\n        } else {\n            headPosition = positionAfter\n        }\n    }\n}\n","package io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.Memory\nimport io.ktor.utils.io.bits.get\nimport io.ktor.utils.io.core.internal.*\nimport kotlin.jvm.JvmName\n\n/**\n * Usually shouldn't be implemented directly. Inherit [AbstractInput] instead.\n */\npublic expect interface Input : Closeable {\n    @Deprecated(\n        \"Not supported anymore. All operations are big endian by default. \" +\n            \"Use readXXXLittleEndian or readXXX then X.reverseByteOrder() instead.\",\n        level = DeprecationLevel.ERROR\n    )\n    public var byteOrder: ByteOrder\n\n    /**\n     * It is `true` when it is known that no more bytes will be available. When it is `false` then this means that\n     * it is not known yet or there are available bytes.\n     * Please note that `false` value doesn't guarantee that there are available bytes so `readByte()` may fail.\n     */\n    public val endOfInput: Boolean\n\n    /**\n     * Read the next upcoming byte\n     * @throws EOFException if no more bytes available.\n     */\n    public fun readByte(): Byte\n\n    /*\n     * Returns next byte (unsigned) or `-1` if no more bytes available\n     */\n    public fun tryPeek(): Int\n\n    /**\n     * Try to copy at least [min] but up to [max] bytes to the specified [destination] buffer from this input\n     * skipping [offset] bytes. If there are not enough bytes available to provide [min] bytes after skipping [offset]\n     * bytes then it will trigger the underlying source reading first and after that will\n     * simply copy available bytes even if EOF encountered so [min] is not a requirement but a desired number of bytes.\n     * It is safe to specify [max] greater than the destination free space.\n     * `min` shouldn't be bigger than the [destination] free space.\n     * This function could trigger the underlying source reading that may lead to blocking I/O.\n     * It is allowed to specify too big [offset] so in this case this function will always return `0` after prefetching\n     * all underlying bytes but note that it may lead to significant memory consumption.\n     * This function usually copy more bytes than [min] (unless `max = min`) but it is not guaranteed.\n     * When `0` is returned with `offset = 0` then it makes sense to check [endOfInput].\n     *\n     * @param destination to write bytes\n     * @param offset to skip input\n     * @param min bytes to be copied, shouldn't be greater than the buffer free space. Could be `0`.\n     * @param max bytes to be copied even if there are more bytes buffered, could be [Int.MAX_VALUE].\n     * @return number of bytes copied to the [destination] possibly `0`\n     */\n    public fun peekTo(\n        destination: Memory,\n        destinationOffset: Long,\n        offset: Long = 0,\n        min: Long = 1,\n        max: Long = Long.MAX_VALUE\n    ): Long\n\n    /**\n     * Discard at most [n] bytes\n     */\n    public fun discard(n: Long): Long\n\n    /**\n     * Close input including the underlying source. All pending bytes will be discarded.\n     * It is not recommended to invoke it with read operations in-progress concurrently.\n     */\n    override fun close()\n\n    /**\n     * Copy available bytes to the specified [buffer] but keep them available.\n     * The underlying implementation could trigger\n     * bytes population from the underlying source and block until any bytes available.\n     *\n     * Very similar to [readAvailable] but don't discard copied bytes.\n     *\n     * @return number of bytes were copied\n     */\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\", \"DEPRECATION\")\n    public fun peekTo(buffer: IoBuffer): Int {\n        return peekTo(buffer)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readShort(): Short {\n        return readShort()\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readInt(): Int {\n        return readInt()\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readLong(): Long {\n        return readLong()\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readFloat(): Float {\n        return readFloat()\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readDouble(): Double {\n        return readDouble()\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readFully(dst: ByteArray, offset: Int, length: Int) {\n        readFully(dst, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readFully(dst: ShortArray, offset: Int, length: Int) {\n        readFully(dst, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readFully(dst: IntArray, offset: Int, length: Int) {\n        readFully(dst, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readFully(dst: LongArray, offset: Int, length: Int) {\n        readFully(dst, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readFully(dst: FloatArray, offset: Int, length: Int) {\n        readFully(dst, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readFully(dst: DoubleArray, offset: Int, length: Int) {\n        readFully(dst, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\", \"DEPRECATION\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readFully(dst: IoBuffer, length: Int) {\n        readFully(dst, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readAvailable(dst: ByteArray, offset: Int, length: Int): Int {\n        return readAvailable(dst, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readAvailable(dst: ShortArray, offset: Int, length: Int): Int {\n        return readAvailable(dst, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readAvailable(dst: IntArray, offset: Int, length: Int): Int {\n        return readAvailable(dst, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readAvailable(dst: LongArray, offset: Int, length: Int): Int {\n        return readAvailable(dst, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readAvailable(dst: FloatArray, offset: Int, length: Int): Int {\n        return readAvailable(dst, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readAvailable(dst: DoubleArray, offset: Int, length: Int): Int {\n        return readAvailable(dst, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\", \"DEPRECATION\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readAvailable(dst: IoBuffer, length: Int): Int {\n        return readAvailable(dst, length)\n    }\n}\n\n/**\n * Discard all remaining bytes.\n * @return number of bytes were discarded\n */\npublic fun Input.discard(): Long {\n    return discard(Long.MAX_VALUE)\n}\n\n/**\n * Discard exactly [n] bytes or fail if not enough bytes in the input to be discarded.\n */\npublic fun Input.discardExact(n: Long) {\n    val discarded = discard(n)\n    if (discarded != n) {\n        throw IllegalStateException(\"Only $discarded bytes were discarded of $n requested\")\n    }\n}\n\n/**\n * Discard exactly [n] bytes or fail if not enough bytes in the input to be discarded.\n */\npublic fun Input.discardExact(n: Int) {\n    discardExact(n.toLong())\n}\n\n/**\n * Invoke [block] function for every chunk until end of input or [block] function return `false`\n * [block] function returns `true` to request more chunks or `false` to stop loop\n *\n * It is not guaranteed that every chunk will have fixed size but it will be never empty.\n * [block] function should never release provided buffer and should not write to it otherwise an undefined behaviour\n * could be observed\n */\n@DangerousInternalIoApi\npublic inline fun Input.takeWhile(block: (Buffer) -> Boolean) {\n    var release = true\n    var current = prepareReadFirstHead(1) ?: return\n\n    try {\n        do {\n            if (!block(current)) {\n                break\n            }\n            release = false\n            val next = prepareReadNextHead(current) ?: break\n            current = next\n            release = true\n        } while (true)\n    } finally {\n        if (release) {\n            completeReadHead(current)\n        }\n    }\n}\n\n/**\n * Invoke [block] function for every chunk until end of input or [block] function return zero\n * [block] function returns number of bytes required to read next primitive and shouldn't require too many bytes at once\n * otherwise it could fail with an exception.\n * It is not guaranteed that every chunk will have fixed size but it will be always at least requested bytes length.\n * [block] function should never release provided buffer and should not write to it otherwise an undefined behaviour\n * could be observed\n */\n@DangerousInternalIoApi\npublic inline fun Input.takeWhileSize(initialSize: Int = 1, block: (Buffer) -> Int) {\n    var release = true\n    var current = prepareReadFirstHead(initialSize) ?: return\n    var size = initialSize\n\n    try {\n        do {\n            val before = current.readRemaining\n            val after: Int\n\n            if (before >= size) {\n                try {\n                    size = block(current)\n                } finally {\n                    after = current.readRemaining\n                }\n            } else {\n                after = before\n            }\n\n            release = false\n\n            val next = when {\n                after == 0 -> prepareReadNextHead(current)\n                after < size || current.endGap < Buffer.ReservedSize -> {\n                    completeReadHead(current)\n                    prepareReadFirstHead(size)\n                }\n                else -> current\n            }\n\n            if (next == null) {\n                break\n            }\n\n            current = next\n            release = true\n        } while (size > 0)\n    } finally {\n        if (release) {\n            completeReadHead(current)\n        }\n    }\n}\n\n@ExperimentalIoApi\npublic fun Input.peekCharUtf8(): Char {\n    val rc = tryPeek()\n    if (rc and 0x80 == 0) return rc.toChar()\n    if (rc == -1) throw EOFException(\"Failed to peek a char: end of input\")\n\n    return peekCharUtf8Impl(rc)\n}\n\n/**\n * For every byte from this input invokes [block] function giving it as parameter.\n */\n@ExperimentalIoApi\npublic inline fun Input.forEach(block: (Byte) -> Unit) {\n    takeWhile { buffer ->\n        buffer.forEach(block)\n        true\n    }\n}\n\nprivate fun Input.peekCharUtf8Impl(first: Int): Char {\n    var rc = '?'\n    var found = false\n\n    takeWhileSize(byteCountUtf8(first)) {\n        it.decodeUTF8 { ch ->\n            found = true\n            rc = ch\n            false\n        }\n    }\n\n    if (!found) {\n        throw MalformedUTF8InputException(\"No UTF-8 character found\")\n    }\n\n    return rc\n}\n\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"UNUSED\", \"DEPRECATION\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\npublic fun Input.readAvailable(dst: IoBuffer, size: Int = dst.writeRemaining): Int = readAvailable(dst, size)\n\n@JvmName(\"readAvailable\")\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"UNUSED\", \"DEPRECATION\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\npublic fun Input.readAvailableOld(dst: ByteArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    return readAvailable(dst, offset, length)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"UNUSED\", \"DEPRECATION\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n@JvmName(\"readAvailable\")\npublic fun Input.readAvailableOld(dst: ShortArray, offset: Int = 0, length: Int = dst.size - offset): Int =\n    readAvailable(dst, offset, length)\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"UNUSED\", \"DEPRECATION\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n@JvmName(\"readAvailable\")\npublic fun Input.readAvailableOld(dst: IntArray, offset: Int = 0, length: Int = dst.size - offset): Int =\n    readAvailable(dst, offset, length)\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"UNUSED\", \"DEPRECATION\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n@JvmName(\"readAvailable\")\npublic fun Input.readAvailableOld(dst: LongArray, offset: Int = 0, length: Int = dst.size - offset): Int =\n    readAvailable(dst, offset, length)\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"UNUSED\", \"DEPRECATION\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n@JvmName(\"readAvailable\")\npublic fun Input.readAvailableOld(dst: FloatArray, offset: Int = 0, length: Int = dst.size - offset): Int =\n    readAvailable(dst, offset, length)\n\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"UNUSED\", \"DEPRECATION\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n@JvmName(\"readAvailable\")\npublic fun Input.readAvailableOld(dst: DoubleArray, offset: Int = 0, length: Int = dst.size - offset): Int =\n    readAvailable(dst, offset, length)\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"UNUSED\", \"DEPRECATION\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\npublic fun Input.readFully(dst: IoBuffer, size: Int = dst.writeRemaining): Unit = readFully(dst, size)\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"UNUSED\", \"DEPRECATION\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n@JvmName(\"readFully\")\npublic fun Input.readFullyOld(dst: ByteArray, offset: Int = 0, length: Int = dst.size - offset): Unit =\n    readFully(dst, offset, length)\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"UNUSED\", \"DEPRECATION\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n@JvmName(\"readFully\")\npublic fun Input.readFullyOld(dst: ShortArray, offset: Int = 0, length: Int = dst.size - offset): Unit =\n    readFully(dst, offset, length)\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"UNUSED\", \"DEPRECATION\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n@JvmName(\"readFully\")\npublic fun Input.readFullyOld(dst: IntArray, offset: Int = 0, length: Int = dst.size - offset): Unit =\n    readFully(dst, offset, length)\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"UNUSED\", \"DEPRECATION\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n@JvmName(\"readFully\")\npublic fun Input.readFullyOld(dst: LongArray, offset: Int = 0, length: Int = dst.size - offset): Unit =\n    readFully(dst, offset, length)\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"UNUSED\", \"DEPRECATION\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n@JvmName(\"readFully\")\npublic fun Input.readFullyOld(dst: FloatArray, offset: Int = 0, length: Int = dst.size - offset): Unit =\n    readFully(dst, offset, length)\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"UNUSED\", \"DEPRECATION\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n@JvmName(\"readFully\")\npublic fun Input.readFullyOld(dst: DoubleArray, offset: Int = 0, length: Int = dst.size - offset): Unit =\n    readFully(dst, offset, length)\n\n","package io.ktor.utils.io.core.internal\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.charsets.*\nimport io.ktor.utils.io.core.*\n\ninternal inline fun Buffer.decodeASCII(consumer: (Char) -> Boolean): Boolean {\n    read { memory, start, endExclusive ->\n        for (index in start until endExclusive) {\n            val codepoint = memory[index].toInt() and 0xff\n            if (codepoint and 0x80 == 0x80 || !consumer(codepoint.toChar())) {\n                discardExact(index - start)\n                return false\n            }\n        }\n\n        endExclusive - start\n    }\n\n    return true\n}\n\n@DangerousInternalIoApi\npublic suspend fun decodeUTF8LineLoopSuspend(\n    out: Appendable,\n    limit: Int,\n    nextChunk: suspend (Int) -> AbstractInput?\n): Boolean {\n    var decoded = 0\n    var size = 1\n    var cr = false\n    var end = false\n\n    while (!end && size != 0) {\n        val chunk = nextChunk(size) ?: break\n        chunk.takeWhileSize { buffer ->\n            var skip = 0\n            size = buffer.decodeUTF8 { ch ->\n                when (ch) {\n                    '\\r' -> {\n                        if (cr) {\n                            end = true\n                            return@decodeUTF8 false\n                        }\n                        cr = true\n                        true\n                    }\n                    '\\n' -> {\n                        end = true\n                        skip = 1\n                        false\n                    }\n                    else -> {\n                        if (cr) {\n                            end = true\n                            return@decodeUTF8 false\n                        }\n\n                        if (decoded == limit) {\n                            throw BufferLimitExceededException(\"Too many characters in line: limit $limit exceeded\")\n                        }\n                        decoded++\n                        out.append(ch)\n                        true\n                    }\n                }\n            }\n\n            if (skip > 0) {\n                buffer.discardExact(skip)\n            }\n\n            size = if (end) 0 else size.coerceAtLeast(1)\n\n            size\n        }\n    }\n\n    if (size > 1) prematureEndOfStreamUtf(size)\n    if (cr) {\n        end = true\n    }\n\n    return decoded > 0 || end\n}\n\nprivate fun prematureEndOfStreamUtf(size: Int): Nothing =\n    throw EOFException(\"Premature end of stream: expected $size bytes to decode UTF-8 char\")\n\n@DangerousInternalIoApi\ninternal fun byteCountUtf8(firstByte: Int): Int {\n    var byteCount = 0\n    var mask = 0x80\n    var value = firstByte\n\n    for (i in 1..6) {\n        if (value and mask != 0) {\n            value = value and mask.inv()\n            mask = mask shr 1\n            byteCount++\n        } else {\n            break\n        }\n    }\n\n    return byteCount\n}\n\n@Suppress(\"DEPRECATION\")\n@Deprecated(\"Binary compatibility\", level = DeprecationLevel.HIDDEN)\npublic inline fun IoBuffer.decodeUTF8(consumer: (Char) -> Boolean): Int {\n    return (this as Buffer).decodeUTF8(consumer)\n}\n\n/**\n * Decodes all the bytes to utf8 applying every character on [consumer] until or consumer return `false`.\n * If a consumer returned false then a character will be pushed back (including all surrogates will be pushed back as well)\n * and [decodeUTF8] returns -1\n * @return number of bytes required to decode incomplete utf8 character or 0 if all bytes were processed\n * or -1 if consumer rejected loop\n */\n@DangerousInternalIoApi\npublic inline fun Buffer.decodeUTF8(consumer: (Char) -> Boolean): Int {\n    var byteCount = 0\n    var value = 0\n    var lastByteCount = 0\n\n    read { memory, start, endExclusive ->\n        for (index in start until endExclusive) {\n            val v = memory[index].toInt() and 0xff\n            when {\n                v and 0x80 == 0 -> {\n                    if (byteCount != 0) malformedByteCount(byteCount)\n                    if (!consumer(v.toChar())) {\n                        discardExact(index - start)\n                        return -1\n                    }\n                }\n                byteCount == 0 -> {\n                    // first unicode byte\n\n                    var mask = 0x80\n                    value = v\n\n                    for (i in 1..6) { // TODO do we support 6 bytes unicode?\n                        if (value and mask != 0) {\n                            value = value and mask.inv()\n                            mask = mask shr 1\n                            byteCount++\n                        } else {\n                            break\n                        }\n                    }\n\n                    lastByteCount = byteCount\n                    byteCount--\n\n                    if (lastByteCount > endExclusive - index) {\n                        discardExact(index - start)\n                        return lastByteCount\n                    }\n                }\n                else -> {\n                    // trailing unicode byte\n                    value = (value shl 6) or (v and 0x7f)\n                    byteCount--\n\n                    if (byteCount == 0) {\n                        if (isBmpCodePoint(value)) {\n                            if (!consumer(value.toChar())) {\n                                discardExact(index - start - lastByteCount + 1)\n                                return -1\n                            }\n                        } else if (!isValidCodePoint(value)) {\n                            malformedCodePoint(value)\n                        } else {\n                            if (!consumer(highSurrogate(value).toChar()) ||\n                                !consumer(lowSurrogate(value).toChar())\n                            ) {\n                                discardExact(index - start - lastByteCount + 1)\n                                return -1\n                            }\n                        }\n\n                        value = 0\n                    }\n                }\n            }\n        }\n\n        endExclusive - start\n    }\n\n    return 0\n}\n\n@Suppress(\"RedundantModalityModifier\")\ninternal class CharArraySequence(\n    private val array: CharArray,\n    private val offset: Int,\n    final override val length: Int\n) : CharSequence {\n    final override fun get(index: Int): Char {\n        if (index >= length) {\n            indexOutOfBounds(index)\n        }\n        return array[index + offset]\n    }\n\n    final override fun subSequence(startIndex: Int, endIndex: Int): CharSequence {\n        require(startIndex >= 0) { \"startIndex shouldn't be negative: $startIndex\" }\n        require(startIndex <= length) { \"startIndex is too large: $startIndex > $length\" }\n        require(startIndex + endIndex <= length) { \"endIndex is too large: $endIndex > $length\" }\n        require(endIndex >= startIndex) { \"endIndex should be greater or equal to startIndex: $startIndex > $endIndex\" }\n\n        return CharArraySequence(array, offset + startIndex, endIndex - startIndex)\n    }\n\n    private fun indexOutOfBounds(index: Int): Nothing {\n        throw IndexOutOfBoundsException(\"String index out of bounds: $index > $length\")\n    }\n}\n\n@Suppress(\"NOTHING_TO_INLINE\", \"EXPERIMENTAL_FEATURE_WARNING\")\ninternal inline class EncodeResult(val value: Int) {\n    constructor(characters: UShort, bytes: UShort) : this(characters.toInt() shl 16 or bytes.toInt())\n\n    inline val characters: UShort get() = value.highShort.toUShort()\n    inline val bytes: UShort get() = value.lowShort.toUShort()\n\n    inline operator fun component1(): UShort = characters\n    inline operator fun component2(): UShort = bytes\n}\n\ninternal fun Memory.encodeUTF8(text: CharSequence, from: Int, to: Int, dstOffset: Int, dstLimit: Int): EncodeResult {\n    // encode single-byte characters\n    val lastCharIndex = minOf(to, from + UShort.MAX_VALUE.toInt())\n    val resultLimit = dstLimit.coerceAtMost(UShort.MAX_VALUE.toInt())\n    var resultPosition = dstOffset\n    var index = from\n\n    do {\n        if (resultPosition >= resultLimit || index >= lastCharIndex) {\n            return EncodeResult((index - from).toUShort(), (resultPosition - dstOffset).toUShort())\n        }\n\n        val character = text[index++].toInt() and 0xffff\n        if (character and 0xff80 == 0) {\n            storeAt(resultPosition++, character.toByte())\n        } else {\n            break\n        }\n    } while (true)\n\n    index--\n    return encodeUTF8Stage1(text, index, lastCharIndex, from, resultPosition, resultLimit, dstOffset)\n}\n\n/**\n * Encode UTF-8 multibytes characters when we for sure have enough free space\n */\nprivate fun Memory.encodeUTF8Stage1(\n    text: CharSequence,\n    index1: Int,\n    lastCharIndex: Int,\n    from: Int,\n    resultPosition1: Int,\n    resultLimit: Int,\n    dstOffset: Int\n): EncodeResult {\n    var index = index1\n    var resultPosition: Int = resultPosition1\n    val stage1Limit = resultLimit - 3\n\n    do {\n        val freeSpace = stage1Limit - resultPosition\n        if (freeSpace <= 0 || index >= lastCharIndex) {\n            break\n        }\n\n        val character = text[index++]\n        val codepoint = when {\n            character.isHighSurrogate() -> {\n                if (index == lastCharIndex || !text[index].isLowSurrogate()) {\n                    63\n                } else {\n                    codePoint(character, text[index++])\n                }\n            }\n            else -> character.toInt()\n        }\n        val size = putUtf8Char(resultPosition, codepoint)\n\n        resultPosition += size\n    } while (true)\n\n    if (resultPosition == stage1Limit) {\n        return encodeUTF8Stage2(text, index, lastCharIndex, from, resultPosition, resultLimit, dstOffset)\n    }\n\n    return EncodeResult((index - from).toUShort(), (resultPosition - dstOffset).toUShort())\n}\n\nprivate fun Memory.encodeUTF8Stage2(\n    text: CharSequence,\n    index1: Int,\n    lastCharIndex: Int,\n    from: Int,\n    resultPosition1: Int,\n    resultLimit: Int,\n    dstOffset: Int\n): EncodeResult {\n    var index = index1\n    var resultPosition: Int = resultPosition1\n\n    do {\n        val freeSpace = resultLimit - resultPosition\n        if (freeSpace <= 0 || index >= lastCharIndex) {\n            break\n        }\n\n        val character = text[index++]\n        val codepoint = when {\n            !character.isHighSurrogate() -> character.toInt()\n            else -> {\n                if (index == lastCharIndex || !text[index].isLowSurrogate()) {\n                    63\n                } else {\n                    codePoint(character, text[index++])\n                }\n            }\n        }\n        if (charactersSize(codepoint) > freeSpace) {\n            index--\n            break\n        }\n        val size = putUtf8Char(resultPosition, codepoint)\n        resultPosition += size\n    } while (true)\n\n    return EncodeResult((index - from).toUShort(), (resultPosition - dstOffset).toUShort())\n}\n\n@Suppress(\"NOTHING_TO_INLINE\")\nprivate inline fun charactersSize(v: Int) = when {\n    v in 1..0x7f -> 1\n    v in 0x80..0x7ff -> 2\n    v in 0x800..0xffff -> 3\n    v in 0x10000..0x10ffff -> 4\n    else -> malformedCodePoint(v)\n}\n\n// TODO optimize it, now we are simply do naive encoding here\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal inline fun Memory.putUtf8Char(offset: Int, v: Int): Int = when {\n    v in 0..0x7f -> {\n        storeAt(offset, v.toByte())\n        1\n    }\n    v in 0x80..0x7ff -> {\n        this[offset] = (0xc0 or ((v shr 6) and 0x1f)).toByte()\n        this[offset + 1] = (0x80 or (v and 0x3f)).toByte()\n        2\n    }\n    v in 0x800..0xffff -> {\n        this[offset] = (0xe0 or ((v shr 12) and 0x0f)).toByte()\n        this[offset + 1] = (0x80 or ((v shr 6) and 0x3f)).toByte()\n        this[offset + 2] = (0x80 or (v and 0x3f)).toByte()\n        3\n    }\n    v in 0x10000..0x10ffff -> {\n        this[offset] = (0xf0 or ((v shr 18) and 0x07)).toByte() // 3 bits\n        this[offset + 1] = (0x80 or ((v shr 12) and 0x3f)).toByte() // 6 bits\n        this[offset + 2] = (0x80 or ((v shr 6) and 0x3f)).toByte() // 6 bits\n        this[offset + 3] = (0x80 or (v and 0x3f)).toByte() // 6 bits\n        4\n    }\n    else -> malformedCodePoint(v)\n}\n\n@PublishedApi\ninternal fun malformedByteCount(byteCount: Int): Nothing =\n    throw MalformedUTF8InputException(\"Expected $byteCount more character bytes\")\n\n@PublishedApi\ninternal fun malformedCodePoint(value: Int): Nothing =\n    throw IllegalArgumentException(\"Malformed code-point $value found\")\n\nprivate const val MaxCodePoint = 0x10ffff\nprivate const val MinLowSurrogate = 0xdc00\nprivate const val MinHighSurrogate = 0xd800\nprivate const val MinSupplementary = 0x10000\nprivate const val HighSurrogateMagic = MinHighSurrogate - (MinSupplementary ushr 10)\n\n@PublishedApi\ninternal fun isBmpCodePoint(cp: Int): Boolean = cp ushr 16 == 0\n\n@PublishedApi\ninternal fun isValidCodePoint(codePoint: Int): Boolean = codePoint <= MaxCodePoint\n\n@PublishedApi\ninternal fun lowSurrogate(cp: Int): Int = (cp and 0x3ff) + MinLowSurrogate\n\n@PublishedApi\ninternal fun highSurrogate(cp: Int): Int = (cp ushr 10) + HighSurrogateMagic\n\ninternal fun codePoint(high: Char, low: Char): Int {\n//    check(high.isHighSurrogate())\n//    check(low.isLowSurrogate())\n\n    val highValue = high.toInt() - HighSurrogateMagic\n    val lowValue = low.toInt() - MinLowSurrogate\n\n    return highValue shl 10 or lowValue\n}\n\npublic class MalformedUTF8InputException(message: String) : Exception(message)\n","@file:Suppress(\"LocalVariableName\", \"RedundantModalityModifier\")\n\npackage io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.charsets.*\nimport io.ktor.utils.io.concurrent.*\nimport io.ktor.utils.io.core.internal.*\nimport io.ktor.utils.io.pool.*\n\n/**\n * The default [Output] implementation.\n * @see flush\n * @see closeDestination\n */\n@ExperimentalIoApi\npublic abstract class AbstractOutput\ninternal constructor(\n    private val headerSizeHint: Int,\n    protected val pool: ObjectPool<ChunkBuffer>\n) : Appendable, Output {\n    public constructor(pool: ObjectPool<ChunkBuffer>) : this(0, pool)\n\n    public constructor() : this(ChunkBuffer.Pool)\n\n    /**\n     * An implementation should write [source] to the destination exactly [length] bytes.\n     * It should never capture the [source] instance\n     * longer than this method execution since it may be disposed after return.\n     */\n    protected abstract fun flush(source: Memory, offset: Int, length: Int)\n\n    /**\n     * An implementation should only close the destination.\n     */\n    protected abstract fun closeDestination()\n\n    private val state = AbstractOutputSharedState()\n\n    private var _head: ChunkBuffer?\n        get() = state.head\n        set(value) {\n            state.head = value\n        }\n\n    private var _tail: ChunkBuffer?\n        get() = state.tail\n        set(value) {\n            state.tail = value\n        }\n\n    internal val head: ChunkBuffer\n        get() = _head ?: ChunkBuffer.Empty\n\n    @PublishedApi\n    @Deprecated(\"Will be removed in future releases.\", level = DeprecationLevel.HIDDEN)\n    internal val tail: ChunkBuffer\n        get() {\n            return prepareWriteHead(1)\n        }\n\n    @Deprecated(\"Will be removed. Override flush(buffer) properly.\", level = DeprecationLevel.ERROR)\n    protected var currentTail: ChunkBuffer\n        get() = prepareWriteHead(1)\n        set(newValue) {\n            appendChain(newValue)\n        }\n\n    internal var tailMemory: Memory\n        get() = state.tailMemory\n        set(value) {\n            state.tailMemory = value\n        }\n\n    internal var tailPosition\n        get() = state.tailPosition\n        set(value) {\n            state.tailPosition = value\n        }\n\n    internal var tailEndExclusive\n        get() = state.tailEndExclusive\n        private set(value) {\n            state.tailEndExclusive = value\n        }\n\n    private var tailInitialPosition\n        get() = state.tailInitialPosition\n        set(value) {\n            state.tailInitialPosition = value\n        }\n    /**\n     * Number of bytes buffered in the chain except the tail chunk\n     */\n    private var chainedSize: Int\n        get() = state.chainedSize\n        set(value) {\n            state.chainedSize = value\n        }\n\n    internal inline val tailRemaining: Int get() = tailEndExclusive - tailPosition\n\n    /**\n     * Number of bytes currently buffered (pending).\n     */\n    protected final var _size: Int\n        get() = chainedSize + (tailPosition - tailInitialPosition)\n        @Deprecated(\"There is no need to update/reset this value anymore.\")\n        set(_) {\n        }\n\n    /**\n     * Byte order (Endianness) to be used by future write functions calls on this builder instance. Doesn't affect any\n     * previously written values.\n     * @default [ByteOrder.BIG_ENDIAN]\n     */\n    @Deprecated(\n        \"This is no longer supported. All operations are big endian by default. Use readXXXLittleEndian \" +\n            \"to read primitives in little endian\",\n        level = DeprecationLevel.ERROR\n    )\n    final override var byteOrder: ByteOrder = ByteOrder.BIG_ENDIAN\n        set(value) {\n            field = value\n            if (value != ByteOrder.BIG_ENDIAN) {\n                throw IllegalArgumentException(\n                    \"Only BIG_ENDIAN is supported. Use corresponding functions to read/write\" +\n                        \"in the little endian\"\n                )\n            }\n        }\n\n    final override fun flush() {\n        flushChain()\n    }\n\n    private fun flushChain() {\n        val oldTail = stealAll() ?: return\n\n        try {\n            oldTail.forEachChunk { chunk ->\n                flush(chunk.memory, chunk.readPosition, chunk.readRemaining)\n            }\n        } finally {\n            oldTail.releaseAll(pool)\n        }\n    }\n\n    /**\n     * Detach all chunks and cleanup all internal state so builder could be reusable again\n     * @return a chain of buffer views or `null` of it is empty\n     */\n    internal fun stealAll(): ChunkBuffer? {\n        val head = this._head ?: return null\n\n        _tail?.commitWrittenUntilIndex(tailPosition)\n\n        this._head = null\n        this._tail = null\n        tailPosition = 0\n        tailEndExclusive = 0\n        tailInitialPosition = 0\n        chainedSize = 0\n        tailMemory = Memory.Empty\n\n        return head\n    }\n\n    internal fun afterBytesStolen() {\n        val head = head\n        if (head !== ChunkBuffer.Empty) {\n            check(head.next == null)\n            head.resetForWrite()\n            head.reserveStartGap(headerSizeHint)\n            head.reserveEndGap(Buffer.ReservedSize)\n            tailPosition = head.writePosition\n            tailInitialPosition = tailPosition\n            tailEndExclusive = head.limit\n        }\n    }\n\n    internal final fun appendSingleChunk(buffer: ChunkBuffer) {\n        check(buffer.next == null) { \"It should be a single buffer chunk.\" }\n        appendChainImpl(buffer, buffer, 0)\n    }\n\n    internal final fun appendChain(head: ChunkBuffer) {\n        val tail = head.findTail()\n        val chainedSizeDelta = (head.remainingAll() - tail.readRemaining).toIntOrFail(\"total size increase\")\n        appendChainImpl(head, tail, chainedSizeDelta)\n    }\n\n    private fun appendNewChunk(): ChunkBuffer {\n        val new = pool.borrow()\n        new.reserveEndGap(Buffer.ReservedSize)\n\n        appendSingleChunk(new)\n\n        return new\n    }\n\n    private final fun appendChainImpl(head: ChunkBuffer, newTail: ChunkBuffer, chainedSizeDelta: Int) {\n        val _tail = _tail\n        if (_tail == null) {\n            _head = head\n            chainedSize = 0\n        } else {\n            _tail.next = head\n            val tailPosition = tailPosition\n            _tail.commitWrittenUntilIndex(tailPosition)\n            chainedSize += tailPosition - tailInitialPosition\n        }\n\n        this._tail = newTail\n        chainedSize += chainedSizeDelta\n        tailMemory = newTail.memory\n        tailPosition = newTail.writePosition\n        tailInitialPosition = newTail.readPosition\n        tailEndExclusive = newTail.limit\n    }\n\n    final override fun writeByte(v: Byte) {\n        val index = tailPosition\n        if (index < tailEndExclusive) {\n            tailPosition = index + 1\n            tailMemory[index] = v\n            return\n        }\n\n        return writeByteFallback(v)\n    }\n\n    private fun writeByteFallback(v: Byte) {\n        appendNewChunk().writeByte(v)\n        tailPosition++\n    }\n\n    /**\n     * Should flush and close the destination\n     */\n    final override fun close() {\n        try {\n            flush()\n        } finally {\n            closeDestination() // TODO check what should be done here\n        }\n    }\n\n    /**\n     * Append single UTF-8 character\n     */\n    override fun append(c: Char): AbstractOutput {\n        val tailPosition = tailPosition\n        if (tailEndExclusive - tailPosition >= 3) {\n            val size = tailMemory.putUtf8Char(tailPosition, c.toInt())\n            this.tailPosition = tailPosition + size\n            return this\n        }\n\n        appendCharFallback(c)\n        return this\n    }\n\n    private fun appendCharFallback(c: Char) {\n        write(3) { buffer ->\n            val size = buffer.memory.putUtf8Char(buffer.writePosition, c.toInt())\n            buffer.commitWritten(size)\n            size\n        }\n    }\n\n    override fun append(csq: CharSequence?): AbstractOutput {\n        if (csq == null) {\n            append(\"null\", 0, 4)\n        } else {\n            append(csq, 0, csq.length)\n        }\n        return this\n    }\n\n    override fun append(csq: CharSequence?, start: Int, end: Int): AbstractOutput {\n        if (csq == null) {\n            return append(\"null\", start, end)\n        }\n\n        writeText(csq, start, end, Charsets.UTF_8)\n\n        return this\n    }\n\n    /**\n     * Writes another packet to the end. Please note that the instance [p] gets consumed so you don't need to release it\n     */\n    public fun writePacket(p: ByteReadPacket) {\n        val foreignStolen = p.stealAll()\n        if (foreignStolen == null) {\n            p.release()\n            return\n        }\n\n        val _tail = _tail\n        if (_tail == null) {\n            appendChain(foreignStolen)\n            return\n        }\n\n        writePacketMerging(_tail, foreignStolen, p.pool)\n    }\n\n    /**\n     * Write chunk buffer to current [Output]. Assuming that chunk buffer is from current pool.\n     */\n    internal fun writeChunkBuffer(chunkBuffer: ChunkBuffer) {\n        val _tail = _tail\n        if (_tail == null) {\n            appendChain(chunkBuffer)\n            return\n        }\n\n        writePacketMerging(_tail, chunkBuffer, pool)\n    }\n\n    private fun writePacketMerging(tail: ChunkBuffer, foreignStolen: ChunkBuffer, pool: ObjectPool<ChunkBuffer>) {\n        tail.commitWrittenUntilIndex(tailPosition)\n\n        val lastSize = tail.readRemaining\n        val nextSize = foreignStolen.readRemaining\n\n        // at first we evaluate if it is reasonable to merge chunks\n        val maxCopySize = PACKET_MAX_COPY_SIZE\n        val appendSize = if (nextSize < maxCopySize && nextSize <= (tail.endGap + tail.writeRemaining)) {\n            nextSize\n        } else -1\n\n        val prependSize =\n            if (lastSize < maxCopySize && lastSize <= foreignStolen.startGap && foreignStolen.isExclusivelyOwned()) {\n                lastSize\n            } else -1\n\n        if (appendSize == -1 && prependSize == -1) {\n            // simply enqueue if there is no reason to merge\n            appendChain(foreignStolen)\n        } else if (prependSize == -1 || appendSize <= prependSize) {\n            // do append\n            tail.writeBufferAppend(foreignStolen, tail.writeRemaining + tail.endGap)\n            afterHeadWrite()\n            foreignStolen.cleanNext()?.let { next ->\n                appendChain(next)\n            }\n\n            foreignStolen.release(pool)\n        } else if (appendSize == -1 || prependSize < appendSize) {\n            writePacketSlowPrepend(foreignStolen, tail)\n        } else {\n            throw IllegalStateException(\"prep = $prependSize, app = $appendSize\")\n        }\n    }\n\n    /**\n     * Do prepend current [tail] to the beginning of [foreignStolen].\n     */\n    private fun writePacketSlowPrepend(foreignStolen: ChunkBuffer, tail: ChunkBuffer) {\n        foreignStolen.writeBufferPrepend(tail)\n\n        val _head = _head ?: error(\"head should't be null since it is already handled in the fast-path\")\n        if (_head === tail) {\n            this._head = foreignStolen\n        } else {\n            // we need to fix next reference of the previous chunk before the tail\n            // we have to traverse from the beginning to find it\n            var pre = _head\n            while (true) {\n                val next = pre.next!!\n                if (next === tail) break\n                pre = next\n            }\n\n            pre.next = foreignStolen\n        }\n\n        tail.release(pool)\n\n        this._tail = foreignStolen.findTail()\n    }\n\n    /**\n     * Write exact [n] bytes from packet to the builder\n     */\n    public fun writePacket(p: ByteReadPacket, n: Int) {\n        var remaining = n\n\n        while (remaining > 0) {\n            val headRemaining = p.headRemaining\n            if (headRemaining <= remaining) {\n                remaining -= headRemaining\n                appendSingleChunk(p.steal() ?: throw EOFException(\"Unexpected end of packet\"))\n            } else {\n                p.read { view ->\n                    writeFully(view, remaining)\n                }\n                break\n            }\n        }\n    }\n\n    /**\n     * Write exact [n] bytes from packet to the builder\n     */\n    public fun writePacket(p: ByteReadPacket, n: Long) {\n        var remaining = n\n\n        while (remaining > 0L) {\n            val headRemaining = p.headRemaining.toLong()\n            if (headRemaining <= remaining) {\n                remaining -= headRemaining\n                appendSingleChunk(p.steal() ?: throw EOFException(\"Unexpected end of packet\"))\n            } else {\n                p.read { view ->\n                    writeFully(view, remaining.toInt())\n                }\n                break\n            }\n        }\n    }\n\n    override fun append(csq: CharArray, start: Int, end: Int): Appendable {\n        writeText(csq, start, end, Charsets.UTF_8)\n        return this\n    }\n\n    private inline fun appendCharsTemplate(\n        start: Int,\n        end: Int,\n        block: Buffer.(index: Int) -> Int\n    ): Int {\n        var idx = start\n        if (idx >= end) return idx\n        idx = prepareWriteHead(1).block(idx)\n        afterHeadWrite()\n\n        while (idx < end) {\n            idx = appendNewChunk().block(idx)\n            afterHeadWrite()\n        }\n\n        return idx\n    }\n\n    @Deprecated(\"Use writeText instead\", ReplaceWith(\"writeText(s)\"))\n    public fun writeStringUtf8(s: String) {\n        writeText(s)\n    }\n\n    @Deprecated(\"Use writeText instead\", ReplaceWith(\"this.writeText(cs)\"))\n    public fun writeStringUtf8(cs: CharSequence) {\n        writeText(cs)\n    }\n\n    @Suppress(\"NOTHING_TO_INLINE\")\n    private inline fun Buffer.putUtf8Char(v: Int) = when {\n        v in 1..0x7f -> {\n            writeByte(v.toByte())\n            1\n        }\n        v > 0x7ff -> {\n            writeExact(3, \"3 bytes character\") { memory, offset ->\n                memory[offset] = (0xe0 or ((v shr 12) and 0x0f)).toByte()\n                memory[offset + 1] = (0x80 or ((v shr 6) and 0x3f)).toByte()\n                memory[offset + 2] = (0x80 or (v and 0x3f)).toByte()\n            }\n            3\n        }\n        else -> {\n            writeExact(2, \"2 bytes character\") { memory, offset ->\n                memory[offset] = (0xc0 or ((v shr 6) and 0x1f)).toByte()\n                memory[offset + 1] = (0x80 or (v and 0x3f)).toByte()\n            }\n            2\n        }\n    }\n\n    /**\n     * Release any resources that the builder holds. Builder shouldn't be used after release\n     */\n    public final fun release() {\n        close()\n    }\n\n    @DangerousInternalIoApi\n    public fun prepareWriteHead(n: Int): ChunkBuffer {\n        if (tailRemaining >= n) {\n            _tail?.let {\n                it.commitWrittenUntilIndex(tailPosition)\n                return it\n            }\n        }\n        return appendNewChunk()\n    }\n\n    @DangerousInternalIoApi\n    public fun afterHeadWrite() {\n        _tail?.let { tailPosition = it.writePosition }\n    }\n\n    @PublishedApi\n    internal inline fun write(size: Int, block: (Buffer) -> Int): Int {\n        val buffer = prepareWriteHead(size)\n        try {\n            val result = block(buffer)\n            check(result >= 0) { \"The returned value shouldn't be negative\" }\n\n            return result\n        } finally {\n            afterHeadWrite()\n        }\n    }\n\n    @PublishedApi\n    @Deprecated(\"There is no need to do that anymore.\", level = DeprecationLevel.HIDDEN)\n    internal fun addSize(n: Int) {\n        check(n >= 0) { \"It should be non-negative size increment: $n\" }\n        check(n <= tailRemaining) { \"Unable to mark more bytes than available: $n > $tailRemaining\" }\n\n        // For binary compatibility we need to update pointers\n        tailPosition += n\n    }\n\n    @Suppress(\"DEPRECATION\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    internal open fun last(buffer: IoBuffer) {\n        appendSingleChunk(buffer as ChunkBuffer)\n    }\n\n    @Suppress(\"DEPRECATION\")\n    @Deprecated(\"Use appendNewChunk instead\",\n        replaceWith = ReplaceWith(\"appendNewChunk()\"),\n        level = DeprecationLevel.HIDDEN)\n    public fun appendNewBuffer(): IoBuffer = appendNewChunk() as IoBuffer\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public open fun reset() {\n    }\n}\n","@file:Suppress(\"NOTHING_TO_INLINE\")\n\npackage io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\nimport kotlin.contracts.*\nimport io.ktor.utils.io.core.internal.require\n\n/**\n * For every byte from this buffer invokes [block] function giving it as parameter.\n */\n@ExperimentalIoApi\npublic inline fun Buffer.forEach(block: (Byte) -> Unit) {\n    read { memory, start, endExclusive ->\n        for (index in start until endExclusive) {\n            block(memory[index])\n        }\n        endExclusive - start\n    }\n}\n\n/**\n * Read an unsigned byte or fail if no bytes available for reading.\n */\npublic fun Buffer.readUByte(): UByte = readByte().toUByte()\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Input instead.\")\npublic inline fun IoBuffer.readUByte(): UByte = (this as Buffer).readUByte()\n\n/**\n * Write an unsigned byte or fail if not enough space available for writing.\n */\npublic fun Buffer.writeUByte(value: UByte) {\n    writeByte(value.toByte())\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Output instead.\")\npublic fun IoBuffer.writeUByte(value: UByte) {\n    (this as Buffer).writeUByte(value)\n}\n\n/**\n * Read a short integer or fail if no bytes available for reading.\n * The numeric value is decoded in the network order (Big Endian).\n */\npublic fun Buffer.readShort(): Short = readExact(2, \"short integer\") { memory, offset ->\n    memory.loadShortAt(offset)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Input instead.\")\npublic inline fun IoBuffer.readShort(): Short = (this as Buffer).readShort()\n\n/**\n * Read an unsigned short integer or fail if not enough bytes available for reading.\n * The numeric value is decoded in the network order (Big Endian).\n */\npublic fun Buffer.readUShort(): UShort = readExact(2, \"short unsigned integer\") { memory, offset ->\n    memory.loadUShortAt(offset)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Input instead.\")\npublic inline fun IoBuffer.readUShort(): UShort = (this as Buffer).readUShort()\n\n\n/**\n * Read an integer or fail if not enough bytes available for reading.\n * The numeric value is decoded in the network order (Big Endian).\n */\npublic fun Buffer.readInt(): Int = readExact(4, \"regular integer\") { memory, offset ->\n    memory.loadIntAt(offset)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Input instead.\")\npublic inline fun IoBuffer.readInt(): Int = (this as Buffer).readInt()\n\n\n/**\n * Read an unsigned integer or fail if not enough bytes available for reading.\n * The numeric value is decoded in the network order (Big Endian).\n */\npublic fun Buffer.readUInt(): UInt = readExact(4, \"regular unsigned integer\") { memory, offset ->\n    memory.loadUIntAt(offset)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Input instead.\")\npublic inline fun IoBuffer.readUInt(): UInt = (this as Buffer).readUInt()\n\n\n/**\n * Read a long integer or fail if not enough bytes available for reading.\n * The numeric value is decoded in the network order (Big Endian).\n */\npublic fun Buffer.readLong(): Long = readExact(8, \"long integer\") { memory, offset ->\n    memory.loadLongAt(offset)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Input instead.\")\npublic inline fun IoBuffer.readLong(): Long = (this as Buffer).readLong()\n\n/**\n * Read an unsigned long integer or fail if not enough bytes available for reading.\n * The numeric value is decoded in the network order (Big Endian).\n */\npublic fun Buffer.readULong(): ULong = readExact(8, \"long unsigned integer\") { memory, offset ->\n    memory.loadULongAt(offset)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Input instead.\")\npublic inline fun IoBuffer.readULong(): ULong = (this as Buffer).readULong()\n\n\n/**\n * Read a floating point number or fail if not enough bytes available for reading.\n * The numeric value is decoded in the network order (Big Endian).\n */\npublic fun Buffer.readFloat(): Float = readExact(4, \"floating point number\") { memory, offset ->\n    memory.loadFloatAt(offset)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Input instead.\")\npublic inline fun IoBuffer.readFloat(): Float = (this as Buffer).readFloat()\n\n\n/**\n * Read a floating point number or fail if not enough bytes available for reading.\n * The numeric value is decoded in the network order (Big Endian).\n */\npublic fun Buffer.readDouble(): Double = readExact(8, \"long floating point number\") { memory, offset ->\n    memory.loadDoubleAt(offset)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Input instead.\")\npublic inline fun IoBuffer.readDouble(): Double = (this as Buffer).readDouble()\n\n\n/**\n * Write a short integer or fail if not enough space available for writing.\n * The numeric value is encoded in the network order (Big Endian).\n */\npublic fun Buffer.writeShort(value: Short): Unit = writeExact(2, \"short integer\") { memory, offset ->\n    memory.storeShortAt(offset, value)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Output instead.\")\npublic inline fun IoBuffer.writeShort(value: Short): Unit = (this as Buffer).writeShort(value)\n\n/**\n * Write an unsigned short integer or fail if not enough space available for writing.\n * The numeric value is encoded in the network order (Big Endian).\n */\npublic fun Buffer.writeUShort(value: UShort): Unit = writeExact(2, \"short unsigned integer\") { memory, offset ->\n    memory.storeUShortAt(offset, value)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Output instead.\")\npublic inline fun IoBuffer.writeUShort(value: UShort): Unit = (this as Buffer).writeUShort(value)\n\n/**\n * Write an integer or fail if not enough space available for writing.\n * The numeric value is encoded in the network order (Big Endian).\n */\npublic fun Buffer.writeInt(value: Int): Unit = writeExact(4, \"regular integer\") { memory, offset ->\n    memory.storeIntAt(offset, value)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Output instead.\")\npublic inline fun IoBuffer.writeInt(value: Int): Unit = (this as Buffer).writeInt(value)\n\n/**\n * Write an unsigned integer or fail if not enough space available for writing.\n * The numeric value is encoded in the network order (Big Endian).\n */\npublic fun Buffer.writeUInt(value: UInt): Unit = writeExact(4, \"regular unsigned integer\") { memory, offset ->\n    memory.storeUIntAt(offset, value)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Output instead.\")\npublic inline fun IoBuffer.writeUInt(value: UInt): Unit = (this as Buffer).writeUInt(value)\n\n/**\n * Write a long integer or fail if not enough space available for writing.\n * The numeric value is encoded in the network order (Big Endian).\n */\npublic fun Buffer.writeLong(value: Long): Unit = writeExact(8, \"long integer\") { memory, offset ->\n    memory.storeLongAt(offset, value)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Output instead.\")\npublic inline fun IoBuffer.writeLong(value: Long): Unit = (this as Buffer).writeLong(value)\n\n/**\n * Write an unsigned long integer or fail if not enough space available for writing.\n * The numeric value is encoded in the network order (Big Endian).\n */\npublic fun Buffer.writeULong(value: ULong): Unit = writeExact(8, \"long unsigned integer\") { memory, offset ->\n    memory.storeULongAt(offset, value)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Output instead.\")\npublic inline fun IoBuffer.writeULong(value: ULong): Unit = (this as Buffer).writeULong(value)\n\n/**\n * Write a floating point number or fail if not enough space available for writing.\n * The numeric value is encoded in the network order (Big Endian).\n */\npublic fun Buffer.writeFloat(value: Float): Unit = writeExact(4, \"floating point number\") { memory, offset ->\n    memory.storeFloatAt(offset, value)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Output instead.\")\npublic inline fun IoBuffer.writeFloat(value: Float): Unit = (this as Buffer).writeFloat(value)\n\n/**\n * Write a floating point number or fail if not enough space available for writing.\n * The numeric value is encoded in the network order (Big Endian).\n */\npublic fun Buffer.writeDouble(value: Double): Unit = writeExact(8, \"long floating point number\") { memory, offset ->\n    memory.storeDoubleAt(offset, value)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Output instead.\")\npublic inline fun IoBuffer.writeDouble(value: Double): Unit = (this as Buffer).writeDouble(value)\n\n/**\n * Read from this buffer to the [destination] array to [offset] and [length] bytes.\n */\npublic fun Buffer.readFully(destination: ByteArray, offset: Int = 0, length: Int = destination.size - offset) {\n    readExact(length, \"byte array\") { memory, srcOffset ->\n        memory.loadByteArray(srcOffset, destination, offset, length)\n    }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Input instead.\")\npublic inline fun IoBuffer.readFully(destination: ByteArray, offset: Int = 0, length: Int = destination.size - offset) {\n    (this as Buffer).readFully(destination, offset, length)\n}\n\n/**\n * Read from this buffer to the [destination] array to [offset] and [length] bytes.\n */\npublic fun Buffer.readFully(destination: UByteArray, offset: Int = 0, length: Int = destination.size - offset) {\n    readFully(destination.asByteArray(), offset, length)\n}\n\n/**\n * Read available for read bytes to the [destination] array range starting at array [offset] and [length] bytes.\n * If less than [length] bytes available then less bytes will be copied and the corresponding number\n * will be returned as result.\n * @return number of bytes copied to the [destination] or `-1` if the buffer is empty\n */\npublic fun Buffer.readAvailable(destination: ByteArray, offset: Int = 0, length: Int = destination.size - offset): Int {\n    require(offset >= 0) { \"offset shouldn't be negative: $offset\" }\n    require(length >= 0) { \"length shouldn't be negative: $length\" }\n    require(offset + length <= destination.size) {\n        \"offset + length should be less than the destination size: $offset\" +\n            \" + $length > ${destination.size}\"\n    }\n\n    if (!canRead()) return -1\n    val toBeRead = minOf(length, readRemaining)\n    readFully(destination, offset, toBeRead)\n    return toBeRead\n}\n\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Input instead.\")\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\npublic inline fun IoBuffer.readAvailable(destination: ByteArray, offset: Int = 0, length: Int = destination.size - offset): Int {\n    return (this as Buffer).readAvailable(destination, offset, length)\n}\n\n/**\n * Read available for read bytes to the [destination] array range starting at array [offset] and [length] bytes.\n * If less than [length] bytes available then less bytes will be copied and the corresponding number\n * will be returned as result.\n * @return number of bytes copied to the [destination] or `-1` if the buffer is empty\n */\npublic fun Buffer.readAvailable(destination: UByteArray, offset: Int = 0, length: Int = destination.size - offset): Int {\n    return readAvailable(destination.asByteArray(), offset, length)\n}\n\n/**\n * Write the whole [source] array range staring at [offset] and having the specified bytes [length].\n */\npublic fun Buffer.writeFully(source: ByteArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeExact(length, \"byte array\") { memory, dstOffset ->\n        memory.storeByteArray(dstOffset, source, offset, length)\n    }\n}\n\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Output instead.\")\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\npublic inline fun IoBuffer.writeFully(source: ByteArray, offset: Int = 0, length: Int = source.size - offset) {\n    (this as Buffer).writeFully(source, offset, length)\n}\n\n/**\n * Write the whole [source] array range staring at [offset] and having the specified bytes [length].\n */\npublic fun Buffer.writeFully(source: UByteArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeFully(source.asByteArray(), offset, length)\n}\n\n/**\n * Read from this buffer to the [destination] array to [offset] and [length] bytes.\n * Numeric values are interpreted in the network byte order (Big Endian).\n */\npublic fun Buffer.readFully(destination: ShortArray, offset: Int = 0, length: Int = destination.size - offset) {\n    readExact(length * 2, \"short integers array\") { memory, srcOffset ->\n        memory.loadShortArray(srcOffset, destination, offset, length)\n    }\n}\n\n/**\n * Read from this buffer to the [destination] array to [offset] and [length] bytes.\n * Numeric values are interpreted in the network byte order (Big Endian).\n */\npublic fun Buffer.readFully(destination: UShortArray, offset: Int = 0, length: Int = destination.size - offset) {\n    readFully(destination.asShortArray(), offset, length)\n}\n\n/**\n * Read available for read bytes to the [destination] array range starting at array [offset] and [length] elements.\n * If less than [length] elements available then less elements will be copied and the corresponding number\n * will be returned as result (possibly zero).\n *\n * @return number of elements copied to the [destination] or `-1` if the buffer is empty,\n *  `0` - not enough bytes for at least an element\n */\npublic fun Buffer.readAvailable(destination: ShortArray, offset: Int = 0, length: Int = destination.size - offset): Int {\n    require(offset >= 0) { \"offset shouldn't be negative: $offset\" }\n    require(length >= 0) { \"length shouldn't be negative: $length\" }\n    require(offset + length <= destination.size) {\n        \"offset + length should be less than the destination size: $offset\" +\n            \" + $length > ${destination.size}\"\n    }\n\n    if (!canRead()) return -1\n    val toBeRead = minOf(length / 2, readRemaining)\n    readFully(destination, offset, toBeRead)\n    return toBeRead\n}\n\n/**\n * Read available for read bytes to the [destination] array range starting at array [offset] and [length] elements.\n * If less than [length] elements available then less elements will be copied and the corresponding number\n * will be returned as result (possibly zero).\n *\n * @return number of elements copied to the [destination] or `-1` if the buffer is empty,\n *  `0` - not enough bytes for at least an element\n */\npublic fun Buffer.readAvailable(destination: UShortArray, offset: Int = 0, length: Int = destination.size - offset): Int {\n    return readAvailable(destination.asShortArray(), offset, length)\n}\n\n/**\n * Write the whole [source] array range staring at [offset] and having the specified items [length].\n * Numeric values are interpreted in the network byte order (Big Endian).\n */\npublic fun Buffer.writeFully(source: ShortArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeExact(length * 2, \"short integers array\") { memory, dstOffset ->\n        memory.storeShortArray(dstOffset, source, offset, length)\n    }\n}\n\n/**\n * Write the whole [source] array range staring at [offset] and having the specified items [length].\n * Numeric values are interpreted in the network byte order (Big Endian).\n */\npublic fun Buffer.writeFully(source: UShortArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeFully(source.asShortArray(), offset, length)\n}\n\n/**\n * Read from this buffer to the [destination] array to [offset] and [length] bytes.\n * Numeric values are interpreted in the network byte order (Big Endian).\n */\npublic fun Buffer.readFully(destination: IntArray, offset: Int = 0, length: Int = destination.size - offset) {\n    readExact(length * 4, \"integers array\") { memory, srcOffset ->\n        memory.loadIntArray(srcOffset, destination, offset, length)\n    }\n}\n\n/**\n * Read from this buffer to the [destination] array to [offset] and [length] bytes.\n * Numeric values are interpreted in the network byte order (Big Endian).\n */\npublic fun Buffer.readFully(destination: UIntArray, offset: Int = 0, length: Int = destination.size - offset) {\n    readFully(destination.asIntArray(), offset, length)\n}\n\n/**\n * Read available for read bytes to the [destination] array range starting at array [offset] and [length] elements.\n * If less than [length] elements available then less elements will be copied and the corresponding number\n * will be returned as result (possibly zero).\n *\n * @return number of elements copied to the [destination] or `-1` if the buffer is empty,\n *  `0` - not enough bytes for at least an element\n */\npublic fun Buffer.readAvailable(destination: IntArray, offset: Int = 0, length: Int = destination.size - offset): Int {\n    require(offset >= 0) { \"offset shouldn't be negative: $offset\" }\n    require(length >= 0) { \"length shouldn't be negative: $length\" }\n    require(offset + length <= destination.size) {\n        \"offset + length should be less than the destination size: $offset\" +\n            \" + $length > ${destination.size}\"\n    }\n\n    if (!canRead()) return -1\n    val toBeRead = minOf(length / 4, readRemaining)\n    readFully(destination, offset, toBeRead)\n    return toBeRead\n}\n\n/**\n * Read available for read bytes to the [destination] array range starting at array [offset] and [length] elements.\n * If less than [length] elements available then less elements will be copied and the corresponding number\n * will be returned as result (possibly zero).\n *\n * @return number of elements copied to the [destination] or `-1` if the buffer is empty,\n *  `0` - not enough bytes for at least an element\n */\npublic fun Buffer.readAvailable(destination: UIntArray, offset: Int = 0, length: Int = destination.size - offset): Int {\n    return readAvailable(destination.asIntArray(), offset, length)\n}\n\n/**\n * Write the whole [source] array range staring at [offset] and having the specified items [length].\n * Numeric values are interpreted in the network byte order (Big Endian).\n */\npublic fun Buffer.writeFully(source: IntArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeExact(length * 4, \"integers array\") { memory, dstOffset ->\n        memory.storeIntArray(dstOffset, source, offset, length)\n    }\n}\n\n/**\n * Write the whole [source] array range staring at [offset] and having the specified items [length].\n * Numeric values are interpreted in the network byte order (Big Endian).\n */\npublic fun Buffer.writeFully(source: UIntArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeFully(source.asIntArray(), offset, length)\n}\n\n/**\n * Read from this buffer to the [destination] array to [offset] and [length] bytes.\n * Numeric values are interpreted in the network byte order (Big Endian).\n */\npublic fun Buffer.readFully(destination: LongArray, offset: Int = 0, length: Int = destination.size - offset) {\n    readExact(length * 8, \"long integers array\") { memory, srcOffset ->\n        memory.loadLongArray(srcOffset, destination, offset, length)\n    }\n}\n\n/**\n * Read from this buffer to the [destination] array to [offset] and [length] bytes.\n * Numeric values are interpreted in the network byte order (Big Endian).\n */\npublic fun Buffer.readFully(destination: ULongArray, offset: Int = 0, length: Int = destination.size - offset) {\n    readFully(destination.asLongArray(), offset, length)\n}\n\n/**\n * Read available for read bytes to the [destination] array range starting at array [offset] and [length] elements.\n * If less than [length] elements available then less elements will be copied and the corresponding number\n * will be returned as result (possibly zero).\n *\n * @return number of elements copied to the [destination] or `-1` if the buffer is empty,\n *  `0` - not enough bytes for at least an element\n */\npublic fun Buffer.readAvailable(destination: LongArray, offset: Int = 0, length: Int = destination.size - offset): Int {\n    require(offset >= 0) { \"offset shouldn't be negative: $offset\" }\n    require(length >= 0) { \"length shouldn't be negative: $length\" }\n    require(offset + length <= destination.size) {\n        \"offset + length should be less than the destination size: $offset\" +\n            \" + $length > ${destination.size}\"\n    }\n\n    if (!canRead()) return -1\n    val toBeRead = minOf(length / 8, readRemaining)\n    readFully(destination, offset, toBeRead)\n    return toBeRead\n}\n\n/**\n * Read available for read bytes to the [destination] array range starting at array [offset] and [length] elements.\n * If less than [length] elements available then less elements will be copied and the corresponding number\n * will be returned as result (possibly zero).\n *\n * @return number of elements copied to the [destination] or `-1` if the buffer is empty,\n *  `0` - not enough bytes for at least an element\n */\npublic fun Buffer.readAvailable(destination: ULongArray, offset: Int = 0, length: Int = destination.size - offset): Int {\n    return readAvailable(destination.asLongArray(), offset, length)\n}\n\n/**\n * Write the whole [source] array range staring at [offset] and having the specified items [length].\n * Numeric values are interpreted in the network byte order (Big Endian).\n */\npublic fun Buffer.writeFully(source: LongArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeExact(length * 8, \"long integers array\") { memory, dstOffset ->\n        memory.storeLongArray(dstOffset, source, offset, length)\n    }\n}\n\n/**\n * Write the whole [source] array range staring at [offset] and having the specified items [length].\n * Numeric values are interpreted in the network byte order (Big Endian).\n */\npublic fun Buffer.writeFully(source: ULongArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeFully(source.asLongArray(), offset, length)\n}\n\n/**\n * Read from this buffer to the [destination] array to [offset] and [length] bytes.\n * Numeric values are interpreted in the network byte order (Big Endian).\n */\npublic fun Buffer.readFully(destination: FloatArray, offset: Int = 0, length: Int = destination.size - offset) {\n    readExact(length * 4, \"floating point numbers array\") { memory, srcOffset ->\n        memory.loadFloatArray(srcOffset, destination, offset, length)\n    }\n}\n\n/**\n * Read available for read bytes to the [destination] array range starting at array [offset] and [length] elements.\n * If less than [length] elements available then less elements will be copied and the corresponding number\n * will be returned as result (possibly zero).\n *\n * @return number of elements copied to the [destination] or `-1` if the buffer is empty,\n *  `0` - not enough bytes for at least an element\n */\npublic fun Buffer.readAvailable(destination: FloatArray, offset: Int = 0, length: Int = destination.size - offset): Int {\n    require(offset >= 0) { \"offset shouldn't be negative: $offset\" }\n    require(length >= 0) { \"length shouldn't be negative: $length\" }\n    require(offset + length <= destination.size) {\n        \"offset + length should be less than the destination size: $offset\" +\n            \" + $length > ${destination.size}\"\n    }\n\n    if (!canRead()) return -1\n    val toBeRead = minOf(length / 4, readRemaining)\n    readFully(destination, offset, toBeRead)\n    return toBeRead\n}\n\n/**\n * Write the whole [source] array range staring at [offset] and having the specified items [length].\n * Numeric values are interpreted in the network byte order (Big Endian).\n */\npublic fun Buffer.writeFully(source: FloatArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeExact(length * 4, \"floating point numbers array\") { memory, dstOffset ->\n        memory.storeFloatArray(dstOffset, source, offset, length)\n    }\n}\n\n/**\n * Read from this buffer to the [destination] array to [offset] and [length] bytes.\n * Numeric values are interpreted in the network byte order (Big Endian).\n */\npublic fun Buffer.readFully(destination: DoubleArray, offset: Int = 0, length: Int = destination.size - offset) {\n    readExact(length * 8, \"floating point numbers array\") { memory, srcOffset ->\n        memory.loadDoubleArray(srcOffset, destination, offset, length)\n    }\n}\n\n/**\n * Read available for read bytes to the [destination] array range starting at array [offset] and [length] elements.\n * If less than [length] elements available then less elements will be copied and the corresponding number\n * will be returned as result (possibly zero).\n *\n * @return number of elements copied to the [destination] or `-1` if the buffer is empty,\n *  `0` - not enough bytes for at least an element\n */\npublic fun Buffer.readAvailable(destination: DoubleArray, offset: Int = 0, length: Int = destination.size - offset): Int {\n    require(offset >= 0) { \"offset shouldn't be negative: $offset\" }\n    require(length >= 0) { \"length shouldn't be negative: $length\" }\n    require(offset + length <= destination.size) {\n        \"offset + length should be less than the destination size: $offset\" +\n            \" + $length > ${destination.size}\"\n    }\n\n    if (!canRead()) return -1\n    val toBeRead = minOf(length / 8, readRemaining)\n    readFully(destination, offset, toBeRead)\n    return toBeRead\n}\n\n/**\n * Write the whole [source] array range staring at [offset] and having the specified items [length].\n * Numeric values are interpreted in the network byte order (Big Endian).\n */\npublic fun Buffer.writeFully(source: DoubleArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeExact(length * 8, \"floating point numbers array\") { memory, dstOffset ->\n        memory.storeDoubleArray(dstOffset, source, offset, length)\n    }\n}\n\n/**\n * Read at most [length] bytes from this buffer to the [dst] buffer.\n * @return number of bytes copied\n */\npublic fun Buffer.readFully(dst: Buffer, length: Int = dst.writeRemaining): Int {\n    require(length >= 0)\n    require(length <= dst.writeRemaining)\n\n    readExact(length, \"buffer content\") { memory, offset ->\n        memory.copyTo(dst.memory, offset, length, dst.writePosition)\n        dst.commitWritten(length)\n    }\n\n    return length\n}\n\n/**\n * Read at most [length] available bytes to the [dst] buffer or `-1` if no bytes available for read.\n * @return number of bytes copied or `-1` if empty\n */\npublic fun Buffer.readAvailable(dst: Buffer, length: Int = dst.writeRemaining): Int {\n    if (!canRead()) return -1\n\n    val readSize = minOf(dst.writeRemaining, readRemaining, length)\n\n    readExact(readSize, \"buffer content\") { memory, offset ->\n        memory.copyTo(dst.memory, offset, readSize, dst.writePosition)\n        dst.commitWritten(readSize)\n    }\n\n    return readSize\n}\n\n/**\n * Write all readable bytes from [src] to this buffer. Fails if not enough space available to write all bytes.\n */\npublic fun Buffer.writeFully(src: Buffer) {\n    val length = src.readRemaining\n\n    writeExact(length, \"buffer readable content\") { memory, offset ->\n        src.memory.copyTo(memory, src.readPosition, length, offset)\n        src.discardExact(length)\n    }\n}\n\n/**\n * Write at most [length] readable bytes from [src] to this buffer.\n * Fails if not enough space available to write all bytes.\n */\npublic fun Buffer.writeFully(src: Buffer, length: Int) {\n    require(length >= 0) { \"length shouldn't be negative: $length\" }\n    require(length <= src.readRemaining) {\n        \"length shouldn't be greater than the source read remaining: $length > ${src.readRemaining}\"\n    }\n    require(length <= writeRemaining) {\n        \"length shouldn't be greater than the destination write remaining space: $length > $writeRemaining\"\n    }\n\n    writeExact(length, \"buffer readable content\") { memory, offset ->\n        src.memory.copyTo(memory, src.readPosition, length, offset)\n        src.discardExact(length)\n    }\n}\n\n@PublishedApi\ninternal inline fun <R> Buffer.readExact(size: Int, name: String, block: (memory: Memory, offset: Int) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n\n    var value: R\n\n    read { memory, start, endExclusive ->\n        io.ktor.utils.io.core.internal.require(endExclusive - start >= size) {\n            throw EOFException(\"Not enough bytes to read a $name of size $size.\")\n        }\n        value = block(memory, start)\n        size\n    }\n\n    return value\n}\n\n@PublishedApi\ninternal inline fun Buffer.writeExact(size: Int, name: String, block: (memory: Memory, offset: Int) -> Unit) {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n\n    write { memory, start, endExclusive ->\n        val writeRemaining = endExclusive - start\n        if (writeRemaining < size) {\n            throw InsufficientSpaceException(name, size, writeRemaining)\n        }\n        block(memory, start)\n        size\n    }\n}\n","@file:Suppress(\"DeprecatedCallableAddReplaceWith\")\n\npackage io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.charsets.*\nimport io.ktor.utils.io.core.internal.*\nimport io.ktor.utils.io.core.internal.require\nimport io.ktor.utils.io.errors.*\nimport io.ktor.utils.io.pool.*\n\n/**\n * Write byte [value] repeated the specified [times].\n */\npublic fun Buffer.fill(times: Int, value: Byte) {\n    require(times >= 0) { \"times shouldn't be negative: $times\" }\n    require(times <= writeRemaining) { \"times shouldn't be greater than the write remaining space: $times > $writeRemaining\" }\n\n    memory.fill(writePosition, times, value)\n    commitWritten(times)\n}\n\n/**\n * Write unsigned byte [value] repeated the specified [times].\n */\npublic fun Buffer.fill(times: Int, value: UByte) {\n    fill(times, value.toByte())\n}\n\n/**\n * Write byte [v] value repeated [n] times.\n */\n@Deprecated(\"Use fill with n with type Int\")\npublic fun Buffer.fill(n: Long, v: Byte) {\n    fill(n.toIntOrFail(\"n\"), v)\n}\n\n/**\n * Push back [n] bytes: only possible if there were at least [n] bytes read before this operation.\n */\n@Deprecated(\"Use rewind instead\", ReplaceWith(\"rewind(n)\"))\npublic fun Buffer.pushBack(n: Int): Unit = rewind(n)\n\n@Deprecated(\"Use duplicate instead\", ReplaceWith(\"duplicate()\"))\npublic fun Buffer.makeView(): Buffer = duplicate()\n\n@Deprecated(\"Use duplicate instead\", ReplaceWith(\"duplicate()\"))\npublic fun ChunkBuffer.makeView(): ChunkBuffer = duplicate()\n\n@Deprecated(\"Does nothing.\")\npublic fun Buffer.flush() {\n}\n\ninternal fun Buffer.appendChars(csq: CharArray, start: Int, end: Int): Int {\n    return appendChars(CharArraySequence(csq, 0, csq.size), start, end)\n}\n\ninternal fun Buffer.appendChars(csq: CharSequence, start: Int, end: Int): Int {\n    var charactersWritten: Int\n\n    write { dst, dstStart, dstEndExclusive ->\n        val result = dst.encodeUTF8(csq, start, end, dstStart, dstEndExclusive)\n        charactersWritten = result.characters.toInt()\n        result.bytes.toInt()\n    }\n\n    return start + charactersWritten\n}\n\n@Deprecated(\"This is no longer supported. Use a packet builder to append characters instead.\")\npublic fun Buffer.append(c: Char): Buffer {\n    write { memory, start, endExclusive ->\n        val size = memory.putUtf8Char(start, c.toInt())\n        when {\n            size > endExclusive - start -> appendFailed(1)\n            else -> size\n        }\n    }\n\n    return this\n}\n\n@Deprecated(\"This is no longer supported. Use a packet builder to append characters instead.\")\npublic fun Buffer.append(csq: CharSequence?): Buffer {\n    if (csq == null) {\n        return append(\"null\")\n    }\n\n    return append(csq, 0, csq.length)\n}\n\n@Deprecated(\"This is no longer supported. Use a packet builder to append characters instead.\")\npublic fun Buffer.append(csq: CharSequence?, start: Int, end: Int): Buffer = apply {\n    if (csq == null) {\n        return append(\"null\", start, end)\n    }\n\n    if (appendChars(csq, start, end) != end) {\n        appendFailed(end - start)\n    }\n}\n\nprivate fun appendFailed(length: Int): Nothing {\n    throw BufferLimitExceededException(\"Not enough free space available to write $length character(s).\")\n}\n\n@Deprecated(\"This is no longer supported. Use a packet builder to append characters instead.\")\npublic fun Buffer.append(csq: CharArray, start: Int, end: Int): Buffer {\n    return append(CharArraySequence(csq, 0, csq.size), start, end)\n}\n\n@Deprecated(\"This is no longer supported. Read from a packet instead.\")\npublic fun Buffer.readText(decoder: CharsetDecoder, out: Appendable, lastBuffer: Boolean, max: Int = Int.MAX_VALUE): Int {\n    return decoder.decodeBuffer(this, out, lastBuffer, max)\n}\n\n/**\n * releases buffer view and returns it to the [pool] if there are no more usages. Based on simple ref-counting so\n * it is very fragile.\n */\n@Suppress(\"DEPRECATION\")\npublic fun IoBuffer.release(pool: ObjectPool<IoBuffer>) {\n    // TODO ???\n    @Suppress(\"UNCHECKED_CAST\")\n    (this as ChunkBuffer).release(pool as ObjectPool<ChunkBuffer>)\n}\n\n/**\n * Peek the next unsigned byte or return `-1` if no more bytes available for reading. No bytes will be marked\n * as consumed in any case.\n * @see [Buffer.tryPeekByte]\n */\n@Deprecated(\"Use tryPeekByte instead\", replaceWith = ReplaceWith(\"tryPeekByte()\"))\npublic fun Buffer.tryPeek(): Int = tryPeekByte()\n\npublic fun Buffer.readFully(dst: Array<Byte>, offset: Int = 0, length: Int = dst.size - offset) {\n    read { memory, start, endExclusive ->\n        if (endExclusive - start < length) {\n            throw EOFException(\"Not enough bytes available to read $length bytes\")\n        }\n\n        for (index in 0 until length) {\n            dst[index + offset] = memory[index + start]\n        }\n\n        length\n    }\n}\n\n@Deprecated(\n    \"This is no longer supported. All operations are big endian by default. Use readXXXLittleEndian \" +\n        \"to read primitives in little endian\",\n    level = DeprecationLevel.ERROR\n)\npublic var Buffer.byteOrder: ByteOrder\n    get() = ByteOrder.BIG_ENDIAN\n    set(newOrder) {\n        if (newOrder != ByteOrder.BIG_ENDIAN) throw UnsupportedOperationException(\"Only BIG_ENDIAN is supported\")\n    }\n","package io.ktor.utils.io.bits\n\nimport io.ktor.utils.io.core.ExperimentalIoApi\n\n/**\n * Reverse number's byte order\n */\npublic expect fun Short.reverseByteOrder(): Short\n\n/**\n * Reverse number's byte order\n */\npublic expect fun Int.reverseByteOrder(): Int\n\n/**\n * Reverse number's byte order\n */\npublic expect fun Long.reverseByteOrder(): Long\n\n/**\n * Reverse number's byte order\n */\npublic expect fun Float.reverseByteOrder(): Float\n\n/**\n * Reverse number's byte order\n */\npublic expect fun Double.reverseByteOrder(): Double\n\n/**\n * Reverse number's byte order\n */\n@ExperimentalUnsignedTypes\npublic fun UShort.reverseByteOrder(): UShort = toShort().reverseByteOrder().toUShort()\n\n/**\n * Reverse number's byte order\n */\n@ExperimentalUnsignedTypes\npublic fun UInt.reverseByteOrder(): UInt = toInt().reverseByteOrder().toUInt()\n\n/**\n * Reverse number's byte order\n */\n@ExperimentalUnsignedTypes\npublic fun ULong.reverseByteOrder(): ULong = toLong().reverseByteOrder().toULong()\n\n@ExperimentalIoApi\npublic inline val Short.highByte: Byte get() = (toInt() ushr 8).toByte()\n\n@ExperimentalIoApi\npublic inline val Short.lowByte: Byte get() = (toInt() and 0xff).toByte()\n\n@ExperimentalIoApi\npublic inline val Int.highShort: Short get() = (this ushr 16).toShort()\n\n@ExperimentalIoApi\npublic inline val Int.lowShort: Short get() = (this and 0xffff).toShort()\n\n@ExperimentalIoApi\npublic inline val Long.highInt: Int get() = (this ushr 32).toInt()\n\n@ExperimentalIoApi\npublic inline val Long.lowInt: Int get() = (this and 0xffffffffL).toInt()\n","package io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.core.internal.ChunkBuffer\nimport io.ktor.utils.io.pool.DefaultPool\nimport io.ktor.utils.io.pool.ObjectPool\nimport kotlin.native.concurrent.ThreadLocal\n\ninternal const val DEFAULT_BUFFER_SIZE: Int = 4096\n\n/**\n * Invoke [block] function with a temporary [Buffer] instance of the specified [size] in bytes.\n * The provided instance shouldn't be captured and used outside of the [block] otherwise an undefined behaviour\n * may occur including crash and/or data corruption.\n */\n@ExperimentalIoApi\npublic inline fun <R> withBuffer(size: Int, block: Buffer.() -> R): R {\n    return with(Buffer(DefaultAllocator.alloc(size)), block)\n}\n\n/**\n * Invoke [block] function with a temporary [Buffer] instance taken from the specified [pool].\n * Depending on the pool it may be safe or unsafe to capture and use the provided buffer outside of the [block].\n * Usually it is always recommended to NOT capture an instance outside.\n */\n@ExperimentalIoApi\npublic inline fun <R> withBuffer(pool: ObjectPool<Buffer>, block: Buffer.() -> R): R {\n    val instance = pool.borrow()\n    return try {\n        block(instance)\n    } finally {\n        pool.recycle(instance)\n    }\n}\n\n/**\n * Invoke [block] function with a temporary [Buffer] instance taken from the specified [pool].\n * Depending on the pool it may be safe or unsafe to capture and use the provided buffer outside of the [block].\n * Usually it is always recommended to NOT capture an instance outside.\n * However since [ChunkBuffer] is reference counted, you can create a [Buffer.duplicate] (this is simply a view) and use\n * it outside of the [block] function but it is important to release the duplicate properly once not needed anymore\n * otherwise memory leak may occur on some platforms.\n */\ninternal inline fun <R> withChunkBuffer(pool: ObjectPool<ChunkBuffer>, block: ChunkBuffer.() -> R): R {\n    val instance = pool.borrow()\n    return try {\n        block(instance)\n    } finally {\n        instance.release(pool)\n    }\n}\n\n@ThreadLocal\n@Suppress(\"DEPRECATION\")\ninternal val DefaultChunkedBufferPool: ObjectPool<IoBuffer> = DefaultBufferPool()\n\n@Suppress(\"DEPRECATION\")\ninternal class DefaultBufferPool(\n    private val bufferSize: Int = DEFAULT_BUFFER_SIZE,\n\n    capacity: Int = 1000,\n    private val allocator: Allocator = DefaultAllocator\n) : DefaultPool<IoBuffer>(capacity) {\n    override fun produceInstance(): IoBuffer {\n        return IoBuffer(allocator.alloc(bufferSize), null)\n    }\n\n    override fun disposeInstance(instance: IoBuffer) {\n        allocator.free(instance.memory)\n        super.disposeInstance(instance)\n        instance.unlink()\n    }\n\n    override fun validateInstance(instance: IoBuffer) {\n        super.validateInstance(instance)\n\n        if (instance === IoBuffer.Empty) {\n            error(\"IoBuffer.Empty couldn't be recycled\")\n        }\n\n        check(instance !== IoBuffer.Empty) { \"Empty instance couldn't be recycled\" }\n        check(instance !== Buffer.Empty) { \"Empty instance couldn't be recycled\" }\n        check(instance !== ChunkBuffer.Empty) { \"Empty instance couldn't be recycled\" }\n\n        check(instance.referenceCount == 0) { \"Unable to clear buffer: it is still in use.\" }\n        check(instance.next == null) { \"Recycled instance shouldn't be a part of a chain.\" }\n        check(instance.origin == null) { \"Recycled instance shouldn't be a view or another buffer.\" }\n    }\n\n    override fun clearInstance(instance: IoBuffer): IoBuffer {\n        return super.clearInstance(instance).apply {\n            unpark()\n            reset()\n        }\n    }\n}\n","@file:Suppress(\"RedundantModalityModifier\")\n\npackage io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.Memory\nimport io.ktor.utils.io.core.internal.*\nimport io.ktor.utils.io.core.internal.require\nimport io.ktor.utils.io.pool.*\nimport kotlin.Boolean\nimport kotlin.Char\nimport kotlin.CharSequence\nimport kotlin.Deprecated\nimport kotlin.DeprecationLevel\nimport kotlin.Int\nimport kotlin.PublishedApi\nimport kotlin.Suppress\nimport kotlin.check\nimport kotlin.jvm.JvmName\n\n/**\n * A builder that provides ability to build byte packets with no knowledge of it's size.\n * Unlike Java's ByteArrayOutputStream it doesn't copy the whole content every time it's internal buffer overflows\n * but chunks buffers instead. Packet building via [build] function is O(1) operation and only does instantiate\n * a new [ByteReadPacket]. Once a byte packet has been built via [build] function call, the builder could be\n * reused again. You also can discard all written bytes via [reset] or [release]. Please note that an instance of\n * builder need to be terminated either via [build] function invocation or via [release] call otherwise it will\n * cause byte buffer leak so that may have performance impact.\n *\n * Byte packet builder is also an [Appendable] so it does append UTF-8 characters to a packet\n *\n * ```\n * buildPacket {\n *     listOf(1,2,3).joinTo(this, separator = \",\")\n * }\n * ```\n */\npublic class BytePacketBuilder(private var headerSizeHint: Int = 0, pool: ObjectPool<ChunkBuffer>) :\n    @Suppress(\"DEPRECATION_ERROR\") BytePacketBuilderPlatformBase(pool) {\n    init {\n        require(headerSizeHint >= 0) { \"shouldn't be negative: headerSizeHint = $headerSizeHint\" }\n    }\n\n    /**\n     * Number of bytes written to the builder after the creation or the last reset.\n     */\n    public val size: Int\n        get() = _size\n\n    /**\n     * If no bytes were written or the builder has been reset.\n     */\n    public val isEmpty: Boolean\n        get() = _size == 0\n\n    /**\n     * If at least one byte was written after the creation or the last reset.\n     */\n    public val isNotEmpty: Boolean\n        get() = _size > 0\n\n    @PublishedApi\n    internal val _pool: ObjectPool<ChunkBuffer>\n        get() = pool\n\n    /**\n     * Does nothing for memory-backed output\n     */\n    final override fun closeDestination() {\n    }\n\n    /**\n     * Does nothing for memory-backed output\n     */\n    final override fun flush(source: Memory, offset: Int, length: Int) {\n    }\n\n    override fun append(c: Char): BytePacketBuilder {\n        return super.append(c) as BytePacketBuilder\n    }\n\n    override fun append(csq: CharSequence?): BytePacketBuilder {\n        return super.append(csq) as BytePacketBuilder\n    }\n\n    override fun append(csq: CharSequence?, start: Int, end: Int): BytePacketBuilder {\n        return super.append(csq, start, end) as BytePacketBuilder\n    }\n\n    @Suppress(\"DEPRECATION_ERROR\", \"UNUSED\")\n    @Deprecated(\"Binary compatibility\", level = DeprecationLevel.HIDDEN)\n    @JvmName(\"append\")\n    public fun appendOld(c: Char): BytePacketBuilderBase = append(c)\n\n    @Suppress(\"DEPRECATION_ERROR\", \"UNUSED\")\n    @Deprecated(\"Binary compatibility\", level = DeprecationLevel.HIDDEN)\n    @JvmName(\"append\")\n    public fun appendOld(csq: CharSequence?): BytePacketBuilderBase = append(csq)\n\n    @Suppress(\"DEPRECATION_ERROR\", \"UNUSED\")\n    @Deprecated(\"Binary compatibility\", level = DeprecationLevel.HIDDEN)\n    @JvmName(\"append\")\n    public fun appendOld(csq: CharSequence?, start: Int, end: Int): BytePacketBuilderBase = append(csq, start, end)\n\n    /**\n     * Creates a temporary packet view of the packet being build without discarding any bytes from the builder.\n     * This is similar to `build().copy()` except that the builder keeps already written bytes untouched.\n     * A temporary view packet is passed as argument to [block] function and it shouldn't leak outside of this block\n     * otherwise an unexpected behaviour may occur.\n     */\n    @Suppress(\"unused\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun <R> preview(block: (tmp: ByteReadPacket) -> R): R {\n        return preview(block)\n    }\n\n    /**\n     * Builds byte packet instance and resets builder's state to be able to build another one packet if needed\n     */\n    public fun build(): ByteReadPacket {\n        val size = size\n        val head = stealAll()\n\n        return when (head) {\n            null -> ByteReadPacket.Empty\n            else -> ByteReadPacket(head, size.toLong(), pool)\n        }\n    }\n\n    /**\n     * Discard all written bytes and prepare to build another packet.\n     */\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    final override fun reset() {\n        release()\n    }\n\n    @PublishedApi\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"unused\")\n    internal fun preview(): ByteReadPacket {\n        return preview()\n    }\n\n    override fun toString(): String {\n        return \"BytePacketBuilder($size bytes written)\"\n    }\n}\n","@file:Suppress(\"RedundantModalityModifier\", \"FunctionName\")\n\npackage io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.Memory\nimport io.ktor.utils.io.core.internal.*\nimport io.ktor.utils.io.pool.*\n\n/**\n * Read-only immutable byte packet. Could be consumed only once however it does support [copy] that doesn't copy every byte\n * but creates a new view instead. Once packet created it should be either completely read (consumed) or released\n * via [release].\n */\npublic class ByteReadPacket internal constructor(\n    head: ChunkBuffer, remaining: Long, pool: ObjectPool<ChunkBuffer>\n) : @Suppress(\"DEPRECATION_ERROR\") ByteReadPacketPlatformBase(head, remaining, pool), Input {\n    public constructor(head: ChunkBuffer, pool: ObjectPool<ChunkBuffer>) : this(head, head.remainingAll(), pool)\n\n    @Suppress(\"DEPRECATION\", \"UNUSED\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public constructor(head: IoBuffer, pool: ObjectPool<ChunkBuffer>) : this(head, head.remainingAll(), pool)\n\n    init {\n        markNoMoreChunksAvailable()\n    }\n\n    /**\n     * Returns a copy of the packet. The original packet and the copy could be used concurrently. Both need to be\n     * either completely consumed or released via [release]\n     */\n    public final fun copy(): ByteReadPacket = ByteReadPacket(head.copyAll(), remaining, pool)\n\n    final override fun fill(): ChunkBuffer? = null\n\n    final override fun fill(destination: Memory, offset: Int, length: Int): Int {\n        return 0\n    }\n\n    final override fun closeSource() {\n    }\n\n    override fun toString(): String {\n        return \"ByteReadPacket($remaining bytes remaining)\"\n    }\n\n    public companion object {\n        public val Empty: ByteReadPacket = ByteReadPacket(ChunkBuffer.Empty, 0L, ChunkBuffer.EmptyPool)\n\n        @DangerousInternalIoApi\n        public val ReservedSize: Int\n            get() = Buffer.ReservedSize\n    }\n}\n\n@Suppress(\"DEPRECATION\")\n@DangerousInternalIoApi\n@Deprecated(\n    \"Will be removed in future releases.\",\n    level = DeprecationLevel.ERROR,\n    replaceWith = ReplaceWith(\"AbstractInput\", \"io.ktor.utils.io.core.AbstractInput\")\n)\npublic abstract class ByteReadPacketPlatformBase protected constructor(\n    head: ChunkBuffer,\n    remaining: Long,\n    pool: ObjectPool<ChunkBuffer>\n) : ByteReadPacketBase(head, remaining, pool) {\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public constructor(head: IoBuffer,\n                remaining: Long,\n                pool: ObjectPool<ChunkBuffer>) : this(head as ChunkBuffer, remaining, pool)\n}\n\npublic expect fun ByteReadPacket(\n    array: ByteArray, offset: Int = 0, length: Int = array.size,\n    block: (ByteArray) -> Unit\n): ByteReadPacket\n\n@Suppress(\"NOTHING_TO_INLINE\")\npublic inline fun ByteReadPacket(array: ByteArray, offset: Int = 0, length: Int = array.size): ByteReadPacket {\n    return ByteReadPacket(array, offset, length) {}\n}\n","package io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.core.internal.*\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Input.readShort(): Short {\n    return readPrimitive(2, { memory, index -> memory.loadShortAt(index) }, { readShortFallback() })\n}\n\nprivate fun Input.readShortFallback(): Short {\n    return readPrimitiveFallback(2) { it.readShort() }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Input.readInt(): Int {\n    return readPrimitive(4, { memory, index -> memory.loadIntAt(index) }, { readIntFallback() })\n}\n\nprivate fun Input.readIntFallback(): Int {\n    return readPrimitiveFallback(4) { it.readInt() }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Input.readLong(): Long {\n    return readPrimitive(8, { memory, index -> memory.loadLongAt(index) }, { readLongFallback() })\n}\n\nprivate fun Input.readLongFallback(): Long {\n    return readPrimitiveFallback(8) { it.readLong() }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Input.readFloat(): Float {\n    return readPrimitive(4, { memory, index -> memory.loadFloatAt(index) }, { readFloatFallback() })\n}\n\npublic fun Input.readFloatFallback(): Float {\n    return readPrimitiveFallback(4) { it.readFloat() }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Input.readDouble(): Double {\n    return readPrimitive(8, { memory, index -> memory.loadDoubleAt(index) }, { readDoubleFallback() })\n}\n\npublic fun Input.readDoubleFallback(): Double {\n    return readPrimitiveFallback(8) { it.readDouble() }\n}\n\nprivate inline fun <R> Input.readPrimitive(size: Int, main: (Memory, Int) -> R, fallback: () -> R): R {\n    if (this is AbstractInput && headRemaining > size) {\n        val index = headPosition\n        headPosition = index + size\n        return main(headMemory, index)\n    }\n\n    return fallback()\n}\n\nprivate inline fun <R> Input.readPrimitiveFallback(size: Int, read: (Buffer) -> R): R {\n    val head = prepareReadFirstHead(size) ?: prematureEndOfStream(size)\n    val value = read(head)\n    completeReadHead(head)\n    return value\n}\n","@file:Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\n\npackage io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\n\npublic fun Output.writeShort(value: Short) {\n    if (!writePrimitiveTemplate(2) { memory, index -> memory.storeShortAt(index, value) }) {\n        writeShortFallback(value)\n    }\n}\n\nprivate fun Output.writeShortFallback(value: Short) {\n    if (!writePrimitiveFallbackTemplate(2) { it.writeShort(value) }) {\n        writeByte(value.highByte)\n        writeByte(value.lowByte)\n    }\n}\n\npublic fun Output.writeInt(value: Int) {\n    if (!writePrimitiveTemplate(4) { memory, index -> memory.storeIntAt(index, value) }) {\n        writeIntFallback(value)\n    }\n}\n\nprivate fun Output.writeIntFallback(value: Int) {\n    if (!writePrimitiveFallbackTemplate(4) { it.writeInt(value) }) {\n        writeIntByteByByte(value)\n    }\n}\n\nprivate fun Output.writeIntByteByByte(value: Int) {\n    value.highShort.let {\n        writeByte(it.highByte)\n        writeByte(it.lowByte)\n    }\n    value.lowShort.let {\n        writeByte(it.highByte)\n        writeByte(it.lowByte)\n    }\n}\n\npublic fun Output.writeLong(value: Long) {\n    if (!writePrimitiveTemplate(8) { memory, index -> memory.storeLongAt(index, value) }) {\n        writeLongFallback(value)\n    }\n}\n\nprivate fun Output.writeLongFallback(value: Long) {\n    if (!writePrimitiveFallbackTemplate(8) { it.writeLong(value) }) {\n        writeIntByteByByte(value.highInt)\n        writeIntByteByByte(value.lowInt)\n    }\n}\n\npublic fun Output.writeFloat(value: Float) {\n    if (!writePrimitiveTemplate(4) { memory, index -> memory.storeFloatAt(index, value) }) {\n        writeIntFallback(value.toRawBits())\n    }\n}\n\npublic fun Output.writeDouble(value: Double) {\n    if (!writePrimitiveTemplate(8) { memory, index -> memory.storeDoubleAt(index, value) }) {\n        writeLongFallback(value.toRawBits())\n    }\n}\n\nprivate inline fun Output.writePrimitiveTemplate(\n    componentSize: Int,\n    block: (Memory, index: Int) -> Unit\n): Boolean {\n    if (this is AbstractOutput) {\n        val index = tailPosition\n        if (tailEndExclusive - index > componentSize) {\n            tailPosition = index + componentSize\n            block(tailMemory, index)\n            return true\n        }\n    }\n\n    return false\n}\n\nprivate inline fun Output.writePrimitiveFallbackTemplate(\n    componentSize: Int,\n    writeOperation: (Buffer) -> Unit\n): Boolean {\n    if (this is AbstractOutput) {\n        val tail = prepareWriteHead(componentSize)\n        writeOperation(tail)\n        afterHeadWrite()\n        return true\n    }\n\n    return false\n}\n","@file:Suppress(\"RedundantModalityModifier\")\n\npackage io.ktor.utils.io.core\n\nimport io.ktor.utils.io.core.internal.*\nimport io.ktor.utils.io.errors.*\nimport io.ktor.utils.io.pool.*\n\n@DangerousInternalIoApi\n@Deprecated(\n    \"Will be removed in the future releases. Use Input or AbstractInput instead.\",\n    ReplaceWith(\"AbstractInput\", \"io.ktor.utils.io.core.AbstractInput\")\n)\npublic abstract class ByteReadPacketBase(\n    head: ChunkBuffer, remaining: Long, pool: ObjectPool<ChunkBuffer>\n) : AbstractInput(head, remaining, pool) {\n\n    @Suppress(\"DEPRECATION\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public constructor(head: IoBuffer,\n                remaining: Long,\n                pool: ObjectPool<ChunkBuffer>) : this(head as ChunkBuffer, remaining, pool)\n\n    public companion object {\n        @Deprecated(\n            \"Use ByteReadPacket.Empty instead\",\n            ReplaceWith(\"ByteReadPacket.Empty\"),\n            level = DeprecationLevel.ERROR\n        )\n        public val Empty: ByteReadPacket\n            get() = ByteReadPacket.Empty\n    }\n}\n\npublic expect class EOFException(message: String) : IOException\n\n/**\n * For streaming input it should be [Input.endOfInput] instead.\n */\n@Deprecated(\"Use endOfInput property instead\", ReplaceWith(\"endOfInput\"))\npublic inline val Input.isEmpty: Boolean\n    get() = endOfInput\n\n/**\n * For streaming input there is no reliable way to detect it without triggering bytes population from the underlying\n * source. Consider using [Input.endOfInput] or use [ByteReadPacket] instead.\n */\n@Deprecated(\n    \"This makes no sense for streaming inputs. Some use-cases are covered by endOfInput property\",\n    ReplaceWith(\"!endOfInput\")\n)\npublic val Input.isNotEmpty: Boolean\n    get() {\n        if (endOfInput) return false\n        prepareReadFirstHead(1)?.let { found ->\n            completeReadHead(found)\n            return true\n        }\n        return false\n    }\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic inline val ByteReadPacket.isEmpty: Boolean\n    get() = endOfInput\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic inline val ByteReadPacket.isNotEmpty: Boolean\n    get() = !endOfInput\n","package io.ktor.utils.io.core\n\nimport io.ktor.utils.io.core.internal.*\nimport kotlin.contracts.*\n\n/**\n * Creates a temporary packet view of the packet being build without discarding any bytes from the builder.\n * This is similar to `build().copy()` except that the builder keeps already written bytes untouched.\n * A temporary view packet is passed as argument to [block] function and it shouldn't leak outside of this block\n * otherwise an unexpected behaviour may occur.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic inline fun <R> BytePacketBuilder.preview(block: (tmp: ByteReadPacket) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n\n    val packet = preview()\n    return try {\n        block(packet)\n    } finally {\n        packet.release()\n    }\n}\n\n@PublishedApi\ninternal fun BytePacketBuilder.preview(): ByteReadPacket {\n    val head = head\n    return when {\n        head === ChunkBuffer.Empty -> ByteReadPacket.Empty\n        else -> ByteReadPacket(head.copyAll(), _pool)\n    }\n}\n","package io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.get\nimport io.ktor.utils.io.bits.loadByteArray\n\n/**\n * Discards bytes until [delimiter] occurred\n * @return number of bytes discarded\n */\npublic fun Input.discardUntilDelimiter(delimiter: Byte): Long {\n    var discardedTotal = 0L\n\n    takeWhile { chunk ->\n        val discarded = chunk.discardUntilDelimiterImpl(delimiter)\n        discardedTotal += discarded\n        discarded > 0 && !chunk.canRead()\n    }\n\n    return discardedTotal\n}\n\n/**\n * Discards bytes until of of the specified delimiters [delimiter1] or [delimiter2] occurred\n * @return number of bytes discarded\n */\npublic fun Input.discardUntilDelimiters(delimiter1: Byte, delimiter2: Byte): Long {\n    var discardedTotal = 0L\n\n    takeWhile { chunk ->\n        val discarded = chunk.discardUntilDelimitersImpl(delimiter1, delimiter2)\n        discardedTotal += discarded\n        discarded > 0 && !chunk.canRead()\n    }\n\n    return discardedTotal\n}\n\n/**\n * Copies to [dst] array at [offset] at most [length] bytes or until the specified [delimiter] occurred.\n * @return number of bytes copied\n */\npublic fun Input.readUntilDelimiter(delimiter: Byte, dst: ByteArray, offset: Int = 0, length: Int = dst.size): Int {\n    var currentOffset = offset\n    var dstRemaining = length\n\n    takeWhile { chunk ->\n        val copied = chunk.readUntilDelimiterImpl(delimiter, dst, currentOffset, dstRemaining)\n        currentOffset += copied\n        dstRemaining -= copied\n        dstRemaining > 0 && !chunk.canRead()\n    }\n\n    return currentOffset - offset\n}\n\n/**\n * Copies to [dst] array at [offset] at most [length] bytes or until one of the specified delimiters\n * [delimiter1] or [delimiter2] occurred.\n * @return number of bytes copied\n */\npublic fun Input.readUntilDelimiters(delimiter1: Byte, delimiter2: Byte,\n                              dst: ByteArray, offset: Int = 0, length: Int = dst.size): Int {\n    if (delimiter1 == delimiter2) return readUntilDelimiter(delimiter1, dst, offset, length)\n\n    var currentOffset = offset\n    var dstRemaining = length\n\n    takeWhile {  chunk ->\n        val copied = chunk.readUntilDelimitersImpl(delimiter1, delimiter2, dst, currentOffset, dstRemaining)\n        currentOffset += copied\n        dstRemaining -= copied\n        !chunk.canRead() && dstRemaining > 0\n    }\n\n    return currentOffset - offset\n}\n\n/**\n * Copies to [dst] output until the specified [delimiter] occurred.\n * @return number of bytes copied\n */\npublic fun Input.readUntilDelimiter(delimiter: Byte, dst: Output): Long {\n    var copiedTotal = 0L\n    takeWhile { chunk ->\n        val copied = chunk.readUntilDelimiterImpl(delimiter, dst)\n        copiedTotal += copied\n        !chunk.canRead()\n    }\n\n    return copiedTotal\n}\n\n/**\n * Copies to [dst] output until one of the specified delimiters\n * [delimiter1] or [delimiter2] occurred.\n * @return number of bytes copied\n */\npublic fun Input.readUntilDelimiters(delimiter1: Byte, delimiter2: Byte, dst: Output): Long {\n    var copiedTotal = 0L\n\n    takeWhile { chunk ->\n        val copied = chunk.readUntilDelimitersImpl(delimiter1, delimiter2, dst)\n        copiedTotal += copied\n        !chunk.canRead()\n    }\n\n    return copiedTotal\n}\n\ninternal expect fun Buffer.discardUntilDelimiterImpl(delimiter: Byte): Int\n\ninternal fun discardUntilDelimiterImplMemory(buffer: Buffer, delimiter: Byte): Int {\n    val start = buffer.readPosition\n    var i = start\n    val limit = buffer.writePosition\n    val memory = buffer.memory\n\n    while (i < limit) {\n        if (memory[i] == delimiter) break\n        i++\n    }\n\n    buffer.discardUntilIndex(i)\n    return i - start\n}\n\ninternal expect fun Buffer.discardUntilDelimitersImpl(delimiter1: Byte, delimiter2: Byte): Int\n\ninternal fun discardUntilDelimitersImplMemory(buffer: Buffer, delimiter1: Byte, delimiter2: Byte): Int {\n    val start = buffer.readPosition\n    var i = start\n    val limit = buffer.writePosition\n    val memory = buffer.memory\n\n    while (i < limit) {\n        val v = memory[i]\n        if (v == delimiter1 || v == delimiter2) break\n        i++\n    }\n\n    buffer.discardUntilIndex(i)\n    return i - start\n}\n\ninternal expect fun Buffer.readUntilDelimiterImpl(\n    delimiter: Byte,\n                                                    dst: ByteArray, offset: Int, length: Int): Int\n\ninternal expect fun Buffer.readUntilDelimitersImpl(\n    delimiter1: Byte, delimiter2: Byte,\n    dst: ByteArray, offset: Int, length: Int): Int\n\ninternal expect fun Buffer.readUntilDelimiterImpl(\n    delimiter: Byte,\n    dst: Output): Int\n\ninternal expect fun Buffer.readUntilDelimitersImpl(\n    delimiter1: Byte, delimiter2: Byte,\n    dst: Output): Int\n\ninternal inline fun Buffer.copyUntil(predicate: (Byte) -> Boolean, dst: ByteArray, offset: Int, length: Int): Int {\n    val readPosition = readPosition\n    var end = minOf(writePosition, readPosition + length)\n    val memory = memory\n    for (index in readPosition until end) {\n        if (predicate(memory.loadAt(index))) {\n            end = index\n            break\n        }\n    }\n\n    val copySize = end - readPosition\n    memory.loadByteArray(readPosition, dst, offset, copySize)\n    return copySize\n}\n\ninternal inline fun Buffer.copyUntil(predicate: (Byte) -> Boolean, dst: Output): Int {\n    var index = readPosition\n    val end = writePosition\n    val memory = memory\n    do {\n        if (index == end || predicate(memory.loadAt(index))) {\n            break\n        }\n        index++\n    } while (true)\n\n    val size = index - readPosition\n    dst.writeFully(this, size)\n    return size\n}\n\n","package io.ktor.utils.io.core\n\nimport io.ktor.utils.io.charsets.*\nimport io.ktor.utils.io.core.internal.*\n\n@Suppress(\"NOTHING_TO_INLINE\")\npublic inline fun String.toByteArray(charset: Charset = Charsets.UTF_8): ByteArray =\n    charset.newEncoder().encodeToByteArray(this, 0, length)\n\n/**\n * Create an instance of [String] from the specified [bytes] range starting at [offset] and bytes [length]\n * interpreting characters in the specified [charset].\n */\n@Suppress(\"FunctionName\")\npublic expect fun String(\n    bytes: ByteArray,\n    offset: Int = 0,\n    length: Int = bytes.size,\n    charset: Charset = Charsets.UTF_8\n): String\n\n/**\n * Read a string line considering optionally specified [estimate] but up to optional [limit] characters length\n * (does fail once limit exceeded) or return `null` if the packet is empty\n */\npublic fun ByteReadPacket.readUTF8Line(estimate: Int = 16, limit: Int = Int.MAX_VALUE): String? {\n    if (isEmpty) return null\n    val sb = StringBuilder(estimate)\n    return if (readUTF8LineTo(sb, limit)) sb.toString() else null\n}\n\n/**\n * Read a string line considering optionally specified [estimate] but up to optional [limit] characters length\n * (does fail once limit exceeded) or return `null` if the packet is empty\n */\npublic fun Input.readUTF8Line(estimate: Int = 16, limit: Int = Int.MAX_VALUE): String? {\n    val sb = StringBuilder(estimate)\n    return if (readUTF8LineTo(sb, limit)) sb.toString() else null\n}\n\n/**\n * Read UTF-8 line and append all line characters to [out] except line endings. Does support CR, LF and CR+LF\n * @return `true` if some characters were appended or line ending reached (empty line) or `false` if packet\n * if empty\n */\npublic fun Input.readUTF8LineTo(out: Appendable, limit: Int): Boolean {\n    var decoded = 0\n    var size = 1\n    var cr = false\n    var end = false\n\n    takeWhileSize { buffer ->\n        var skip = 0\n        size = buffer.decodeUTF8 { ch ->\n            when (ch) {\n                '\\r' -> {\n                    if (cr) {\n                        end = true\n                        return@decodeUTF8 false\n                    }\n                    cr = true\n                    true\n                }\n                '\\n' -> {\n                    end = true\n                    skip = 1\n                    false\n                }\n                else -> {\n                    if (cr) {\n                        end = true\n                        return@decodeUTF8 false\n                    }\n\n                    if (decoded == limit) bufferLimitExceeded(limit)\n                    decoded++\n                    out.append(ch)\n                    true\n                }\n            }\n        }\n\n        if (skip > 0) {\n            buffer.discardExact(skip)\n        }\n\n        if (end) 0 else size.coerceAtLeast(1)\n    }\n\n    if (size > 1) prematureEndOfStream(size)\n\n    return decoded > 0 || !endOfInput\n}\n\n/**\n * Reads UTF-8 characters until one of the specified [delimiters] found, [limit] exceeded or end of stream encountered\n *\n * @throws BufferLimitExceededException\n * @returns a string of characters read before delimiter\n */\npublic fun Input.readUTF8UntilDelimiter(delimiters: String, limit: Int = Int.MAX_VALUE): String {\n    return buildString {\n        readUTF8UntilDelimiterTo(this, delimiters, limit)\n    }\n}\n\n/**\n * Reads UTF-8 characters to [out] buffer until one of the specified [delimiters] found, [limit] exceeded\n * or end of stream encountered\n *\n * @throws BufferLimitExceededException\n * @returns number of characters copied (possibly zero)\n */\npublic fun Input.readUTF8UntilDelimiterTo(out: Appendable, delimiters: String, limit: Int = Int.MAX_VALUE): Int {\n    var decoded = 0\n    var delimiter = false\n\n    takeWhile { buffer ->\n        buffer.decodeASCII { ch ->\n            if (ch in delimiters) {\n                delimiter = true\n                false\n            } else {\n                if (decoded == limit) bufferLimitExceeded(limit)\n                decoded++\n                out.append(ch)\n                true\n            }\n        }\n    }\n\n    if (!delimiter) {\n        decoded = readUTF8UntilDelimiterToSlowUtf8(out, delimiters, limit, decoded)\n    }\n\n    return decoded\n}\n\n/**\n * Reads UTF-8 characters to [out] buffer until one of the specified [delimiters] found, [limit] exceeded\n * or end of stream encountered\n *\n * @throws BufferLimitExceededException\n * @returns number of characters copied (possibly zero)\n */\npublic fun Input.readUTF8UntilDelimiterTo(out: Output, delimiters: String, limit: Int = Int.MAX_VALUE): Int {\n    val delimitersCount = delimiters.length\n    if (delimitersCount == 1 && delimiters[0].isAsciiChar()) {\n        return readUntilDelimiter(delimiters[0].toByte(), out).toInt()\n    } else if (delimitersCount == 2 && delimiters[0].isAsciiChar() && delimiters[1].isAsciiChar()) {\n        return readUntilDelimiters(delimiters[0].toByte(), delimiters[1].toByte(), out).toInt()\n    }\n\n    return readUTFUntilDelimiterToSlowAscii(delimiters, limit, out)\n}\n\n@Suppress(\"unused\", \"DEPRECATION_ERROR\")\n@Deprecated(\"Use Output version instead\", level = DeprecationLevel.HIDDEN)\npublic fun Input.readUTF8UntilDelimiterTo(out: BytePacketBuilderBase, delimiters: String, limit: Int = Int.MAX_VALUE): Int {\n    return readUTF8UntilDelimiterTo(out as Output, delimiters, limit)\n}\n\n/**\n * Read exactly [n] bytes (consumes all remaining if [n] is not specified but up to [Int.MAX_VALUE] bytes).\n * Does fail if not enough bytes remaining.\n */\npublic fun ByteReadPacket.readBytes(\n    n: Int = remaining.coerceAtMostMaxIntOrFail(\"Unable to convert to a ByteArray: packet is too big\")\n): ByteArray = when {\n    n != 0 -> ByteArray(n).also { readFully(it, 0, n) }\n    else -> EmptyByteArray\n}\n\n/**\n * Reads exactly [n] bytes from the input or fails if not enough bytes available.\n */\npublic fun Input.readBytes(n: Int): ByteArray = readBytesOf(n, n)\n\n/**\n * Reads all remaining bytes from the input\n */\npublic fun Input.readBytes(): ByteArray = readBytesOf()\n\n/**\n * Reads at least [min] but no more than [max] bytes from the input to a new byte array\n * @throws EOFException if not enough bytes available to get [min] bytes\n */\npublic fun Input.readBytesOf(min: Int = 0, max: Int = Int.MAX_VALUE): ByteArray = if (min == max && min == 0) {\n    EmptyByteArray\n} else if (min == max) {\n    ByteArray(min).also { readFully(it, 0, min) }\n} else {\n    var array = ByteArray(max.toLong().coerceAtMost(sizeEstimate()).coerceAtLeast(min.toLong()).toInt())\n    var size = 0\n\n    while (size < max) {\n        val partSize = minOf(max, array.size) - size\n        val rc = readAvailable(array, size, partSize)\n        if (rc <= 0) break\n        size += rc\n        if (array.size == size) {\n            array = array.copyOf(size * 2)\n        }\n    }\n\n    if (size < min) {\n        throw EOFException(\"Not enough bytes available to read $min bytes: ${min - size} more required\")\n    }\n\n    if (size == array.size) array else array.copyOf(size)\n}\n\n/**\n * Reads at most [max] characters decoding bytes with specified [decoder]. Extra character bytes will remain unconsumed\n * @return number of characters copied to [out]\n */\n@Deprecated(\n    \"Use CharsetDecoder.decode instead\",\n    ReplaceWith(\"decoder.decode(this, out, max)\", \"io.ktor.utils.io.charsets.decode\"),\n    level = DeprecationLevel.ERROR\n)\npublic fun Input.readText(out: Appendable, decoder: CharsetDecoder, max: Int = Int.MAX_VALUE): Int {\n    return decoder.decode(this, out, max)\n}\n\n/**\n * Reads at most [max] characters decoding bytes with specified [charset]. Extra character bytes will remain unconsumed\n * @return number of characters copied to [out]\n */\npublic fun Input.readText(out: Appendable, charset: Charset = Charsets.UTF_8, max: Int = Int.MAX_VALUE): Int {\n    return charset.newDecoder().decode(this, out, max)\n}\n\n/**\n * Reads at most [max] characters decoding bytes with specified [decoder]. Extra character bytes will remain unconsumed\n * @return a decoded string\n */\n@Deprecated(\n    \"Use CharsetDecoder.decode instead\",\n    ReplaceWith(\"decoder.decode(this, max)\", \"io.ktor.utils.io.charsets.decode\")\n)\npublic fun Input.readText(decoder: CharsetDecoder, max: Int = Int.MAX_VALUE): String {\n    return decoder.decode(this, max)\n}\n\n/**\n * Reads at most [max] characters decoding bytes with specified [charset]. Extra character bytes will remain unconsumed\n * @return a decoded string\n */\npublic fun Input.readText(charset: Charset = Charsets.UTF_8, max: Int = Int.MAX_VALUE): String {\n    return charset.newDecoder().decode(this, max)\n}\n\n/**\n * Reads at most [max] characters decoding bytes with specified [charset]. Extra character bytes will remain unconsumed\n * @return a decoded string\n */\npublic fun Buffer.readText(charset: Charset = Charsets.UTF_8, max: Int = Int.MAX_VALUE): String = buildString {\n    charset.newDecoder().decodeBuffer(this@readText, this, true, max)\n}\n\n/**\n * Read exactly [n] characters interpreting bytes in the specified [charset].\n */\n@Deprecated(\n    \"Use readTextExactCharacters instead.\",\n    ReplaceWith(\"readTextExactCharacters(n, charset)\")\n)\npublic fun Input.readTextExact(charset: Charset = Charsets.UTF_8, n: Int): String {\n    return readTextExactCharacters(n, charset)\n}\n\n/**\n * Read exactly [charactersCount] characters interpreting bytes in the specified [charset].\n */\npublic fun Input.readTextExactCharacters(charactersCount: Int, charset: Charset = Charsets.UTF_8): String {\n    val s = readText(charset, charactersCount)\n    if (s.length < charactersCount) {\n        prematureEndOfStreamToReadChars(charactersCount)\n    }\n    return s\n}\n\n/**\n * Read exactly the specified number of [bytes]\n * interpreting bytes in the specified [charset] (optional, UTF-8 by default).\n */\n@Deprecated(\"Parameters order is changed.\", ReplaceWith(\"readTextExactBytes(bytes, charset)\"))\npublic fun Input.readTextExactBytes(charset: Charset = Charsets.UTF_8, bytes: Int): String {\n    return readTextExactBytes(bytes, charset)\n}\n\n/**\n * Read exactly [bytesCount] interpreting bytes in the specified [charset] (optional, UTF-8 by default).\n */\npublic fun Input.readTextExactBytes(bytesCount: Int, charset: Charset = Charsets.UTF_8): String {\n    return charset.newDecoder().decodeExactBytes(this, inputLength = bytesCount)\n}\n\n/**\n * Writes [text] characters in range \\[[fromIndex] .. [toIndex]) with the specified [encoder]\n */\n@Deprecated(\n    \"Use the implementation with Charset instead\",\n    ReplaceWith(\"writeText(text, fromIndex, toIndex, encoder.charset)\", \"io.ktor.utils.io.charsets.charset\"),\n    level = DeprecationLevel.ERROR\n)\npublic fun Output.writeText(text: CharSequence, fromIndex: Int = 0, toIndex: Int = text.length, encoder: CharsetEncoder) {\n    encoder.encodeToImpl(this, text, fromIndex, toIndex)\n}\n\n/**\n * Writes [text] characters in range \\[[fromIndex] .. [toIndex]) with the specified [charset]\n */\npublic fun Output.writeText(\n    text: CharSequence,\n    fromIndex: Int = 0,\n    toIndex: Int = text.length,\n    charset: Charset = Charsets.UTF_8\n) {\n    if (charset === Charsets.UTF_8) {\n        return writeTextUtf8(text, fromIndex, toIndex)\n    }\n\n    charset.newEncoder().encodeToImpl(this, text, fromIndex, toIndex)\n}\n\n/**\n * Writes [text] characters in range \\[[fromIndex] .. [toIndex]) with the specified [charset]\n */\npublic fun Output.writeText(\n    text: CharArray,\n    fromIndex: Int = 0,\n    toIndex: Int = text.size,\n    charset: Charset = Charsets.UTF_8\n) {\n    if (charset === Charsets.UTF_8) {\n        return writeTextUtf8(CharArraySequence(text, 0, text.size), fromIndex, toIndex)\n    }\n\n    charset.newEncoder().encode(text, fromIndex, toIndex, this)\n}\n\nprivate fun Output.writeTextUtf8(text: CharSequence, fromIndex: Int, toIndex: Int) {\n    var index = fromIndex\n    writeWhileSize(1) { buffer ->\n        val memory = buffer.memory\n        val dstOffset = buffer.writePosition\n        val dstLimit = buffer.limit\n\n        val (characters, bytes) = memory.encodeUTF8(text, index, toIndex, dstOffset, dstLimit)\n\n        index += characters.toInt()\n        buffer.commitWritten(bytes.toInt())\n\n        when {\n            characters.toInt() == 0 && index < toIndex -> 8\n            index < toIndex -> 1\n            else -> 0\n        }\n    }\n}\n\ninternal expect fun String.getCharsInternal(dst: CharArray, dstOffset: Int)\n\n\n@Suppress(\"NOTHING_TO_INLINE\")\nprivate inline fun Char.isAsciiChar() = toInt() <= 0x7f\n\nprivate fun Input.readUTFUntilDelimiterToSlowAscii(delimiters: String, limit: Int, out: Output): Int {\n    var decoded = 0\n    var delimiter = false\n\n    takeWhile { buffer ->\n        val before = buffer.readRemaining\n\n        val rc = buffer.decodeASCII { ch ->\n            if (ch in delimiters) {\n                delimiter = true\n                false\n            } else {\n                if (decoded == limit) bufferLimitExceeded(limit)\n                decoded++\n                true\n            }\n        }\n\n        val delta = before - buffer.readRemaining\n        if (delta > 0) {\n            buffer.rewind(delta)\n            out.writeFully(buffer, delta)\n        }\n\n        rc\n    }\n\n    if (!delimiter && !endOfInput) {\n        decoded = readUTF8UntilDelimiterToSlowUtf8(out, delimiters, limit, decoded)\n    }\n\n    return decoded\n}\n\nprivate fun Input.readUTF8UntilDelimiterToSlowUtf8(\n    out: Output,\n    delimiters: String,\n    limit: Int,\n    decoded0: Int\n): Int {\n    var decoded = decoded0\n    var size = 1\n\n    takeWhileSize { buffer ->\n        val before = buffer.readRemaining\n\n        size = buffer.decodeUTF8 { ch ->\n            if (ch in delimiters) {\n                false\n            } else {\n                if (decoded == limit) {\n                    bufferLimitExceeded(limit)\n                }\n                decoded++\n                true\n            }\n        }\n\n        val delta = before - buffer.readRemaining\n        if (delta > 0) {\n            buffer.rewind(delta)\n            out.writeFully(buffer, delta)\n        }\n\n        size = if (size == -1) 0 else size.coerceAtLeast(1)\n        size\n    }\n\n    if (size > 1) prematureEndOfStream(size)\n\n    return decoded\n}\n\nprivate fun Input.readUTF8UntilDelimiterToSlowUtf8(\n    out: Appendable,\n    delimiters: String,\n    limit: Int,\n    decoded0: Int\n): Int {\n    var decoded = decoded0\n    var size = 1\n\n    takeWhileSize { buffer ->\n        size = buffer.decodeUTF8 { ch ->\n            if (ch in delimiters) {\n                false\n            } else {\n                if (decoded == limit) {\n                    bufferLimitExceeded(limit)\n                }\n                decoded++\n                out.append(ch)\n                true\n            }\n        }\n\n        size = if (size == -1) 0 else size.coerceAtLeast(1)\n        size\n    }\n\n    if (size > 1) prematureEndOfStream(size)\n\n    return decoded\n}\n\nprivate fun bufferLimitExceeded(limit: Int): Nothing {\n    throw BufferLimitExceededException(\"Too many characters before delimiter: limit $limit exceeded\")\n}\n\n@PublishedApi\ninternal fun prematureEndOfStream(size: Int): Nothing =\n    throw EOFException(\"Premature end of stream: expected $size bytes\")\n\n@PublishedApi\ninternal fun prematureEndOfStream(size: Long): Nothing =\n    throw EOFException(\"Premature end of stream: expected $size bytes\")\n\nprivate fun prematureEndOfStreamToReadChars(charactersCount: Int): Nothing =\n    throw EOFException(\"Not enough input bytes to read $charactersCount characters.\")\n","package io.ktor.utils.io.core.internal\n\nimport kotlinx.atomicfu.*\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.bits.DefaultAllocator\nimport io.ktor.utils.io.concurrent.*\nimport io.ktor.utils.io.core.*\nimport io.ktor.utils.io.pool.*\n\n@DangerousInternalIoApi\npublic open class ChunkBuffer internal constructor(memory: Memory, origin: ChunkBuffer?) : Buffer(memory) {\n    init {\n        require(origin !== this) { \"A chunk couldn't be a view of itself.\" }\n    }\n\n    private val nextRef: AtomicRef<ChunkBuffer?> = atomic(null)\n    private val refCount = atomic(1)\n\n    /**\n     * Reference to an origin buffer view this was copied from\n     */\n    public var origin: ChunkBuffer? by shared(origin)\n        private set\n\n    /**\n     * Reference to next buffer view. Useful to chain multiple views.\n     * @see appendNext\n     * @see cleanNext\n     */\n    public var next: ChunkBuffer? get() = nextRef.value\n        set(newValue) {\n            if (newValue == null) {\n                cleanNext()\n            } else {\n                appendNext(newValue)\n            }\n        }\n\n    public val referenceCount: Int get() = refCount.value\n\n    private fun appendNext(chunk: ChunkBuffer) {\n        if (!nextRef.compareAndSet(null, chunk)) {\n            throw IllegalStateException(\"This chunk has already a next chunk.\")\n        }\n    }\n\n    public fun cleanNext(): ChunkBuffer? {\n        return nextRef.getAndSet(null)\n    }\n\n    override fun duplicate(): ChunkBuffer = (origin ?: this).let { newOrigin ->\n        newOrigin.acquire()\n        ChunkBuffer(memory, newOrigin).also { copy ->\n            duplicateTo(copy)\n        }\n    }\n\n    public open fun release(pool: ObjectPool<ChunkBuffer>) {\n        if (release()) {\n            val origin = origin\n            if (origin != null) {\n                unlink()\n                origin.release(pool)\n            } else {\n                pool.recycle(this)\n            }\n        }\n    }\n\n    internal fun unlink() {\n        if (!refCount.compareAndSet(0, -1)) {\n            throw IllegalStateException(\"Unable to unlink: buffer is in use.\")\n        }\n\n        cleanNext()\n        origin = null\n    }\n\n    /**\n     * Increase ref-count. May fail if already released.\n     */\n    internal fun acquire() {\n        refCount.update { old ->\n            if (old <= 0) throw IllegalStateException(\"Unable to acquire chunk: it is already released.\")\n            old + 1\n        }\n    }\n\n    /**\n     * Invoked by a pool before return the instance to a user.\n     */\n    internal fun unpark() {\n        refCount.update { old ->\n            if (old < 0) {\n                throw IllegalStateException(\"This instance is already disposed and couldn't be borrowed.\")\n            }\n            if (old > 0) {\n                throw IllegalStateException(\"This instance is already in use but somehow appeared in the pool.\")\n            }\n\n            1\n        }\n    }\n\n    /**\n     * Release ref-count.\n     * @return `true` if the last usage was released\n     */\n    internal fun release(): Boolean {\n        return refCount.updateAndGet { old ->\n            if (old <= 0) throw IllegalStateException(\"Unable to release: it is already released.\")\n            old - 1\n        } == 0\n    }\n\n    final override fun reset() {\n        require(origin == null) { \"Unable to reset buffer with origin\" }\n\n        super.reset()\n        @Suppress(\"DEPRECATION\")\n        attachment = null\n        nextRef.value = null\n    }\n\n    public companion object {\n        public val Pool: ObjectPool<ChunkBuffer> = object : ObjectPool<ChunkBuffer> {\n            override val capacity: Int\n                get() = DefaultChunkedBufferPool.capacity\n\n            override fun borrow(): ChunkBuffer {\n                return DefaultChunkedBufferPool.borrow()\n            }\n\n            @Suppress(\"DEPRECATION\")\n            override fun recycle(instance: ChunkBuffer) {\n                if (instance !is IoBuffer) {\n                    throw IllegalArgumentException(\"Only IoBuffer instances can be recycled.\")\n                }\n\n                DefaultChunkedBufferPool.recycle(instance)\n            }\n\n            override fun dispose() {\n                DefaultChunkedBufferPool.dispose()\n            }\n        }\n\n        @Suppress(\"DEPRECATION\")\n        public val Empty: ChunkBuffer get() = IoBuffer.Empty\n\n        /**\n         * A pool that always returns [ChunkBuffer.Empty]\n         */\n        public val EmptyPool: ObjectPool<ChunkBuffer> = object : ObjectPool<ChunkBuffer> {\n            override val capacity: Int get() = 1\n\n            override fun borrow() = Empty\n\n            override fun recycle(instance: ChunkBuffer) {\n                require(instance === ChunkBuffer.Empty) { \"Only ChunkBuffer.Empty instance could be recycled.\" }\n            }\n\n            override fun dispose() {\n            }\n        }\n\n        @Suppress(\"DEPRECATION\")\n        internal val NoPool: ObjectPool<ChunkBuffer> = object : NoPoolImpl<ChunkBuffer>() {\n            override fun borrow(): ChunkBuffer {\n                return IoBuffer(DefaultAllocator.alloc(DEFAULT_BUFFER_SIZE), null)\n            }\n\n            override fun recycle(instance: ChunkBuffer) {\n                if (instance !is IoBuffer) {\n                    throw IllegalArgumentException(\"Only IoBuffer instances can be recycled.\")\n                }\n\n                DefaultAllocator.free(instance.memory)\n            }\n        }\n\n        internal val NoPoolManuallyManaged: ObjectPool<ChunkBuffer> = object : NoPoolImpl<ChunkBuffer>() {\n            override fun borrow(): ChunkBuffer {\n                throw UnsupportedOperationException(\"This pool doesn't support borrow\")\n            }\n\n            override fun recycle(instance: ChunkBuffer) {\n                // do nothing: manually managed objects should be disposed manually\n            }\n        }\n    }\n}\n\n\n/**\n * @return `true` if and only if the are no buffer views that share the same actual buffer. This actually does\n * refcount and only work guaranteed if other views created/not created via [Buffer.duplicate] function.\n * One can instantiate multiple buffers with the same buffer and this function will return `true` in spite of\n * the fact that the buffer is actually shared.\n */\ninternal fun ChunkBuffer.isExclusivelyOwned(): Boolean = referenceCount == 1\n","@file:Suppress(\"KDocMissingDocumentation\")\n\npackage io.ktor.utils.io.core.internal\n\nimport io.ktor.utils.io.core.*\nimport kotlin.jvm.*\nimport kotlin.native.concurrent.*\n\n/**\n * API marked with this annotation is internal and extremely fragile and not intended to be used by library users.\n * Such API could be changed without notice including rename, removal and behaviour change.\n * Also using API marked with this annotation could cause data loss or any other damage.\n */\n@Suppress(\"DEPRECATION\")\n@RequiresOptIn(level = RequiresOptIn.Level.ERROR)\n@Experimental(level = Experimental.Level.ERROR)\npublic annotation class DangerousInternalIoApi\n\n@DangerousInternalIoApi\npublic fun ByteReadPacket.`$unsafeAppend$`(builder: BytePacketBuilder) {\n    val builderHead = builder.stealAll() ?: return\n    val builderSize = builder.size\n\n    if (builderSize <= PACKET_MAX_COPY_SIZE && builderHead.next == null && tryWriteAppend(builderHead)) {\n        builder.afterBytesStolen()\n        return\n    }\n\n    append(builderHead)\n}\n\ninternal fun ByteReadPacket.unsafeAppend(builder: BytePacketBuilder): Int {\n    val builderSize = builder.size\n    val builderHead = builder.stealAll() ?: return 0\n\n    if (builderSize <= PACKET_MAX_COPY_SIZE && builderHead.next == null && tryWriteAppend(builderHead)) {\n        builder.afterBytesStolen()\n        return builderSize\n    }\n\n    append(builderHead)\n    return builderSize\n}\n\n\n@Suppress(\"DEPRECATION\", \"UNUSED\")\n@JvmName(\"prepareReadFirstHead\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\npublic fun Input.prepareReadFirstHeadOld(minSize: Int): IoBuffer? {\n    return prepareReadFirstHead(minSize) as IoBuffer?\n}\n\n@DangerousInternalIoApi\npublic fun Input.prepareReadFirstHead(minSize: Int): ChunkBuffer? {\n    if (this is AbstractInput) {\n        return prepareReadHead(minSize)\n    }\n    if (this is ChunkBuffer) {\n        return if (canRead()) this else null\n    }\n\n    return prepareReadHeadFallback(minSize)\n}\n\nprivate fun Input.prepareReadHeadFallback(minSize: Int): ChunkBuffer? {\n    if (endOfInput) return null\n\n    val buffer = ChunkBuffer.Pool.borrow()\n    val copied = peekTo(\n        buffer.memory,\n        buffer.writePosition.toLong(),\n        0L,\n        minSize.toLong(),\n        buffer.writeRemaining.toLong()\n    ).toInt()\n    buffer.commitWritten(copied)\n\n    if (copied < minSize) {\n        prematureEndOfStream(minSize)\n    }\n\n    return buffer\n}\n\n@Suppress(\"UNUSED\", \"DEPRECATION\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\npublic fun Input.completeReadHead(current: IoBuffer) {\n    completeReadHead(current)\n}\n\n@DangerousInternalIoApi\npublic fun Input.completeReadHead(current: ChunkBuffer) {\n    if (current === this) {\n        return\n    }\n    if (this is AbstractInput) {\n        if (!current.canRead()) {\n            ensureNext(current)\n        } else if (current.endGap < Buffer.ReservedSize) {\n            fixGapAfterRead(current)\n        } else {\n            headPosition = current.readPosition\n        }\n        return\n    }\n\n    completeReadHeadFallback(current)\n}\n\nprivate fun Input.completeReadHeadFallback(current: ChunkBuffer) {\n    val discardAmount = current.capacity - current.writeRemaining - current.readRemaining\n    discardExact(discardAmount)\n    current.release(ChunkBuffer.Pool)\n}\n\n@Suppress(\"DEPRECATION\", \"UNUSED\")\n@JvmName(\"prepareReadNextHead\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\npublic fun Input.prepareReadNextHeadOld(current: IoBuffer): IoBuffer? {\n    return prepareReadNextHead(current) as IoBuffer?\n}\n\n@DangerousInternalIoApi\npublic fun Input.prepareReadNextHead(current: ChunkBuffer): ChunkBuffer? {\n    if (current === this) {\n        return if (canRead()) this else null\n    }\n    if (this is AbstractInput) {\n        return ensureNextHead(current)\n    }\n\n    return prepareNextReadHeadFallback(current)\n}\n\nprivate fun Input.prepareNextReadHeadFallback(current: ChunkBuffer): ChunkBuffer? {\n    val discardAmount = current.capacity - current.writeRemaining - current.readRemaining\n    discardExact(discardAmount)\n    current.resetForWrite()\n\n    if (endOfInput || peekTo(current) <= 0) {\n        current.release(ChunkBuffer.Pool)\n        return null\n    }\n\n    return current\n}\n\n@Suppress(\"DEPRECATION\", \"UNUSED\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\npublic fun Output.prepareWriteHead(capacity: Int, current: IoBuffer?): IoBuffer {\n    return prepareWriteHead(capacity, current) as IoBuffer\n}\n\n@DangerousInternalIoApi\npublic fun Output.prepareWriteHead(capacity: Int, current: ChunkBuffer?): ChunkBuffer {\n    if (this is AbstractOutput) {\n        if (current != null) {\n            afterHeadWrite()\n        }\n        return prepareWriteHead(capacity)\n    }\n\n    return prepareWriteHeadFallback(current)\n}\n\nprivate fun Output.prepareWriteHeadFallback(current: ChunkBuffer?): ChunkBuffer {\n    if (current != null) {\n        writeFully(current)\n        current.resetForWrite()\n        return current\n    }\n\n    return ChunkBuffer.Pool.borrow()\n}\n\n@Suppress(\"DEPRECATION\", \"UNUSED\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\npublic fun Output.afterHeadWrite(current: IoBuffer) {\n    return afterHeadWrite(current)\n}\n\n@DangerousInternalIoApi\npublic fun Output.afterHeadWrite(current: ChunkBuffer) {\n    if (this is AbstractOutput) {\n        return afterHeadWrite()\n    }\n\n    afterWriteHeadFallback(current)\n}\n\n@JvmField\n@SharedImmutable\ninternal val EmptyByteArray = ByteArray(0)\n\nprivate fun Output.afterWriteHeadFallback(current: ChunkBuffer) {\n    writeFully(current)\n    current.release(ChunkBuffer.Pool)\n}\n","package io.ktor.utils.io.errors\n\nimport io.ktor.utils.io.core.*\n\npublic expect open class IOException(message: String, cause: Throwable?) : Exception {\n    public constructor(message: String)\n}\n\npublic expect open class EOFException(message: String) : IOException\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\")\n@Deprecated(\"Not implemented.\", level = DeprecationLevel.ERROR)\npublic fun <R> TODO_ERROR(value: R): Nothing = TODO(\"Not implemented. Value is $value\")\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\")\n@Deprecated(\"Not implemented.\", level = DeprecationLevel.ERROR)\npublic fun TODO_ERROR(): Nothing = TODO(\"Not implemented.\")\n\ninternal fun checkPeekTo(destination: Buffer, offset: Int, min: Int, max: Int) {\n    io.ktor.utils.io.core.internal.require(offset >= 0) { \"offset shouldn't be negative: $offset.\" }\n    io.ktor.utils.io.core.internal.require(min >= 0) { \"min shouldn't be negative: $min.\" }\n    io.ktor.utils.io.core.internal.require(max >= min) { \"max should't be less than min: max = $max, min = $min.\" }\n    io.ktor.utils.io.core.internal.require(min <= destination.writeRemaining) {\n        \"Not enough free space in the destination buffer \" +\n            \"to write the specified minimum number of bytes: min = $min, free = ${destination.writeRemaining}.\"\n    }\n}\n\n@PublishedApi\ninternal fun incompatibleVersionError(): Nothing = throw Error(\n    \"This API is no longer supported. \" +\n        \"Please downgrade kotlinx-io or recompile your project/dependencies with new kotlinx-io.\"\n)\n","/*\n * Copyright 2014-2020 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n */\n\npackage io.ktor.utils.io.internal\n\nimport io.ktor.utils.io.*\nimport kotlinx.atomicfu.*\nimport kotlinx.coroutines.*\n\n/**\n * Exclusive slot for waiting.\n * Only one waiter allowed.\n *\n * TODO: replace [Job] -> [Continuation] when all coroutines problems are fixed.\n */\ninternal class AwaitingSlot {\n    private val suspension: AtomicRef<CompletableJob?> = atomic(null)\n\n    init {\n        makeShared()\n    }\n\n    /**\n     * Wait for other [sleep] or resume.\n     */\n    public suspend fun sleep() {\n        if (trySuspend()) {\n            return\n        }\n\n        resume()\n    }\n\n    /**\n     * Resume waiter.\n     */\n    public fun resume() {\n        suspension.getAndSet(null)?.complete()\n    }\n\n    /**\n     * Cancel waiter.\n     */\n    public fun cancel(cause: Throwable?) {\n        val continuation = suspension.getAndSet(null) ?: return\n\n        if (cause != null) {\n            continuation.completeExceptionally(cause)\n        } else {\n            continuation.complete()\n        }\n    }\n\n    private suspend fun trySuspend(): Boolean {\n        var suspended = false\n\n        val job = Job()\n        if (suspension.compareAndSet(null, job)) {\n            suspended = true\n            job.join()\n        }\n\n        return suspended\n    }\n\n}\n","package io.ktor.utils.io.internal\n\nimport io.ktor.utils.io.ByteChannelSequentialBase\nimport io.ktor.utils.io.close\nimport io.ktor.utils.io.core.internal.ChunkBuffer\n\ninternal suspend fun ByteChannelSequentialBase.joinToImpl(dst: ByteChannelSequentialBase, closeOnEnd: Boolean) {\n    copyToSequentialImpl(dst, Long.MAX_VALUE)\n    if (closeOnEnd) dst.close()\n}\n\n/**\n * Reads up to [limit] bytes from receiver channel and writes them to [dst] channel.\n * Closes [dst] channel if fails to read or write with cause exception.\n * @return a number of copied bytes\n */\ninternal suspend fun ByteChannelSequentialBase.copyToSequentialImpl(dst: ByteChannelSequentialBase, limit: Long): Long {\n    require(this !== dst)\n    if (closedCause != null) {\n        dst.close(closedCause)\n        return 0L\n    }\n\n    var remainingLimit = limit\n\n    while (remainingLimit > 0) {\n        if (!awaitInternalAtLeast1()) {\n            break\n        }\n        val transferred = transferTo(dst, remainingLimit)\n\n        val copied = if (transferred == 0L) {\n            val tail = copyToTail(dst, remainingLimit)\n            if (tail == 0L) {\n                break\n            }\n\n            tail\n        } else {\n            if (dst.availableForWrite == 0) {\n                dst.awaitAtLeastNBytesAvailableForWrite(1)\n            }\n\n            transferred\n        }\n\n        remainingLimit -= copied\n    }\n\n    return limit - remainingLimit\n}\n\nprivate suspend fun ByteChannelSequentialBase.copyToTail(dst: ByteChannelSequentialBase, limit: Long): Long {\n    val lastPiece = ChunkBuffer.Pool.borrow()\n    try {\n        lastPiece.resetForWrite(limit.coerceAtMost(lastPiece.capacity.toLong()).toInt())\n        val rc = readAvailable(lastPiece)\n        if (rc == -1) {\n            lastPiece.release(ChunkBuffer.Pool)\n            return 0\n        }\n\n        dst.writeFully(lastPiece)\n        return rc.toLong()\n    } finally {\n        lastPiece.release(ChunkBuffer.Pool)\n    }\n}\n","package io.ktor.utils.io.pool\n\nimport kotlinx.atomicfu.*\nimport io.ktor.utils.io.core.*\nimport kotlin.jvm.*\n\npublic interface ObjectPool<T : Any> : Closeable {\n    /**\n     * Pool capacity\n     */\n    public val capacity: Int\n\n    /**\n     * borrow an instance. Pool can recycle an old instance or create a new one\n     */\n    public fun borrow(): T\n\n    /**\n     * Recycle an instance. Should be recycled what was borrowed before otherwise could fail\n     */\n    public fun recycle(instance: T)\n\n    /**\n     * Dispose the whole pool. None of borrowed objects could be used after the pool gets disposed\n     * otherwise it can result in undefined behaviour\n     */\n    public fun dispose()\n\n    /**\n     * Does pool dispose\n     */\n    override fun close() {\n        dispose()\n    }\n}\n\n/**\n * A pool implementation of zero capacity that always creates new instances\n */\npublic abstract class NoPoolImpl<T : Any> : ObjectPool<T> {\n    override val capacity: Int\n        get() = 0\n\n    override fun recycle(instance: T) {\n    }\n\n    override fun dispose() {\n    }\n}\n\n/**\n * A pool that produces at most one instance\n */\npublic abstract class SingleInstancePool<T : Any> : ObjectPool<T> {\n    private val borrowed = atomic(0)\n    private val disposed = atomic(false)\n\n    @Volatile\n    private var instance: T? = null\n\n    /**\n     * Creates a new instance of [T]\n     */\n    protected abstract fun produceInstance(): T\n\n    /**\n     * Dispose [instance] and release it's resources\n     */\n    protected abstract fun disposeInstance(instance: T)\n\n    final override val capacity: Int get() = 1\n\n    final override fun borrow(): T {\n        borrowed.update {\n            if (it != 0) throw IllegalStateException(\"Instance is already consumed\")\n            1\n        }\n\n        val instance = produceInstance()\n        this.instance = instance\n\n        return instance\n    }\n\n    final override fun recycle(instance: T) {\n        if (this.instance !== instance) {\n            if (this.instance == null && borrowed.value != 0) {\n                throw IllegalStateException(\"Already recycled or an irrelevant instance tried to be recycled\")\n            }\n\n            throw IllegalStateException(\"Unable to recycle irrelevant instance\")\n        }\n\n        this.instance = null\n\n        if (!disposed.compareAndSet(false, true)) {\n            throw IllegalStateException(\"An instance is already disposed\")\n        }\n\n        disposeInstance(instance)\n    }\n\n    final override fun dispose() {\n        if (disposed.compareAndSet(false, true)) {\n            val instance = this.instance ?: return\n            this.instance = null\n\n            disposeInstance(instance)\n        }\n    }\n}\n\n/**\n * Default object pool implementation.\n */\npublic expect abstract class DefaultPool<T : Any>(capacity: Int) : ObjectPool<T> {\n    /**\n     * Pool capacity.\n     */\n    final override val capacity: Int\n\n    /**\n     * Creates a new instance of [T]\n     */\n    protected abstract fun produceInstance(): T\n\n    /**\n     * Dispose [instance] and release it's resources\n     */\n    protected open fun disposeInstance(instance: T)\n\n    /**\n     * Clear [instance]'s state before reuse: reset pointers, counters and so on\n     */\n    protected open fun clearInstance(instance: T): T\n\n    /**\n     * Validate [instance] of [T]. Could verify that the object has been borrowed from this pool\n     */\n    protected open fun validateInstance(instance: T)\n\n    final override fun borrow(): T\n\n    final override fun recycle(instance: T)\n\n    final override fun dispose()\n}\n\n/**\n * Borrows and instance of [T] from the pool, invokes [block] with it and finally recycles it\n */\n@Deprecated(\"Use useInstance instead\", ReplaceWith(\"useInstance(block)\"))\npublic inline fun <T : Any, R> ObjectPool<T>.useBorrowed(block: (T) -> R): R {\n    return useInstance(block)\n}\n\n/**\n * Borrows and instance of [T] from the pool, invokes [block] with it and finally recycles it\n */\npublic inline fun <T : Any, R> ObjectPool<T>.useInstance(block: (T) -> R): R {\n    val instance = borrow()\n    try {\n        return block(instance)\n    } finally {\n        recycle(instance)\n    }\n}\n\n",null,"package io.ktor.utils.io\n\nimport kotlinx.coroutines.*\nimport io.ktor.utils.io.internal.*\nimport io.ktor.utils.io.core.*\nimport org.khronos.webgl.*\n\n/**\n * Creates buffered channel for asynchronous reading and writing of sequences of bytes.\n */\npublic actual fun ByteChannel(autoFlush: Boolean): ByteChannel {\n    return ByteChannelJS(IoBuffer.Empty, autoFlush)\n}\n\n/**\n * Creates channel for reading from the specified byte array.\n */\npublic actual fun ByteReadChannel(content: ByteArray, offset: Int, length: Int): ByteReadChannel {\n    if (content.isEmpty()) return ByteReadChannel.Empty\n    val head = IoBuffer.Pool.borrow()\n    var tail = head\n\n    var start = offset\n    val end = start + length\n    while (true) {\n        tail.reserveEndGap(8)\n        val size = minOf(end - start, tail.writeRemaining)\n        (tail as Buffer).writeFully(content, start, size)\n        start += size\n\n        if (start == end) break\n        val current = tail\n        tail = IoBuffer.Pool.borrow()\n        current.next = tail\n    }\n\n    return ByteChannelJS(head, false).apply { close() }\n}\n\n/**\n * Creates channel for reading from the specified [ArrayBufferView]\n */\npublic fun ByteReadChannel(content: ArrayBufferView): ByteReadChannel {\n    if (content.byteLength == 0) return ByteReadChannel.Empty\n    val head = IoBuffer.Pool.borrow()\n    var tail = head\n\n    var start = 0\n    var remaining = content.byteLength - content.byteOffset\n    while (true) {\n        tail.reserveEndGap(8)\n        val size = minOf(remaining, tail.writeRemaining)\n        tail.writeFully(content, start, size)\n        start += size\n        remaining -= size\n\n        if (remaining == 0) break\n        tail = IoBuffer.Pool.borrow()\n    }\n\n    return ByteChannelJS(head, false).apply { close() }\n}\n\npublic actual suspend fun ByteReadChannel.joinTo(dst: ByteWriteChannel, closeOnEnd: Boolean) {\n    (this as ByteChannelSequentialBase).joinToImpl((dst as ByteChannelSequentialBase), closeOnEnd)\n}\n\n/**\n * Reads up to [limit] bytes from receiver channel and writes them to [dst] channel.\n * Closes [dst] channel if fails to read or write with cause exception.\n * @return a number of copied bytes\n */\npublic actual suspend fun ByteReadChannel.copyTo(dst: ByteWriteChannel, limit: Long): Long {\n    return (this as ByteChannelSequentialBase).copyToSequentialImpl((dst as ByteChannelSequentialBase), limit)\n}\n\ninternal class ByteChannelJS(initial: IoBuffer, autoFlush: Boolean) : ByteChannelSequentialBase(initial, autoFlush) {\n    private var attachedJob: Job? = null\n\n    @OptIn(InternalCoroutinesApi::class)\n    override fun attachJob(job: Job) {\n        attachedJob?.cancel()\n        attachedJob = job\n        job.invokeOnCompletion(onCancelling = true) { cause ->\n            attachedJob = null\n            if (cause != null) {\n                cancel(cause)\n            }\n        }\n    }\n\n    override suspend fun readAvailable(dst: ArrayBuffer, offset: Int, length: Int): Int {\n        return if (readable.isEmpty) {\n            readAvailableSuspend(dst, offset, length)\n        } else {\n            closedCause?.let { throw it }\n            readable.readAvailable(dst, offset, length)\n        }\n    }\n\n    private suspend fun readAvailableSuspend(dst: ArrayBuffer, offset: Int, length: Int): Int {\n        if (!await(1)) return -1\n        return readAvailable(dst, offset, length)\n    }\n\n    override suspend fun readFully(dst: ArrayBuffer, offset: Int, length: Int) {\n        if (availableForRead >= length) {\n            closedCause?.let { throw it }\n            readable.readFully(dst, offset, length)\n            return\n        }\n\n        return readFullySuspend(dst, offset, length)\n    }\n\n    private suspend fun readFullySuspend(dst: ArrayBuffer, offset: Int, length: Int) {\n        var start = offset\n        val end = offset + length\n        var remaining = length\n\n        while (start < end) {\n            val rc = readAvailable(dst, start, remaining)\n            if (rc == -1) throw EOFException(\"Premature end of stream: required $remaining more bytes\")\n            start += rc\n            remaining -= rc\n        }\n    }\n\n    override fun toString(): String = \"ByteChannel[$attachedJob, ${hashCode()}]\"\n}\n","/*\n * Copyright 2014-2020 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n */\n\npackage io.ktor.utils.io\n\nimport io.ktor.utils.io.core.*\nimport io.ktor.utils.io.core.internal.*\nimport kotlin.jvm.*\n\ninternal actual class ByteChannelSequentialBaseSharedState actual constructor() {\n    actual var closed: Boolean = false\n\n    actual var readByteOrder: ByteOrder = ByteOrder.BIG_ENDIAN\n\n    actual var writeByteOrder: ByteOrder = ByteOrder.BIG_ENDIAN\n\n    actual var totalBytesRead: Long = 0L\n\n    actual var totalBytesWritten: Long = 0L\n\n    actual var closedCause: Throwable? = null\n\n    actual var lastReadAvailable: Int = 0\n\n    actual var lastReadView: ChunkBuffer = ChunkBuffer.Empty\n}\n","package io.ktor.utils.io\n\nimport kotlin.coroutines.*\n\ninternal actual class Condition actual constructor(val predicate: () -> Boolean) {\n    private var cont: Continuation<Unit>? = null\n\n    actual fun check(): Boolean {\n        return predicate()\n    }\n\n    actual fun signal() {\n        val cont = cont\n        if (cont != null && predicate()) {\n            this.cont = null\n            cont.resume(Unit)\n        }\n    }\n\n    actual suspend fun await(block: () -> Unit) {\n        if (predicate()) return\n\n        return suspendCoroutine { c ->\n            cont = c\n            block()\n        }\n    }\n    actual suspend fun await() {\n        if (predicate()) return\n\n        return suspendCoroutine { c ->\n            cont = c\n        }\n    }\n}\n","/*\n * Copyright 2014-2020 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n */\n\npackage io.ktor.utils.io\n\n/**\n * Print exception stacktrace.\n */\npublic actual fun Throwable.printStack() {\n    @Suppress(\"UnsafeCastFromDynamic\")\n    println(asDynamic().stack)\n}\n","/*\n * Copyright 2014-2020 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n */\n\npackage io.ktor.utils.io\n\nimport io.ktor.utils.io.core.internal.*\n\n@DangerousInternalIoApi\npublic actual fun Any.preventFreeze() {\n}\n\n@DangerousInternalIoApi\npublic actual fun Any.makeShared() {\n}\n","@file:Suppress(\"NOTHING_TO_INLINE\")\n\npackage io.ktor.utils.io.bits\n\n/**\n * Reverse number's byte order\n */\npublic actual fun Short.reverseByteOrder(): Short = swap(this)\n\n/**\n * Reverse number's byte order\n */\npublic actual fun Int.reverseByteOrder(): Int = swap(this)\n\n/**\n * Reverse number's byte order\n */\npublic actual fun Long.reverseByteOrder(): Long = swap(this)\n\n/**\n * Reverse number's byte order\n */\npublic actual fun Float.reverseByteOrder(): Float = swap(this)\n\n/**\n * Reverse number's byte order\n */\npublic actual fun Double.reverseByteOrder(): Double = swap(this)\n\n\nprivate inline fun swap(s: Short): Short = (((s.toInt() and 0xff) shl 8) or ((s.toInt() and 0xffff) ushr 8)).toShort()\n\nprivate inline fun swap(s: Int): Int =\n    (swap((s and 0xffff).toShort()).toInt() shl 16) or (swap((s ushr 16).toShort()).toInt() and 0xffff)\n\nprivate inline fun swap(s: Long): Long =\n    (swap((s and 0xffffffff).toInt()).toLong() shl 32) or (swap((s ushr 32).toInt()).toLong() and 0xffffffff)\n\nprivate inline fun swap(s: Float): Float = Float.fromBits(swap(s.toRawBits()))\n\nprivate inline fun swap(s: Double): Double = Double.fromBits(swap(s.toRawBits()))\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\n\n/**\n * Returns a bit representation of the specified floating-point value as [Long]\n * according to the IEEE 754 floating-point \"double format\" bit layout.\n */\n@SinceKotlin(\"1.2\")\n@library(\"doubleToBits\")\npublic actual fun Double.toBits(): Long = definedExternally\n\n/**\n * Returns a bit representation of the specified floating-point value as [Long]\n * according to the IEEE 754 floating-point \"double format\" bit layout,\n * preserving `NaN` values exact layout.\n */\n@SinceKotlin(\"1.2\")\n@library(\"doubleToRawBits\")\npublic actual fun Double.toRawBits(): Long = definedExternally\n\n/**\n * Returns the [Double] value corresponding to a given bit representation.\n */\n@SinceKotlin(\"1.2\")\n@kotlin.internal.InlineOnly\npublic actual inline fun Double.Companion.fromBits(bits: Long): Double = js(\"Kotlin\").doubleFromBits(bits).unsafeCast<Double>()\n\n/**\n * Returns a bit representation of the specified floating-point value as [Int]\n * according to the IEEE 754 floating-point \"single format\" bit layout.\n *\n * Note that in Kotlin/JS [Float] range is wider than \"single format\" bit layout can represent,\n * so some [Float] values may overflow, underflow or loose their accuracy after conversion to bits and back.\n */\n@SinceKotlin(\"1.2\")\n@library(\"floatToBits\")\npublic actual fun Float.toBits(): Int = definedExternally\n\n/**\n * Returns a bit representation of the specified floating-point value as [Int]\n * according to the IEEE 754 floating-point \"single format\" bit layout,\n * preserving `NaN` values exact layout.\n *\n * Note that in Kotlin/JS [Float] range is wider than \"single format\" bit layout can represent,\n * so some [Float] values may overflow, underflow or loose their accuracy after conversion to bits and back.\n */\n@SinceKotlin(\"1.2\")\n@library(\"floatToRawBits\")\npublic actual fun Float.toRawBits(): Int = definedExternally\n\n/**\n * Returns the [Float] value corresponding to a given bit representation.\n */\n@SinceKotlin(\"1.2\")\n@kotlin.internal.InlineOnly\npublic actual inline fun Float.Companion.fromBits(bits: Int): Float = js(\"Kotlin\").floatFromBits(bits).unsafeCast<Float>()\n\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal inline fun Long(low: Int, high: Int) = js(\"Kotlin\").Long.fromBits(low, high).unsafeCast<Long>()\ninternal inline val Long.low: Int get() = this.asDynamic().getLowBits().unsafeCast<Int>()\ninternal inline val Long.high: Int get() = this.asDynamic().getHighBits().unsafeCast<Int>()\n","@file:Suppress(\"NOTHING_TO_INLINE\")\n\npackage io.ktor.utils.io.bits\n\nimport io.ktor.utils.io.core.*\nimport io.ktor.utils.io.core.internal.*\nimport org.khronos.webgl.*\n\nprivate val isLittleEndianPlatform = ByteOrder.nativeOrder() === ByteOrder.LITTLE_ENDIAN\n\n/**\n * Copies shorts integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic actual fun Memory.loadShortArray(\n    offset: Int,\n    destination: ShortArray,\n    destinationOffset: Int,\n    count: Int\n) {\n    val typed = Int16Array(view.buffer, view.byteOffset + offset, count)\n\n    if (isLittleEndianPlatform) {\n        // TODO investigate this implementation vs DataView.getInt16(...)\n        repeat(count) { index ->\n            destination[index + destinationOffset] = typed[index].reverseByteOrder()\n        }\n    } else {\n        repeat(count) { index ->\n            destination[index + destinationOffset] = typed[index]\n        }\n    }\n}\n\n/**\n * Copies shorts integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic actual fun Memory.loadShortArray(\n    offset: Long,\n    destination: ShortArray,\n    destinationOffset: Int,\n    count: Int\n) {\n    loadShortArray(offset.toIntOrFail(\"offset\"), destination, destinationOffset, count)\n}\n\n/**\n * Copies regular integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic actual fun Memory.loadIntArray(\n    offset: Int,\n    destination: IntArray,\n    destinationOffset: Int,\n    count: Int\n) {\n    val typed = Int32Array(view.buffer, view.byteOffset + offset, count)\n\n    if (isLittleEndianPlatform) {\n        repeat(count) { index ->\n            destination[index + destinationOffset] = typed[index].reverseByteOrder()\n        }\n    } else {\n        repeat(count) { index ->\n            destination[index + destinationOffset] = typed[index]\n        }\n    }\n}\n\n/**\n * Copies regular integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic actual fun Memory.loadIntArray(\n    offset: Long,\n    destination: IntArray,\n    destinationOffset: Int,\n    count: Int\n) {\n    loadIntArray(offset.toIntOrFail(\"offset\"), destination, destinationOffset, count)\n}\n\n/**\n * Copies regular integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic actual fun Memory.loadLongArray(\n    offset: Int,\n    destination: LongArray,\n    destinationOffset: Int,\n    count: Int\n) {\n    val typed = Int32Array(view.buffer, view.byteOffset + offset, count * 2)\n\n    if (isLittleEndianPlatform) {\n        for (index in 0 until count * 2 step 2) {\n            destination[index / 2 + destinationOffset] =\n                (typed[index + 1].reverseByteOrder().toLong() and 0xffffffffL) or\n                    (typed[index].reverseByteOrder().toLong() shl 32)\n        }\n    } else {\n        for (index in 0 until count * 2 step 2) {\n            destination[index / 2 + destinationOffset] = (typed[index].toLong() and 0xffffffffL) or\n                (typed[index + 1].toLong() shl 32)\n        }\n    }\n}\n\n/**\n * Copies regular integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic actual fun Memory.loadLongArray(\n    offset: Long,\n    destination: LongArray,\n    destinationOffset: Int,\n    count: Int\n) {\n    loadLongArray(offset.toIntOrFail(\"offset\"), destination, destinationOffset, count)\n}\n\n/**\n * Copies floating point numbers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic actual fun Memory.loadFloatArray(\n    offset: Int,\n    destination: FloatArray,\n    destinationOffset: Int,\n    count: Int\n) {\n    val typed = Float32Array(view.buffer, view.byteOffset + offset, count)\n\n    if (isLittleEndianPlatform) {\n        repeat(count) { index ->\n            destination[index + destinationOffset] = typed[index].reverseByteOrder()\n        }\n    } else {\n        repeat(count) { index ->\n            destination[index + destinationOffset] = typed[index]\n        }\n    }\n}\n\n/**\n * Copies floating point numbers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic actual fun Memory.loadFloatArray(\n    offset: Long,\n    destination: FloatArray,\n    destinationOffset: Int,\n    count: Int\n) {\n    loadFloatArray(offset.toIntOrFail(\"offset\"), destination, destinationOffset, count)\n}\n\n/**\n * Copies floating point numbers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic actual fun Memory.loadDoubleArray(\n    offset: Int,\n    destination: DoubleArray,\n    destinationOffset: Int,\n    count: Int\n) {\n    val typed = Float64Array(view.buffer, view.byteOffset + offset, count)\n\n    if (isLittleEndianPlatform) {\n        repeat(count) { index ->\n            destination[index + destinationOffset] = typed[index].reverseByteOrder()\n        }\n    } else {\n        repeat(count) { index ->\n            destination[index + destinationOffset] = typed[index]\n        }\n    }\n}\n\n/**\n * Copies floating point numbers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic actual fun Memory.loadDoubleArray(\n    offset: Long,\n    destination: DoubleArray,\n    destinationOffset: Int,\n    count: Int\n) {\n    loadDoubleArray(offset.toIntOrFail(\"offset\"), destination, destinationOffset, count)\n}\n\n/**\n * Copies shorts integers from from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic actual fun Memory.storeShortArray(\n    offset: Int,\n    source: ShortArray,\n    sourceOffset: Int,\n    count: Int\n) {\n    val typed = Int16Array(view.buffer, view.byteOffset + offset, count)\n\n    if (isLittleEndianPlatform) {\n        // TODO investigate this implementation vs DataView.getInt16(...)\n        repeat(count) { index ->\n            typed[index] = source[index + sourceOffset].reverseByteOrder()\n        }\n    } else {\n        repeat(count) { index ->\n            typed[index] = source[index + sourceOffset]\n        }\n    }\n}\n\n/**\n * Copies shorts integers from from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic actual fun Memory.storeShortArray(\n    offset: Long,\n    source: ShortArray,\n    sourceOffset: Int,\n    count: Int\n) {\n    storeShortArray(offset.toIntOrFail(\"offset\"), source, sourceOffset, count)\n}\n\n/**\n * Copies regular integers from from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic actual fun Memory.storeIntArray(\n    offset: Int,\n    source: IntArray,\n    sourceOffset: Int,\n    count: Int\n) {\n    val typed = Int32Array(view.buffer, view.byteOffset + offset, count)\n\n    if (isLittleEndianPlatform) {\n        repeat(count) { index ->\n            typed[index] = source[index + sourceOffset].reverseByteOrder()\n        }\n    } else {\n        repeat(count) { index ->\n            typed[index] = source[index + sourceOffset]\n        }\n    }\n}\n\n/**\n * Copies regular integers from from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic actual fun Memory.storeIntArray(\n    offset: Long,\n    source: IntArray,\n    sourceOffset: Int,\n    count: Int\n) {\n    storeIntArray(offset.toIntOrFail(\"offset\"), source, sourceOffset, count)\n}\n\n/**\n * Copies regular integers from from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic actual fun Memory.storeLongArray(\n    offset: Int,\n    source: LongArray,\n    sourceOffset: Int,\n    count: Int\n) {\n    val typed = Int32Array(view.buffer, view.byteOffset + offset, count * 2)\n\n    if (isLittleEndianPlatform) {\n        for (index in 0 until count * 2 step 2) {\n            val sourceIndex = index / 2 + sourceOffset\n            val sourceValue = source[sourceIndex]\n            typed[index] = (sourceValue ushr 32).toInt().reverseByteOrder()\n            typed[index + 1] = (sourceValue and 0xffffffffL).toInt().reverseByteOrder()\n        }\n    } else {\n        for (index in 0 until count * 2 step 2) {\n            val sourceIndex = index / 2 + sourceOffset\n            val sourceValue = source[sourceIndex]\n            typed[index] = (sourceValue ushr 32).toInt()\n            typed[index + 1] = (sourceValue and 0xffffffffL).toInt()\n        }\n    }\n}\n\n/**\n * Copies regular integers from from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic actual fun Memory.storeLongArray(\n    offset: Long,\n    source: LongArray,\n    sourceOffset: Int,\n    count: Int\n) {\n    storeLongArray(offset.toIntOrFail(\"offset\"), source, sourceOffset, count)\n}\n\n/**\n * Copies floating point numbers from from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic actual fun Memory.storeFloatArray(\n    offset: Int,\n    source: FloatArray,\n    sourceOffset: Int,\n    count: Int\n) {\n    val typed = Float32Array(view.buffer, view.byteOffset + offset, count)\n\n    if (isLittleEndianPlatform) {\n        repeat(count) { index ->\n            typed[index] = source[index + sourceOffset].reverseByteOrder()\n        }\n    } else {\n        repeat(count) { index ->\n            typed[index] = source[index + sourceOffset]\n        }\n    }\n}\n\n/**\n * Copies floating point numbers from from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic actual fun Memory.storeFloatArray(\n    offset: Long,\n    source: FloatArray,\n    sourceOffset: Int,\n    count: Int\n) {\n    storeFloatArray(offset.toIntOrFail(\"offset\"), source, sourceOffset, count)\n}\n\n/**\n * Copies floating point numbers from from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic actual fun Memory.storeDoubleArray(\n    offset: Int,\n    source: DoubleArray,\n    sourceOffset: Int,\n    count: Int\n) {\n    val typed = Float64Array(view.buffer, view.byteOffset + offset, count)\n\n    if (isLittleEndianPlatform) {\n        repeat(count) { index ->\n            typed[index] = source[index + sourceOffset].reverseByteOrder()\n        }\n    } else {\n        repeat(count) { index ->\n            typed[index] = source[index + sourceOffset]\n        }\n    }\n}\n\n/**\n * Copies floating point numbers from from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic actual fun Memory.storeDoubleArray(\n    offset: Long,\n    source: DoubleArray,\n    sourceOffset: Int,\n    count: Int\n) {\n    storeDoubleArray(offset.toIntOrFail(\"offset\"), source, sourceOffset, count)\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// NOTE: THIS FILE IS AUTO-GENERATED, DO NOT EDIT!\n// See github.com/kotlin/dukat for details\n\npackage org.khronos.webgl\n\nimport kotlin.js.*\nimport org.w3c.css.masking.*\nimport org.w3c.dom.*\nimport org.w3c.dom.clipboard.*\nimport org.w3c.dom.css.*\nimport org.w3c.dom.encryptedmedia.*\nimport org.w3c.dom.events.*\nimport org.w3c.dom.mediacapture.*\nimport org.w3c.dom.mediasource.*\nimport org.w3c.dom.parsing.*\nimport org.w3c.dom.pointerevents.*\nimport org.w3c.dom.svg.*\nimport org.w3c.dom.url.*\nimport org.w3c.fetch.*\nimport org.w3c.files.*\nimport org.w3c.notifications.*\nimport org.w3c.performance.*\nimport org.w3c.workers.*\nimport org.w3c.xhr.*\n\npublic external interface WebGLContextAttributes {\n    var alpha: Boolean? /* = true */\n        get() = definedExternally\n        set(value) = definedExternally\n    var depth: Boolean? /* = true */\n        get() = definedExternally\n        set(value) = definedExternally\n    var stencil: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n    var antialias: Boolean? /* = true */\n        get() = definedExternally\n        set(value) = definedExternally\n    var premultipliedAlpha: Boolean? /* = true */\n        get() = definedExternally\n        set(value) = definedExternally\n    var preserveDrawingBuffer: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n    var preferLowPowerToHighPerformance: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n    var failIfMajorPerformanceCaveat: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun WebGLContextAttributes(alpha: Boolean? = true, depth: Boolean? = true, stencil: Boolean? = false, antialias: Boolean? = true, premultipliedAlpha: Boolean? = true, preserveDrawingBuffer: Boolean? = false, preferLowPowerToHighPerformance: Boolean? = false, failIfMajorPerformanceCaveat: Boolean? = false): WebGLContextAttributes {\n    val o = js(\"({})\")\n    o[\"alpha\"] = alpha\n    o[\"depth\"] = depth\n    o[\"stencil\"] = stencil\n    o[\"antialias\"] = antialias\n    o[\"premultipliedAlpha\"] = premultipliedAlpha\n    o[\"preserveDrawingBuffer\"] = preserveDrawingBuffer\n    o[\"preferLowPowerToHighPerformance\"] = preferLowPowerToHighPerformance\n    o[\"failIfMajorPerformanceCaveat\"] = failIfMajorPerformanceCaveat\n    return o\n}\n\npublic external abstract class WebGLObject\n\n/**\n * Exposes the JavaScript [WebGLBuffer](https://developer.mozilla.org/en/docs/Web/API/WebGLBuffer) to Kotlin\n */\npublic external abstract class WebGLBuffer : WebGLObject\n\n/**\n * Exposes the JavaScript [WebGLFramebuffer](https://developer.mozilla.org/en/docs/Web/API/WebGLFramebuffer) to Kotlin\n */\npublic external abstract class WebGLFramebuffer : WebGLObject\n\n/**\n * Exposes the JavaScript [WebGLProgram](https://developer.mozilla.org/en/docs/Web/API/WebGLProgram) to Kotlin\n */\npublic external abstract class WebGLProgram : WebGLObject\n\n/**\n * Exposes the JavaScript [WebGLRenderbuffer](https://developer.mozilla.org/en/docs/Web/API/WebGLRenderbuffer) to Kotlin\n */\npublic external abstract class WebGLRenderbuffer : WebGLObject\n\n/**\n * Exposes the JavaScript [WebGLShader](https://developer.mozilla.org/en/docs/Web/API/WebGLShader) to Kotlin\n */\npublic external abstract class WebGLShader : WebGLObject\n\n/**\n * Exposes the JavaScript [WebGLTexture](https://developer.mozilla.org/en/docs/Web/API/WebGLTexture) to Kotlin\n */\npublic external abstract class WebGLTexture : WebGLObject\n\n/**\n * Exposes the JavaScript [WebGLUniformLocation](https://developer.mozilla.org/en/docs/Web/API/WebGLUniformLocation) to Kotlin\n */\npublic external abstract class WebGLUniformLocation\n\n/**\n * Exposes the JavaScript [WebGLActiveInfo](https://developer.mozilla.org/en/docs/Web/API/WebGLActiveInfo) to Kotlin\n */\npublic external abstract class WebGLActiveInfo {\n    open val size: Int\n    open val type: Int\n    open val name: String\n}\n\n/**\n * Exposes the JavaScript [WebGLShaderPrecisionFormat](https://developer.mozilla.org/en/docs/Web/API/WebGLShaderPrecisionFormat) to Kotlin\n */\npublic external abstract class WebGLShaderPrecisionFormat {\n    open val rangeMin: Int\n    open val rangeMax: Int\n    open val precision: Int\n}\n\n@Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npublic external interface WebGLRenderingContextBase {\n    val canvas: HTMLCanvasElement\n    val drawingBufferWidth: Int\n    val drawingBufferHeight: Int\n    fun getContextAttributes(): WebGLContextAttributes?\n    fun isContextLost(): Boolean\n    fun getSupportedExtensions(): Array<String>?\n    fun getExtension(name: String): dynamic\n    fun activeTexture(texture: Int)\n    fun attachShader(program: WebGLProgram?, shader: WebGLShader?)\n    fun bindAttribLocation(program: WebGLProgram?, index: Int, name: String)\n    fun bindBuffer(target: Int, buffer: WebGLBuffer?)\n    fun bindFramebuffer(target: Int, framebuffer: WebGLFramebuffer?)\n    fun bindRenderbuffer(target: Int, renderbuffer: WebGLRenderbuffer?)\n    fun bindTexture(target: Int, texture: WebGLTexture?)\n    fun blendColor(red: Float, green: Float, blue: Float, alpha: Float)\n    fun blendEquation(mode: Int)\n    fun blendEquationSeparate(modeRGB: Int, modeAlpha: Int)\n    fun blendFunc(sfactor: Int, dfactor: Int)\n    fun blendFuncSeparate(srcRGB: Int, dstRGB: Int, srcAlpha: Int, dstAlpha: Int)\n    fun bufferData(target: Int, size: Int, usage: Int)\n    fun bufferData(target: Int, data: BufferDataSource?, usage: Int)\n    fun bufferSubData(target: Int, offset: Int, data: BufferDataSource?)\n    fun checkFramebufferStatus(target: Int): Int\n    fun clear(mask: Int)\n    fun clearColor(red: Float, green: Float, blue: Float, alpha: Float)\n    fun clearDepth(depth: Float)\n    fun clearStencil(s: Int)\n    fun colorMask(red: Boolean, green: Boolean, blue: Boolean, alpha: Boolean)\n    fun compileShader(shader: WebGLShader?)\n    fun compressedTexImage2D(target: Int, level: Int, internalformat: Int, width: Int, height: Int, border: Int, data: ArrayBufferView)\n    fun compressedTexSubImage2D(target: Int, level: Int, xoffset: Int, yoffset: Int, width: Int, height: Int, format: Int, data: ArrayBufferView)\n    fun copyTexImage2D(target: Int, level: Int, internalformat: Int, x: Int, y: Int, width: Int, height: Int, border: Int)\n    fun copyTexSubImage2D(target: Int, level: Int, xoffset: Int, yoffset: Int, x: Int, y: Int, width: Int, height: Int)\n    fun createBuffer(): WebGLBuffer?\n    fun createFramebuffer(): WebGLFramebuffer?\n    fun createProgram(): WebGLProgram?\n    fun createRenderbuffer(): WebGLRenderbuffer?\n    fun createShader(type: Int): WebGLShader?\n    fun createTexture(): WebGLTexture?\n    fun cullFace(mode: Int)\n    fun deleteBuffer(buffer: WebGLBuffer?)\n    fun deleteFramebuffer(framebuffer: WebGLFramebuffer?)\n    fun deleteProgram(program: WebGLProgram?)\n    fun deleteRenderbuffer(renderbuffer: WebGLRenderbuffer?)\n    fun deleteShader(shader: WebGLShader?)\n    fun deleteTexture(texture: WebGLTexture?)\n    fun depthFunc(func: Int)\n    fun depthMask(flag: Boolean)\n    fun depthRange(zNear: Float, zFar: Float)\n    fun detachShader(program: WebGLProgram?, shader: WebGLShader?)\n    fun disable(cap: Int)\n    fun disableVertexAttribArray(index: Int)\n    fun drawArrays(mode: Int, first: Int, count: Int)\n    fun drawElements(mode: Int, count: Int, type: Int, offset: Int)\n    fun enable(cap: Int)\n    fun enableVertexAttribArray(index: Int)\n    fun finish()\n    fun flush()\n    fun framebufferRenderbuffer(target: Int, attachment: Int, renderbuffertarget: Int, renderbuffer: WebGLRenderbuffer?)\n    fun framebufferTexture2D(target: Int, attachment: Int, textarget: Int, texture: WebGLTexture?, level: Int)\n    fun frontFace(mode: Int)\n    fun generateMipmap(target: Int)\n    fun getActiveAttrib(program: WebGLProgram?, index: Int): WebGLActiveInfo?\n    fun getActiveUniform(program: WebGLProgram?, index: Int): WebGLActiveInfo?\n    fun getAttachedShaders(program: WebGLProgram?): Array<WebGLShader>?\n    fun getAttribLocation(program: WebGLProgram?, name: String): Int\n    fun getBufferParameter(target: Int, pname: Int): Any?\n    fun getParameter(pname: Int): Any?\n    fun getError(): Int\n    fun getFramebufferAttachmentParameter(target: Int, attachment: Int, pname: Int): Any?\n    fun getProgramParameter(program: WebGLProgram?, pname: Int): Any?\n    fun getProgramInfoLog(program: WebGLProgram?): String?\n    fun getRenderbufferParameter(target: Int, pname: Int): Any?\n    fun getShaderParameter(shader: WebGLShader?, pname: Int): Any?\n    fun getShaderPrecisionFormat(shadertype: Int, precisiontype: Int): WebGLShaderPrecisionFormat?\n    fun getShaderInfoLog(shader: WebGLShader?): String?\n    fun getShaderSource(shader: WebGLShader?): String?\n    fun getTexParameter(target: Int, pname: Int): Any?\n    fun getUniform(program: WebGLProgram?, location: WebGLUniformLocation?): Any?\n    fun getUniformLocation(program: WebGLProgram?, name: String): WebGLUniformLocation?\n    fun getVertexAttrib(index: Int, pname: Int): Any?\n    fun getVertexAttribOffset(index: Int, pname: Int): Int\n    fun hint(target: Int, mode: Int)\n    fun isBuffer(buffer: WebGLBuffer?): Boolean\n    fun isEnabled(cap: Int): Boolean\n    fun isFramebuffer(framebuffer: WebGLFramebuffer?): Boolean\n    fun isProgram(program: WebGLProgram?): Boolean\n    fun isRenderbuffer(renderbuffer: WebGLRenderbuffer?): Boolean\n    fun isShader(shader: WebGLShader?): Boolean\n    fun isTexture(texture: WebGLTexture?): Boolean\n    fun lineWidth(width: Float)\n    fun linkProgram(program: WebGLProgram?)\n    fun pixelStorei(pname: Int, param: Int)\n    fun polygonOffset(factor: Float, units: Float)\n    fun readPixels(x: Int, y: Int, width: Int, height: Int, format: Int, type: Int, pixels: ArrayBufferView?)\n    fun renderbufferStorage(target: Int, internalformat: Int, width: Int, height: Int)\n    fun sampleCoverage(value: Float, invert: Boolean)\n    fun scissor(x: Int, y: Int, width: Int, height: Int)\n    fun shaderSource(shader: WebGLShader?, source: String)\n    fun stencilFunc(func: Int, ref: Int, mask: Int)\n    fun stencilFuncSeparate(face: Int, func: Int, ref: Int, mask: Int)\n    fun stencilMask(mask: Int)\n    fun stencilMaskSeparate(face: Int, mask: Int)\n    fun stencilOp(fail: Int, zfail: Int, zpass: Int)\n    fun stencilOpSeparate(face: Int, fail: Int, zfail: Int, zpass: Int)\n    fun texImage2D(target: Int, level: Int, internalformat: Int, width: Int, height: Int, border: Int, format: Int, type: Int, pixels: ArrayBufferView?)\n    fun texImage2D(target: Int, level: Int, internalformat: Int, format: Int, type: Int, source: TexImageSource?)\n    fun texParameterf(target: Int, pname: Int, param: Float)\n    fun texParameteri(target: Int, pname: Int, param: Int)\n    fun texSubImage2D(target: Int, level: Int, xoffset: Int, yoffset: Int, width: Int, height: Int, format: Int, type: Int, pixels: ArrayBufferView?)\n    fun texSubImage2D(target: Int, level: Int, xoffset: Int, yoffset: Int, format: Int, type: Int, source: TexImageSource?)\n    fun uniform1f(location: WebGLUniformLocation?, x: Float)\n    fun uniform1fv(location: WebGLUniformLocation?, v: Float32Array)\n    fun uniform1fv(location: WebGLUniformLocation?, v: Array<Float>)\n    fun uniform1i(location: WebGLUniformLocation?, x: Int)\n    fun uniform1iv(location: WebGLUniformLocation?, v: Int32Array)\n    fun uniform1iv(location: WebGLUniformLocation?, v: Array<Int>)\n    fun uniform2f(location: WebGLUniformLocation?, x: Float, y: Float)\n    fun uniform2fv(location: WebGLUniformLocation?, v: Float32Array)\n    fun uniform2fv(location: WebGLUniformLocation?, v: Array<Float>)\n    fun uniform2i(location: WebGLUniformLocation?, x: Int, y: Int)\n    fun uniform2iv(location: WebGLUniformLocation?, v: Int32Array)\n    fun uniform2iv(location: WebGLUniformLocation?, v: Array<Int>)\n    fun uniform3f(location: WebGLUniformLocation?, x: Float, y: Float, z: Float)\n    fun uniform3fv(location: WebGLUniformLocation?, v: Float32Array)\n    fun uniform3fv(location: WebGLUniformLocation?, v: Array<Float>)\n    fun uniform3i(location: WebGLUniformLocation?, x: Int, y: Int, z: Int)\n    fun uniform3iv(location: WebGLUniformLocation?, v: Int32Array)\n    fun uniform3iv(location: WebGLUniformLocation?, v: Array<Int>)\n    fun uniform4f(location: WebGLUniformLocation?, x: Float, y: Float, z: Float, w: Float)\n    fun uniform4fv(location: WebGLUniformLocation?, v: Float32Array)\n    fun uniform4fv(location: WebGLUniformLocation?, v: Array<Float>)\n    fun uniform4i(location: WebGLUniformLocation?, x: Int, y: Int, z: Int, w: Int)\n    fun uniform4iv(location: WebGLUniformLocation?, v: Int32Array)\n    fun uniform4iv(location: WebGLUniformLocation?, v: Array<Int>)\n    fun uniformMatrix2fv(location: WebGLUniformLocation?, transpose: Boolean, value: Float32Array)\n    fun uniformMatrix2fv(location: WebGLUniformLocation?, transpose: Boolean, value: Array<Float>)\n    fun uniformMatrix3fv(location: WebGLUniformLocation?, transpose: Boolean, value: Float32Array)\n    fun uniformMatrix3fv(location: WebGLUniformLocation?, transpose: Boolean, value: Array<Float>)\n    fun uniformMatrix4fv(location: WebGLUniformLocation?, transpose: Boolean, value: Float32Array)\n    fun uniformMatrix4fv(location: WebGLUniformLocation?, transpose: Boolean, value: Array<Float>)\n    fun useProgram(program: WebGLProgram?)\n    fun validateProgram(program: WebGLProgram?)\n    fun vertexAttrib1f(index: Int, x: Float)\n    fun vertexAttrib1fv(index: Int, values: dynamic)\n    fun vertexAttrib2f(index: Int, x: Float, y: Float)\n    fun vertexAttrib2fv(index: Int, values: dynamic)\n    fun vertexAttrib3f(index: Int, x: Float, y: Float, z: Float)\n    fun vertexAttrib3fv(index: Int, values: dynamic)\n    fun vertexAttrib4f(index: Int, x: Float, y: Float, z: Float, w: Float)\n    fun vertexAttrib4fv(index: Int, values: dynamic)\n    fun vertexAttribPointer(index: Int, size: Int, type: Int, normalized: Boolean, stride: Int, offset: Int)\n    fun viewport(x: Int, y: Int, width: Int, height: Int)\n\n    companion object {\n        val DEPTH_BUFFER_BIT: Int\n        val STENCIL_BUFFER_BIT: Int\n        val COLOR_BUFFER_BIT: Int\n        val POINTS: Int\n        val LINES: Int\n        val LINE_LOOP: Int\n        val LINE_STRIP: Int\n        val TRIANGLES: Int\n        val TRIANGLE_STRIP: Int\n        val TRIANGLE_FAN: Int\n        val ZERO: Int\n        val ONE: Int\n        val SRC_COLOR: Int\n        val ONE_MINUS_SRC_COLOR: Int\n        val SRC_ALPHA: Int\n        val ONE_MINUS_SRC_ALPHA: Int\n        val DST_ALPHA: Int\n        val ONE_MINUS_DST_ALPHA: Int\n        val DST_COLOR: Int\n        val ONE_MINUS_DST_COLOR: Int\n        val SRC_ALPHA_SATURATE: Int\n        val FUNC_ADD: Int\n        val BLEND_EQUATION: Int\n        val BLEND_EQUATION_RGB: Int\n        val BLEND_EQUATION_ALPHA: Int\n        val FUNC_SUBTRACT: Int\n        val FUNC_REVERSE_SUBTRACT: Int\n        val BLEND_DST_RGB: Int\n        val BLEND_SRC_RGB: Int\n        val BLEND_DST_ALPHA: Int\n        val BLEND_SRC_ALPHA: Int\n        val CONSTANT_COLOR: Int\n        val ONE_MINUS_CONSTANT_COLOR: Int\n        val CONSTANT_ALPHA: Int\n        val ONE_MINUS_CONSTANT_ALPHA: Int\n        val BLEND_COLOR: Int\n        val ARRAY_BUFFER: Int\n        val ELEMENT_ARRAY_BUFFER: Int\n        val ARRAY_BUFFER_BINDING: Int\n        val ELEMENT_ARRAY_BUFFER_BINDING: Int\n        val STREAM_DRAW: Int\n        val STATIC_DRAW: Int\n        val DYNAMIC_DRAW: Int\n        val BUFFER_SIZE: Int\n        val BUFFER_USAGE: Int\n        val CURRENT_VERTEX_ATTRIB: Int\n        val FRONT: Int\n        val BACK: Int\n        val FRONT_AND_BACK: Int\n        val CULL_FACE: Int\n        val BLEND: Int\n        val DITHER: Int\n        val STENCIL_TEST: Int\n        val DEPTH_TEST: Int\n        val SCISSOR_TEST: Int\n        val POLYGON_OFFSET_FILL: Int\n        val SAMPLE_ALPHA_TO_COVERAGE: Int\n        val SAMPLE_COVERAGE: Int\n        val NO_ERROR: Int\n        val INVALID_ENUM: Int\n        val INVALID_VALUE: Int\n        val INVALID_OPERATION: Int\n        val OUT_OF_MEMORY: Int\n        val CW: Int\n        val CCW: Int\n        val LINE_WIDTH: Int\n        val ALIASED_POINT_SIZE_RANGE: Int\n        val ALIASED_LINE_WIDTH_RANGE: Int\n        val CULL_FACE_MODE: Int\n        val FRONT_FACE: Int\n        val DEPTH_RANGE: Int\n        val DEPTH_WRITEMASK: Int\n        val DEPTH_CLEAR_VALUE: Int\n        val DEPTH_FUNC: Int\n        val STENCIL_CLEAR_VALUE: Int\n        val STENCIL_FUNC: Int\n        val STENCIL_FAIL: Int\n        val STENCIL_PASS_DEPTH_FAIL: Int\n        val STENCIL_PASS_DEPTH_PASS: Int\n        val STENCIL_REF: Int\n        val STENCIL_VALUE_MASK: Int\n        val STENCIL_WRITEMASK: Int\n        val STENCIL_BACK_FUNC: Int\n        val STENCIL_BACK_FAIL: Int\n        val STENCIL_BACK_PASS_DEPTH_FAIL: Int\n        val STENCIL_BACK_PASS_DEPTH_PASS: Int\n        val STENCIL_BACK_REF: Int\n        val STENCIL_BACK_VALUE_MASK: Int\n        val STENCIL_BACK_WRITEMASK: Int\n        val VIEWPORT: Int\n        val SCISSOR_BOX: Int\n        val COLOR_CLEAR_VALUE: Int\n        val COLOR_WRITEMASK: Int\n        val UNPACK_ALIGNMENT: Int\n        val PACK_ALIGNMENT: Int\n        val MAX_TEXTURE_SIZE: Int\n        val MAX_VIEWPORT_DIMS: Int\n        val SUBPIXEL_BITS: Int\n        val RED_BITS: Int\n        val GREEN_BITS: Int\n        val BLUE_BITS: Int\n        val ALPHA_BITS: Int\n        val DEPTH_BITS: Int\n        val STENCIL_BITS: Int\n        val POLYGON_OFFSET_UNITS: Int\n        val POLYGON_OFFSET_FACTOR: Int\n        val TEXTURE_BINDING_2D: Int\n        val SAMPLE_BUFFERS: Int\n        val SAMPLES: Int\n        val SAMPLE_COVERAGE_VALUE: Int\n        val SAMPLE_COVERAGE_INVERT: Int\n        val COMPRESSED_TEXTURE_FORMATS: Int\n        val DONT_CARE: Int\n        val FASTEST: Int\n        val NICEST: Int\n        val GENERATE_MIPMAP_HINT: Int\n        val BYTE: Int\n        val UNSIGNED_BYTE: Int\n        val SHORT: Int\n        val UNSIGNED_SHORT: Int\n        val INT: Int\n        val UNSIGNED_INT: Int\n        val FLOAT: Int\n        val DEPTH_COMPONENT: Int\n        val ALPHA: Int\n        val RGB: Int\n        val RGBA: Int\n        val LUMINANCE: Int\n        val LUMINANCE_ALPHA: Int\n        val UNSIGNED_SHORT_4_4_4_4: Int\n        val UNSIGNED_SHORT_5_5_5_1: Int\n        val UNSIGNED_SHORT_5_6_5: Int\n        val FRAGMENT_SHADER: Int\n        val VERTEX_SHADER: Int\n        val MAX_VERTEX_ATTRIBS: Int\n        val MAX_VERTEX_UNIFORM_VECTORS: Int\n        val MAX_VARYING_VECTORS: Int\n        val MAX_COMBINED_TEXTURE_IMAGE_UNITS: Int\n        val MAX_VERTEX_TEXTURE_IMAGE_UNITS: Int\n        val MAX_TEXTURE_IMAGE_UNITS: Int\n        val MAX_FRAGMENT_UNIFORM_VECTORS: Int\n        val SHADER_TYPE: Int\n        val DELETE_STATUS: Int\n        val LINK_STATUS: Int\n        val VALIDATE_STATUS: Int\n        val ATTACHED_SHADERS: Int\n        val ACTIVE_UNIFORMS: Int\n        val ACTIVE_ATTRIBUTES: Int\n        val SHADING_LANGUAGE_VERSION: Int\n        val CURRENT_PROGRAM: Int\n        val NEVER: Int\n        val LESS: Int\n        val EQUAL: Int\n        val LEQUAL: Int\n        val GREATER: Int\n        val NOTEQUAL: Int\n        val GEQUAL: Int\n        val ALWAYS: Int\n        val KEEP: Int\n        val REPLACE: Int\n        val INCR: Int\n        val DECR: Int\n        val INVERT: Int\n        val INCR_WRAP: Int\n        val DECR_WRAP: Int\n        val VENDOR: Int\n        val RENDERER: Int\n        val VERSION: Int\n        val NEAREST: Int\n        val LINEAR: Int\n        val NEAREST_MIPMAP_NEAREST: Int\n        val LINEAR_MIPMAP_NEAREST: Int\n        val NEAREST_MIPMAP_LINEAR: Int\n        val LINEAR_MIPMAP_LINEAR: Int\n        val TEXTURE_MAG_FILTER: Int\n        val TEXTURE_MIN_FILTER: Int\n        val TEXTURE_WRAP_S: Int\n        val TEXTURE_WRAP_T: Int\n        val TEXTURE_2D: Int\n        val TEXTURE: Int\n        val TEXTURE_CUBE_MAP: Int\n        val TEXTURE_BINDING_CUBE_MAP: Int\n        val TEXTURE_CUBE_MAP_POSITIVE_X: Int\n        val TEXTURE_CUBE_MAP_NEGATIVE_X: Int\n        val TEXTURE_CUBE_MAP_POSITIVE_Y: Int\n        val TEXTURE_CUBE_MAP_NEGATIVE_Y: Int\n        val TEXTURE_CUBE_MAP_POSITIVE_Z: Int\n        val TEXTURE_CUBE_MAP_NEGATIVE_Z: Int\n        val MAX_CUBE_MAP_TEXTURE_SIZE: Int\n        val TEXTURE0: Int\n        val TEXTURE1: Int\n        val TEXTURE2: Int\n        val TEXTURE3: Int\n        val TEXTURE4: Int\n        val TEXTURE5: Int\n        val TEXTURE6: Int\n        val TEXTURE7: Int\n        val TEXTURE8: Int\n        val TEXTURE9: Int\n        val TEXTURE10: Int\n        val TEXTURE11: Int\n        val TEXTURE12: Int\n        val TEXTURE13: Int\n        val TEXTURE14: Int\n        val TEXTURE15: Int\n        val TEXTURE16: Int\n        val TEXTURE17: Int\n        val TEXTURE18: Int\n        val TEXTURE19: Int\n        val TEXTURE20: Int\n        val TEXTURE21: Int\n        val TEXTURE22: Int\n        val TEXTURE23: Int\n        val TEXTURE24: Int\n        val TEXTURE25: Int\n        val TEXTURE26: Int\n        val TEXTURE27: Int\n        val TEXTURE28: Int\n        val TEXTURE29: Int\n        val TEXTURE30: Int\n        val TEXTURE31: Int\n        val ACTIVE_TEXTURE: Int\n        val REPEAT: Int\n        val CLAMP_TO_EDGE: Int\n        val MIRRORED_REPEAT: Int\n        val FLOAT_VEC2: Int\n        val FLOAT_VEC3: Int\n        val FLOAT_VEC4: Int\n        val INT_VEC2: Int\n        val INT_VEC3: Int\n        val INT_VEC4: Int\n        val BOOL: Int\n        val BOOL_VEC2: Int\n        val BOOL_VEC3: Int\n        val BOOL_VEC4: Int\n        val FLOAT_MAT2: Int\n        val FLOAT_MAT3: Int\n        val FLOAT_MAT4: Int\n        val SAMPLER_2D: Int\n        val SAMPLER_CUBE: Int\n        val VERTEX_ATTRIB_ARRAY_ENABLED: Int\n        val VERTEX_ATTRIB_ARRAY_SIZE: Int\n        val VERTEX_ATTRIB_ARRAY_STRIDE: Int\n        val VERTEX_ATTRIB_ARRAY_TYPE: Int\n        val VERTEX_ATTRIB_ARRAY_NORMALIZED: Int\n        val VERTEX_ATTRIB_ARRAY_POINTER: Int\n        val VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: Int\n        val IMPLEMENTATION_COLOR_READ_TYPE: Int\n        val IMPLEMENTATION_COLOR_READ_FORMAT: Int\n        val COMPILE_STATUS: Int\n        val LOW_FLOAT: Int\n        val MEDIUM_FLOAT: Int\n        val HIGH_FLOAT: Int\n        val LOW_INT: Int\n        val MEDIUM_INT: Int\n        val HIGH_INT: Int\n        val FRAMEBUFFER: Int\n        val RENDERBUFFER: Int\n        val RGBA4: Int\n        val RGB5_A1: Int\n        val RGB565: Int\n        val DEPTH_COMPONENT16: Int\n        val STENCIL_INDEX: Int\n        val STENCIL_INDEX8: Int\n        val DEPTH_STENCIL: Int\n        val RENDERBUFFER_WIDTH: Int\n        val RENDERBUFFER_HEIGHT: Int\n        val RENDERBUFFER_INTERNAL_FORMAT: Int\n        val RENDERBUFFER_RED_SIZE: Int\n        val RENDERBUFFER_GREEN_SIZE: Int\n        val RENDERBUFFER_BLUE_SIZE: Int\n        val RENDERBUFFER_ALPHA_SIZE: Int\n        val RENDERBUFFER_DEPTH_SIZE: Int\n        val RENDERBUFFER_STENCIL_SIZE: Int\n        val FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: Int\n        val FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: Int\n        val FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: Int\n        val FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: Int\n        val COLOR_ATTACHMENT0: Int\n        val DEPTH_ATTACHMENT: Int\n        val STENCIL_ATTACHMENT: Int\n        val DEPTH_STENCIL_ATTACHMENT: Int\n        val NONE: Int\n        val FRAMEBUFFER_COMPLETE: Int\n        val FRAMEBUFFER_INCOMPLETE_ATTACHMENT: Int\n        val FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: Int\n        val FRAMEBUFFER_INCOMPLETE_DIMENSIONS: Int\n        val FRAMEBUFFER_UNSUPPORTED: Int\n        val FRAMEBUFFER_BINDING: Int\n        val RENDERBUFFER_BINDING: Int\n        val MAX_RENDERBUFFER_SIZE: Int\n        val INVALID_FRAMEBUFFER_OPERATION: Int\n        val UNPACK_FLIP_Y_WEBGL: Int\n        val UNPACK_PREMULTIPLY_ALPHA_WEBGL: Int\n        val CONTEXT_LOST_WEBGL: Int\n        val UNPACK_COLORSPACE_CONVERSION_WEBGL: Int\n        val BROWSER_DEFAULT_WEBGL: Int\n    }\n}\n\n/**\n * Exposes the JavaScript [WebGLRenderingContext](https://developer.mozilla.org/en/docs/Web/API/WebGLRenderingContext) to Kotlin\n */\npublic external abstract class WebGLRenderingContext : WebGLRenderingContextBase, RenderingContext {\n    companion object {\n        val DEPTH_BUFFER_BIT: Int\n        val STENCIL_BUFFER_BIT: Int\n        val COLOR_BUFFER_BIT: Int\n        val POINTS: Int\n        val LINES: Int\n        val LINE_LOOP: Int\n        val LINE_STRIP: Int\n        val TRIANGLES: Int\n        val TRIANGLE_STRIP: Int\n        val TRIANGLE_FAN: Int\n        val ZERO: Int\n        val ONE: Int\n        val SRC_COLOR: Int\n        val ONE_MINUS_SRC_COLOR: Int\n        val SRC_ALPHA: Int\n        val ONE_MINUS_SRC_ALPHA: Int\n        val DST_ALPHA: Int\n        val ONE_MINUS_DST_ALPHA: Int\n        val DST_COLOR: Int\n        val ONE_MINUS_DST_COLOR: Int\n        val SRC_ALPHA_SATURATE: Int\n        val FUNC_ADD: Int\n        val BLEND_EQUATION: Int\n        val BLEND_EQUATION_RGB: Int\n        val BLEND_EQUATION_ALPHA: Int\n        val FUNC_SUBTRACT: Int\n        val FUNC_REVERSE_SUBTRACT: Int\n        val BLEND_DST_RGB: Int\n        val BLEND_SRC_RGB: Int\n        val BLEND_DST_ALPHA: Int\n        val BLEND_SRC_ALPHA: Int\n        val CONSTANT_COLOR: Int\n        val ONE_MINUS_CONSTANT_COLOR: Int\n        val CONSTANT_ALPHA: Int\n        val ONE_MINUS_CONSTANT_ALPHA: Int\n        val BLEND_COLOR: Int\n        val ARRAY_BUFFER: Int\n        val ELEMENT_ARRAY_BUFFER: Int\n        val ARRAY_BUFFER_BINDING: Int\n        val ELEMENT_ARRAY_BUFFER_BINDING: Int\n        val STREAM_DRAW: Int\n        val STATIC_DRAW: Int\n        val DYNAMIC_DRAW: Int\n        val BUFFER_SIZE: Int\n        val BUFFER_USAGE: Int\n        val CURRENT_VERTEX_ATTRIB: Int\n        val FRONT: Int\n        val BACK: Int\n        val FRONT_AND_BACK: Int\n        val CULL_FACE: Int\n        val BLEND: Int\n        val DITHER: Int\n        val STENCIL_TEST: Int\n        val DEPTH_TEST: Int\n        val SCISSOR_TEST: Int\n        val POLYGON_OFFSET_FILL: Int\n        val SAMPLE_ALPHA_TO_COVERAGE: Int\n        val SAMPLE_COVERAGE: Int\n        val NO_ERROR: Int\n        val INVALID_ENUM: Int\n        val INVALID_VALUE: Int\n        val INVALID_OPERATION: Int\n        val OUT_OF_MEMORY: Int\n        val CW: Int\n        val CCW: Int\n        val LINE_WIDTH: Int\n        val ALIASED_POINT_SIZE_RANGE: Int\n        val ALIASED_LINE_WIDTH_RANGE: Int\n        val CULL_FACE_MODE: Int\n        val FRONT_FACE: Int\n        val DEPTH_RANGE: Int\n        val DEPTH_WRITEMASK: Int\n        val DEPTH_CLEAR_VALUE: Int\n        val DEPTH_FUNC: Int\n        val STENCIL_CLEAR_VALUE: Int\n        val STENCIL_FUNC: Int\n        val STENCIL_FAIL: Int\n        val STENCIL_PASS_DEPTH_FAIL: Int\n        val STENCIL_PASS_DEPTH_PASS: Int\n        val STENCIL_REF: Int\n        val STENCIL_VALUE_MASK: Int\n        val STENCIL_WRITEMASK: Int\n        val STENCIL_BACK_FUNC: Int\n        val STENCIL_BACK_FAIL: Int\n        val STENCIL_BACK_PASS_DEPTH_FAIL: Int\n        val STENCIL_BACK_PASS_DEPTH_PASS: Int\n        val STENCIL_BACK_REF: Int\n        val STENCIL_BACK_VALUE_MASK: Int\n        val STENCIL_BACK_WRITEMASK: Int\n        val VIEWPORT: Int\n        val SCISSOR_BOX: Int\n        val COLOR_CLEAR_VALUE: Int\n        val COLOR_WRITEMASK: Int\n        val UNPACK_ALIGNMENT: Int\n        val PACK_ALIGNMENT: Int\n        val MAX_TEXTURE_SIZE: Int\n        val MAX_VIEWPORT_DIMS: Int\n        val SUBPIXEL_BITS: Int\n        val RED_BITS: Int\n        val GREEN_BITS: Int\n        val BLUE_BITS: Int\n        val ALPHA_BITS: Int\n        val DEPTH_BITS: Int\n        val STENCIL_BITS: Int\n        val POLYGON_OFFSET_UNITS: Int\n        val POLYGON_OFFSET_FACTOR: Int\n        val TEXTURE_BINDING_2D: Int\n        val SAMPLE_BUFFERS: Int\n        val SAMPLES: Int\n        val SAMPLE_COVERAGE_VALUE: Int\n        val SAMPLE_COVERAGE_INVERT: Int\n        val COMPRESSED_TEXTURE_FORMATS: Int\n        val DONT_CARE: Int\n        val FASTEST: Int\n        val NICEST: Int\n        val GENERATE_MIPMAP_HINT: Int\n        val BYTE: Int\n        val UNSIGNED_BYTE: Int\n        val SHORT: Int\n        val UNSIGNED_SHORT: Int\n        val INT: Int\n        val UNSIGNED_INT: Int\n        val FLOAT: Int\n        val DEPTH_COMPONENT: Int\n        val ALPHA: Int\n        val RGB: Int\n        val RGBA: Int\n        val LUMINANCE: Int\n        val LUMINANCE_ALPHA: Int\n        val UNSIGNED_SHORT_4_4_4_4: Int\n        val UNSIGNED_SHORT_5_5_5_1: Int\n        val UNSIGNED_SHORT_5_6_5: Int\n        val FRAGMENT_SHADER: Int\n        val VERTEX_SHADER: Int\n        val MAX_VERTEX_ATTRIBS: Int\n        val MAX_VERTEX_UNIFORM_VECTORS: Int\n        val MAX_VARYING_VECTORS: Int\n        val MAX_COMBINED_TEXTURE_IMAGE_UNITS: Int\n        val MAX_VERTEX_TEXTURE_IMAGE_UNITS: Int\n        val MAX_TEXTURE_IMAGE_UNITS: Int\n        val MAX_FRAGMENT_UNIFORM_VECTORS: Int\n        val SHADER_TYPE: Int\n        val DELETE_STATUS: Int\n        val LINK_STATUS: Int\n        val VALIDATE_STATUS: Int\n        val ATTACHED_SHADERS: Int\n        val ACTIVE_UNIFORMS: Int\n        val ACTIVE_ATTRIBUTES: Int\n        val SHADING_LANGUAGE_VERSION: Int\n        val CURRENT_PROGRAM: Int\n        val NEVER: Int\n        val LESS: Int\n        val EQUAL: Int\n        val LEQUAL: Int\n        val GREATER: Int\n        val NOTEQUAL: Int\n        val GEQUAL: Int\n        val ALWAYS: Int\n        val KEEP: Int\n        val REPLACE: Int\n        val INCR: Int\n        val DECR: Int\n        val INVERT: Int\n        val INCR_WRAP: Int\n        val DECR_WRAP: Int\n        val VENDOR: Int\n        val RENDERER: Int\n        val VERSION: Int\n        val NEAREST: Int\n        val LINEAR: Int\n        val NEAREST_MIPMAP_NEAREST: Int\n        val LINEAR_MIPMAP_NEAREST: Int\n        val NEAREST_MIPMAP_LINEAR: Int\n        val LINEAR_MIPMAP_LINEAR: Int\n        val TEXTURE_MAG_FILTER: Int\n        val TEXTURE_MIN_FILTER: Int\n        val TEXTURE_WRAP_S: Int\n        val TEXTURE_WRAP_T: Int\n        val TEXTURE_2D: Int\n        val TEXTURE: Int\n        val TEXTURE_CUBE_MAP: Int\n        val TEXTURE_BINDING_CUBE_MAP: Int\n        val TEXTURE_CUBE_MAP_POSITIVE_X: Int\n        val TEXTURE_CUBE_MAP_NEGATIVE_X: Int\n        val TEXTURE_CUBE_MAP_POSITIVE_Y: Int\n        val TEXTURE_CUBE_MAP_NEGATIVE_Y: Int\n        val TEXTURE_CUBE_MAP_POSITIVE_Z: Int\n        val TEXTURE_CUBE_MAP_NEGATIVE_Z: Int\n        val MAX_CUBE_MAP_TEXTURE_SIZE: Int\n        val TEXTURE0: Int\n        val TEXTURE1: Int\n        val TEXTURE2: Int\n        val TEXTURE3: Int\n        val TEXTURE4: Int\n        val TEXTURE5: Int\n        val TEXTURE6: Int\n        val TEXTURE7: Int\n        val TEXTURE8: Int\n        val TEXTURE9: Int\n        val TEXTURE10: Int\n        val TEXTURE11: Int\n        val TEXTURE12: Int\n        val TEXTURE13: Int\n        val TEXTURE14: Int\n        val TEXTURE15: Int\n        val TEXTURE16: Int\n        val TEXTURE17: Int\n        val TEXTURE18: Int\n        val TEXTURE19: Int\n        val TEXTURE20: Int\n        val TEXTURE21: Int\n        val TEXTURE22: Int\n        val TEXTURE23: Int\n        val TEXTURE24: Int\n        val TEXTURE25: Int\n        val TEXTURE26: Int\n        val TEXTURE27: Int\n        val TEXTURE28: Int\n        val TEXTURE29: Int\n        val TEXTURE30: Int\n        val TEXTURE31: Int\n        val ACTIVE_TEXTURE: Int\n        val REPEAT: Int\n        val CLAMP_TO_EDGE: Int\n        val MIRRORED_REPEAT: Int\n        val FLOAT_VEC2: Int\n        val FLOAT_VEC3: Int\n        val FLOAT_VEC4: Int\n        val INT_VEC2: Int\n        val INT_VEC3: Int\n        val INT_VEC4: Int\n        val BOOL: Int\n        val BOOL_VEC2: Int\n        val BOOL_VEC3: Int\n        val BOOL_VEC4: Int\n        val FLOAT_MAT2: Int\n        val FLOAT_MAT3: Int\n        val FLOAT_MAT4: Int\n        val SAMPLER_2D: Int\n        val SAMPLER_CUBE: Int\n        val VERTEX_ATTRIB_ARRAY_ENABLED: Int\n        val VERTEX_ATTRIB_ARRAY_SIZE: Int\n        val VERTEX_ATTRIB_ARRAY_STRIDE: Int\n        val VERTEX_ATTRIB_ARRAY_TYPE: Int\n        val VERTEX_ATTRIB_ARRAY_NORMALIZED: Int\n        val VERTEX_ATTRIB_ARRAY_POINTER: Int\n        val VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: Int\n        val IMPLEMENTATION_COLOR_READ_TYPE: Int\n        val IMPLEMENTATION_COLOR_READ_FORMAT: Int\n        val COMPILE_STATUS: Int\n        val LOW_FLOAT: Int\n        val MEDIUM_FLOAT: Int\n        val HIGH_FLOAT: Int\n        val LOW_INT: Int\n        val MEDIUM_INT: Int\n        val HIGH_INT: Int\n        val FRAMEBUFFER: Int\n        val RENDERBUFFER: Int\n        val RGBA4: Int\n        val RGB5_A1: Int\n        val RGB565: Int\n        val DEPTH_COMPONENT16: Int\n        val STENCIL_INDEX: Int\n        val STENCIL_INDEX8: Int\n        val DEPTH_STENCIL: Int\n        val RENDERBUFFER_WIDTH: Int\n        val RENDERBUFFER_HEIGHT: Int\n        val RENDERBUFFER_INTERNAL_FORMAT: Int\n        val RENDERBUFFER_RED_SIZE: Int\n        val RENDERBUFFER_GREEN_SIZE: Int\n        val RENDERBUFFER_BLUE_SIZE: Int\n        val RENDERBUFFER_ALPHA_SIZE: Int\n        val RENDERBUFFER_DEPTH_SIZE: Int\n        val RENDERBUFFER_STENCIL_SIZE: Int\n        val FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: Int\n        val FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: Int\n        val FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: Int\n        val FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: Int\n        val COLOR_ATTACHMENT0: Int\n        val DEPTH_ATTACHMENT: Int\n        val STENCIL_ATTACHMENT: Int\n        val DEPTH_STENCIL_ATTACHMENT: Int\n        val NONE: Int\n        val FRAMEBUFFER_COMPLETE: Int\n        val FRAMEBUFFER_INCOMPLETE_ATTACHMENT: Int\n        val FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: Int\n        val FRAMEBUFFER_INCOMPLETE_DIMENSIONS: Int\n        val FRAMEBUFFER_UNSUPPORTED: Int\n        val FRAMEBUFFER_BINDING: Int\n        val RENDERBUFFER_BINDING: Int\n        val MAX_RENDERBUFFER_SIZE: Int\n        val INVALID_FRAMEBUFFER_OPERATION: Int\n        val UNPACK_FLIP_Y_WEBGL: Int\n        val UNPACK_PREMULTIPLY_ALPHA_WEBGL: Int\n        val CONTEXT_LOST_WEBGL: Int\n        val UNPACK_COLORSPACE_CONVERSION_WEBGL: Int\n        val BROWSER_DEFAULT_WEBGL: Int\n    }\n}\n\n/**\n * Exposes the JavaScript [WebGLContextEvent](https://developer.mozilla.org/en/docs/Web/API/WebGLContextEvent) to Kotlin\n */\npublic external open class WebGLContextEvent(type: String, eventInit: WebGLContextEventInit = definedExternally) : Event {\n    open val statusMessage: String\n\n    companion object {\n        val NONE: Short\n        val CAPTURING_PHASE: Short\n        val AT_TARGET: Short\n        val BUBBLING_PHASE: Short\n    }\n}\n\npublic external interface WebGLContextEventInit : EventInit {\n    var statusMessage: String? /* = \"\" */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun WebGLContextEventInit(statusMessage: String? = \"\", bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): WebGLContextEventInit {\n    val o = js(\"({})\")\n    o[\"statusMessage\"] = statusMessage\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n    return o\n}\n\n/**\n * Exposes the JavaScript [ArrayBuffer](https://developer.mozilla.org/en/docs/Web/API/ArrayBuffer) to Kotlin\n */\npublic external open class ArrayBuffer(length: Int) : BufferDataSource {\n    open val byteLength: Int\n    fun slice(begin: Int, end: Int = definedExternally): ArrayBuffer\n\n    companion object {\n        fun isView(value: Any?): Boolean\n    }\n}\n\n/**\n * Exposes the JavaScript [ArrayBufferView](https://developer.mozilla.org/en/docs/Web/API/ArrayBufferView) to Kotlin\n */\npublic external interface ArrayBufferView : BufferDataSource {\n    val buffer: ArrayBuffer\n    val byteOffset: Int\n    val byteLength: Int\n}\n\n/**\n * Exposes the JavaScript [Int8Array](https://developer.mozilla.org/en/docs/Web/API/Int8Array) to Kotlin\n */\npublic external open class Int8Array : ArrayBufferView {\n    constructor(length: Int)\n    constructor(array: Int8Array)\n    constructor(array: Array<Byte>)\n    constructor(buffer: ArrayBuffer, byteOffset: Int = definedExternally, length: Int = definedExternally)\n    open val length: Int\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun set(array: Int8Array, offset: Int = definedExternally)\n    fun set(array: Array<Byte>, offset: Int = definedExternally)\n    fun subarray(start: Int, end: Int): Int8Array\n\n    companion object {\n        val BYTES_PER_ELEMENT: Int\n    }\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun Int8Array.get(index: Int): Byte = asDynamic()[index]\n\n@kotlin.internal.InlineOnly\npublic inline operator fun Int8Array.set(index: Int, value: Byte) { asDynamic()[index] = value }\n\n/**\n * Exposes the JavaScript [Uint8Array](https://developer.mozilla.org/en/docs/Web/API/Uint8Array) to Kotlin\n */\npublic external open class Uint8Array : ArrayBufferView {\n    constructor(length: Int)\n    constructor(array: Uint8Array)\n    constructor(array: Array<Byte>)\n    constructor(buffer: ArrayBuffer, byteOffset: Int = definedExternally, length: Int = definedExternally)\n    open val length: Int\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun set(array: Uint8Array, offset: Int = definedExternally)\n    fun set(array: Array<Byte>, offset: Int = definedExternally)\n    fun subarray(start: Int, end: Int): Uint8Array\n\n    companion object {\n        val BYTES_PER_ELEMENT: Int\n    }\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun Uint8Array.get(index: Int): Byte = asDynamic()[index]\n\n@kotlin.internal.InlineOnly\npublic inline operator fun Uint8Array.set(index: Int, value: Byte) { asDynamic()[index] = value }\n\n/**\n * Exposes the JavaScript [Uint8ClampedArray](https://developer.mozilla.org/en/docs/Web/API/Uint8ClampedArray) to Kotlin\n */\npublic external open class Uint8ClampedArray : ArrayBufferView {\n    constructor(length: Int)\n    constructor(array: Uint8ClampedArray)\n    constructor(array: Array<Byte>)\n    constructor(buffer: ArrayBuffer, byteOffset: Int = definedExternally, length: Int = definedExternally)\n    open val length: Int\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun set(array: Uint8ClampedArray, offset: Int = definedExternally)\n    fun set(array: Array<Byte>, offset: Int = definedExternally)\n    fun subarray(start: Int, end: Int): Uint8ClampedArray\n\n    companion object {\n        val BYTES_PER_ELEMENT: Int\n    }\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun Uint8ClampedArray.get(index: Int): Byte = asDynamic()[index]\n\n@kotlin.internal.InlineOnly\npublic inline operator fun Uint8ClampedArray.set(index: Int, value: Byte) { asDynamic()[index] = value }\n\n/**\n * Exposes the JavaScript [Int16Array](https://developer.mozilla.org/en/docs/Web/API/Int16Array) to Kotlin\n */\npublic external open class Int16Array : ArrayBufferView {\n    constructor(length: Int)\n    constructor(array: Int16Array)\n    constructor(array: Array<Short>)\n    constructor(buffer: ArrayBuffer, byteOffset: Int = definedExternally, length: Int = definedExternally)\n    open val length: Int\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun set(array: Int16Array, offset: Int = definedExternally)\n    fun set(array: Array<Short>, offset: Int = definedExternally)\n    fun subarray(start: Int, end: Int): Int16Array\n\n    companion object {\n        val BYTES_PER_ELEMENT: Int\n    }\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun Int16Array.get(index: Int): Short = asDynamic()[index]\n\n@kotlin.internal.InlineOnly\npublic inline operator fun Int16Array.set(index: Int, value: Short) { asDynamic()[index] = value }\n\n/**\n * Exposes the JavaScript [Uint16Array](https://developer.mozilla.org/en/docs/Web/API/Uint16Array) to Kotlin\n */\npublic external open class Uint16Array : ArrayBufferView {\n    constructor(length: Int)\n    constructor(array: Uint16Array)\n    constructor(array: Array<Short>)\n    constructor(buffer: ArrayBuffer, byteOffset: Int = definedExternally, length: Int = definedExternally)\n    open val length: Int\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun set(array: Uint16Array, offset: Int = definedExternally)\n    fun set(array: Array<Short>, offset: Int = definedExternally)\n    fun subarray(start: Int, end: Int): Uint16Array\n\n    companion object {\n        val BYTES_PER_ELEMENT: Int\n    }\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun Uint16Array.get(index: Int): Short = asDynamic()[index]\n\n@kotlin.internal.InlineOnly\npublic inline operator fun Uint16Array.set(index: Int, value: Short) { asDynamic()[index] = value }\n\n/**\n * Exposes the JavaScript [Int32Array](https://developer.mozilla.org/en/docs/Web/API/Int32Array) to Kotlin\n */\npublic external open class Int32Array : ArrayBufferView {\n    constructor(length: Int)\n    constructor(array: Int32Array)\n    constructor(array: Array<Int>)\n    constructor(buffer: ArrayBuffer, byteOffset: Int = definedExternally, length: Int = definedExternally)\n    open val length: Int\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun set(array: Int32Array, offset: Int = definedExternally)\n    fun set(array: Array<Int>, offset: Int = definedExternally)\n    fun subarray(start: Int, end: Int): Int32Array\n\n    companion object {\n        val BYTES_PER_ELEMENT: Int\n    }\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun Int32Array.get(index: Int): Int = asDynamic()[index]\n\n@kotlin.internal.InlineOnly\npublic inline operator fun Int32Array.set(index: Int, value: Int) { asDynamic()[index] = value }\n\n/**\n * Exposes the JavaScript [Uint32Array](https://developer.mozilla.org/en/docs/Web/API/Uint32Array) to Kotlin\n */\npublic external open class Uint32Array : ArrayBufferView {\n    constructor(length: Int)\n    constructor(array: Uint32Array)\n    constructor(array: Array<Int>)\n    constructor(buffer: ArrayBuffer, byteOffset: Int = definedExternally, length: Int = definedExternally)\n    open val length: Int\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun set(array: Uint32Array, offset: Int = definedExternally)\n    fun set(array: Array<Int>, offset: Int = definedExternally)\n    fun subarray(start: Int, end: Int): Uint32Array\n\n    companion object {\n        val BYTES_PER_ELEMENT: Int\n    }\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun Uint32Array.get(index: Int): Int = asDynamic()[index]\n\n@kotlin.internal.InlineOnly\npublic inline operator fun Uint32Array.set(index: Int, value: Int) { asDynamic()[index] = value }\n\n/**\n * Exposes the JavaScript [Float32Array](https://developer.mozilla.org/en/docs/Web/API/Float32Array) to Kotlin\n */\npublic external open class Float32Array : ArrayBufferView {\n    constructor(length: Int)\n    constructor(array: Float32Array)\n    constructor(array: Array<Float>)\n    constructor(buffer: ArrayBuffer, byteOffset: Int = definedExternally, length: Int = definedExternally)\n    open val length: Int\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun set(array: Float32Array, offset: Int = definedExternally)\n    fun set(array: Array<Float>, offset: Int = definedExternally)\n    fun subarray(start: Int, end: Int): Float32Array\n\n    companion object {\n        val BYTES_PER_ELEMENT: Int\n    }\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun Float32Array.get(index: Int): Float = asDynamic()[index]\n\n@kotlin.internal.InlineOnly\npublic inline operator fun Float32Array.set(index: Int, value: Float) { asDynamic()[index] = value }\n\n/**\n * Exposes the JavaScript [Float64Array](https://developer.mozilla.org/en/docs/Web/API/Float64Array) to Kotlin\n */\npublic external open class Float64Array : ArrayBufferView {\n    constructor(length: Int)\n    constructor(array: Float64Array)\n    constructor(array: Array<Double>)\n    constructor(buffer: ArrayBuffer, byteOffset: Int = definedExternally, length: Int = definedExternally)\n    open val length: Int\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun set(array: Float64Array, offset: Int = definedExternally)\n    fun set(array: Array<Double>, offset: Int = definedExternally)\n    fun subarray(start: Int, end: Int): Float64Array\n\n    companion object {\n        val BYTES_PER_ELEMENT: Int\n    }\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun Float64Array.get(index: Int): Double = asDynamic()[index]\n\n@kotlin.internal.InlineOnly\npublic inline operator fun Float64Array.set(index: Int, value: Double) { asDynamic()[index] = value }\n\n/**\n * Exposes the JavaScript [DataView](https://developer.mozilla.org/en/docs/Web/API/DataView) to Kotlin\n */\npublic external open class DataView(buffer: ArrayBuffer, byteOffset: Int = definedExternally, byteLength: Int = definedExternally) : ArrayBufferView {\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun getInt8(byteOffset: Int): Byte\n    fun getUint8(byteOffset: Int): Byte\n    fun getInt16(byteOffset: Int, littleEndian: Boolean = definedExternally): Short\n    fun getUint16(byteOffset: Int, littleEndian: Boolean = definedExternally): Short\n    fun getInt32(byteOffset: Int, littleEndian: Boolean = definedExternally): Int\n    fun getUint32(byteOffset: Int, littleEndian: Boolean = definedExternally): Int\n    fun getFloat32(byteOffset: Int, littleEndian: Boolean = definedExternally): Float\n    fun getFloat64(byteOffset: Int, littleEndian: Boolean = definedExternally): Double\n    fun setInt8(byteOffset: Int, value: Byte)\n    fun setUint8(byteOffset: Int, value: Byte)\n    fun setInt16(byteOffset: Int, value: Short, littleEndian: Boolean = definedExternally)\n    fun setUint16(byteOffset: Int, value: Short, littleEndian: Boolean = definedExternally)\n    fun setInt32(byteOffset: Int, value: Int, littleEndian: Boolean = definedExternally)\n    fun setUint32(byteOffset: Int, value: Int, littleEndian: Boolean = definedExternally)\n    fun setFloat32(byteOffset: Int, value: Float, littleEndian: Boolean = definedExternally)\n    fun setFloat64(byteOffset: Int, value: Double, littleEndian: Boolean = definedExternally)\n}\n\npublic external interface BufferDataSource\n\npublic external interface TexImageSource","package io.ktor.utils.io.charsets\n\nimport io.ktor.utils.io.core.*\nimport io.ktor.utils.io.js.*\nimport org.khronos.webgl.*\n\npublic actual abstract class Charset(internal val _name: String) {\n    public actual abstract fun newEncoder(): CharsetEncoder\n    public actual abstract fun newDecoder(): CharsetDecoder\n\n    public actual companion object {\n        public actual fun forName(name: String): Charset {\n            if (name == \"UTF-8\" || name == \"utf-8\" || name == \"UTF8\" || name == \"utf8\") return Charsets.UTF_8\n            if (name == \"ISO-8859-1\" || name == \"iso-8859-1\"\n                || name.replace('_', '-').let { it == \"iso-8859-1\" || it.toLowerCase() == \"iso-8859-1\" }\n                || name == \"latin1\"\n            ) {\n                return Charsets.ISO_8859_1\n            }\n            throw IllegalArgumentException(\"Charset $name is not supported\")\n        }\n\n    }\n}\n\npublic actual val Charset.name: String get() = _name\n\n// -----------------------\n\npublic actual abstract class CharsetEncoder(internal val _charset: Charset)\nprivate data class CharsetEncoderImpl(private val charset: Charset) : CharsetEncoder(charset)\npublic actual val CharsetEncoder.charset: Charset get() = _charset\n\npublic actual fun CharsetEncoder.encodeToByteArray(input: CharSequence, fromIndex: Int, toIndex: Int): ByteArray =\n    encodeToByteArrayImpl1(input, fromIndex, toIndex)\n\ninternal actual fun CharsetEncoder.encodeImpl(input: CharSequence, fromIndex: Int, toIndex: Int, dst: Buffer): Int {\n    require(fromIndex <= toIndex)\n    if (charset == Charsets.ISO_8859_1) {\n        return encodeISO88591(input, fromIndex, toIndex, dst)\n    }\n\n    require(charset === Charsets.UTF_8) { \"Only UTF-8 encoding is supported in JS\" }\n\n    val encoder = TextEncoderCtor()  // Only UTF-8 is supported so we know that at most 6 bytes per character is used\n    var start = fromIndex\n    var dstRemaining = dst.writeRemaining\n\n    while (start < toIndex && dstRemaining > 0) {\n        val numChars = minOf(toIndex - start, dstRemaining / 6).coerceAtLeast(1)\n        val dropLastChar = input[start + numChars - 1].isHighSurrogate()\n        val endIndexExclusive = when {\n            dropLastChar && numChars == 1 -> start + 2\n            dropLastChar -> start + numChars - 1\n            else -> start + numChars\n        }\n\n        val array1 = encoder.encode(input.substring(start, endIndexExclusive))\n        if (array1.length > dstRemaining) break\n        dst.writeFully(array1)\n        start = endIndexExclusive\n        dstRemaining -= array1.length\n    }\n\n    return start - fromIndex\n}\n\npublic actual fun CharsetEncoder.encodeUTF8(input: ByteReadPacket, dst: Output) {\n    require(charset === Charsets.UTF_8)\n    // we only support UTF-8 so as far as input is UTF-8 encoded string then we simply copy bytes\n    dst.writePacket(input)\n}\n\ninternal actual fun CharsetEncoder.encodeComplete(dst: Buffer): Boolean = true\n\n\n// ----------------------------------------------------------------------\n\n\npublic actual abstract class CharsetDecoder(internal val _charset: Charset)\n\nprivate data class CharsetDecoderImpl(private val charset: Charset) : CharsetDecoder(charset)\n\npublic actual val CharsetDecoder.charset: Charset get() = _charset\n\ninternal actual fun CharsetDecoder.decodeBuffer(\n    input: Buffer,\n    out: Appendable,\n    lastBuffer: Boolean,\n    max: Int\n): Int {\n    if (max == 0) return 0\n\n    val decoder = TextDecoderFatal(charset.name)\n    val copied: Int\n\n    input.readDirectInt8Array { view ->\n        val result = view.decodeBufferImpl(decoder, max)\n        out.append(result.charactersDecoded)\n        copied = result.bytesConsumed\n\n        result.bytesConsumed\n    }\n\n    return copied\n}\n\npublic actual fun CharsetDecoder.decode(input: Input, dst: Appendable, max: Int): Int {\n    val decoder = TextDecoderFatal(charset.name, true)\n    var charactersCopied = 0\n\n    // use decode stream while we have remaining characters count > buffer size in bytes\n    // it is much faster than using decodeBufferImpl\n    input.takeWhileSize { buffer ->\n        val rem = max - charactersCopied\n        val bufferSize = buffer.readRemaining\n        if (rem < bufferSize) return@takeWhileSize 0\n\n        buffer.readDirectInt8Array { view ->\n            val decodedText = decodeWrap {\n                decoder.decodeStream(view, stream = true)\n            }\n            dst.append(decodedText)\n            charactersCopied += decodedText.length\n            view.byteLength\n        }\n\n        when {\n            charactersCopied == max -> {\n                val tail = try {\n                    decoder.decode()\n                } catch (_: dynamic) {\n                    \"\"\n                }\n\n                if (tail.isNotEmpty()) {\n                    // if we have a trailing byte then we can't handle this chunk via fast-path\n                    // because we don't know how many bytes in the end we need to preserve\n                    buffer.rewind(bufferSize)\n                }\n                0\n            }\n            charactersCopied < max -> MAX_CHARACTERS_SIZE_IN_BYTES\n            else -> 0\n        }\n    }\n\n    if (charactersCopied < max) {\n        var size = 1\n        input.takeWhileSize(1) { buffer ->\n            val rc = buffer.readDirectInt8Array { view ->\n                val result = view.decodeBufferImpl(decoder, max - charactersCopied)\n                dst.append(result.charactersDecoded)\n                charactersCopied += result.charactersDecoded.length\n                result.bytesConsumed\n            }\n            when {\n                rc > 0 -> size = 1\n                size == MAX_CHARACTERS_SIZE_IN_BYTES -> size = 0\n                else -> size++\n            }\n\n            size\n        }\n    }\n\n    return charactersCopied\n}\n\npublic actual fun CharsetDecoder.decodeExactBytes(input: Input, inputLength: Int): String {\n    if (inputLength == 0) return \"\"\n    if (input is AbstractInput && input.headRemaining >= inputLength) {\n        val decoder = TextDecoderFatal(charset._name, true)\n\n        val head = input.head\n        val view = input.headMemory.view\n\n        val text = decodeWrap {\n            val subView: ArrayBufferView = when {\n                head.readPosition == 0 && inputLength == view.byteLength -> view\n                else -> DataView(view.buffer, view.byteOffset + head.readPosition, inputLength)\n            }\n\n            decoder.decode(subView)\n        }\n\n        input.discardExact(inputLength)\n        return text\n    }\n\n    return decodeExactBytesSlow(input, inputLength)\n}\n\n// -----------------------------------------------------------\n\npublic actual object Charsets {\n    public actual val UTF_8: Charset = CharsetImpl(\"UTF-8\")\n    public actual val ISO_8859_1: Charset = CharsetImpl(\"ISO-8859-1\")\n}\n\nprivate data class CharsetImpl(val name: String) : Charset(name) {\n    override fun newEncoder(): CharsetEncoder = CharsetEncoderImpl(this)\n    override fun newDecoder(): CharsetDecoder = CharsetDecoderImpl(this)\n}\n\n\npublic actual open class MalformedInputException actual constructor(message: String) : Throwable(message)\n\nprivate fun CharsetDecoder.decodeExactBytesSlow(input: Input, inputLength: Int): String {\n    val decoder = TextDecoderFatal(charset.name, true)\n    var inputRemaining = inputLength\n    val sb = StringBuilder(inputLength)\n\n    decodeWrap {\n        input.takeWhileSize(6) { buffer ->\n            val chunkSize = buffer.readRemaining\n            val size = minOf(chunkSize, inputRemaining)\n            val text = when {\n                buffer.readPosition == 0 && buffer.memory.view.byteLength == size -> decoder.decodeStream(\n                    buffer.memory.view,\n                    true\n                )\n                else -> decoder.decodeStream(\n                    Int8Array(\n                        buffer.memory.view.buffer,\n                        buffer.memory.view.byteOffset + buffer.readPosition,\n                        size\n                    ), true\n                )\n            }\n            sb.append(text)\n\n            buffer.discardExact(size)\n            inputRemaining -= size\n\n            if (inputRemaining > 0) 6 else 0\n        }\n\n        if (inputRemaining > 0) {\n            input.takeWhile { buffer ->\n                val chunkSize = buffer.readRemaining\n                val size = minOf(chunkSize, inputRemaining)\n                val text = when {\n                    buffer.readPosition == 0 && buffer.memory.view.byteLength == size -> {\n                        decoder.decode(buffer.memory.view)\n                    }\n                    else -> decoder.decodeStream(\n                        Int8Array(\n                            buffer.memory.view.buffer,\n                            buffer.memory.view.byteOffset + buffer.readPosition,\n                            size\n                        ), true\n                    )\n                }\n                sb.append(text)\n                buffer.discardExact(size)\n                inputRemaining -= size\n                true\n            }\n        }\n\n        sb.append(decoder.decode())\n    }\n\n    if (inputRemaining > 0) {\n        throw EOFException(\"Not enough bytes available: had only ${inputLength - inputRemaining} instead of $inputLength\")\n    }\n    return sb.toString()\n}\n","package io.ktor.utils.io.js\n\nimport io.ktor.utils.io.charsets.*\nimport io.ktor.utils.io.core.*\nimport org.khronos.webgl.*\n\nprivate val IS_NODE: Boolean = js(\n    \"typeof process !== 'undefined' && process.versions != null && process.versions.node != null\"\n) as Boolean\n\n@Deprecated(\"Use readText with charset instead\", ReplaceWith(\"readText(Charset.forName(encoding), max)\", \"io.ktor.utils.io.core.readText\", \"io.ktor.utils.io.charsets.Charset\"))\npublic fun ByteReadPacket.readText(encoding: String, max: Int = Int.MAX_VALUE): String = readText(Charset.forName(encoding), max)\n\n@Deprecated(\"Use readText with charset instead\", ReplaceWith(\"readText(out, Charset.forName(encoding), max)\", \"io.ktor.utils.io.core.readText\", \"io.ktor.utils.io.charsets.Charset\"))\npublic fun ByteReadPacket.readText(encoding: String = \"UTF-8\", out: Appendable, max: Int = Int.MAX_VALUE): Int {\n    return readText(out, Charset.forName(encoding), max)\n}\n\ninternal external class TextDecoder(encoding: String, options: dynamic = definedExternally) {\n    val encoding: String\n\n    public fun decode(): String\n    public fun decode(buffer: ArrayBuffer): String\n    public fun decode(buffer: ArrayBuffer, options: dynamic): String\n    public fun decode(buffer: ArrayBufferView): String\n    public fun decode(buffer: ArrayBufferView, options: dynamic): String\n}\n\nprivate val STREAM_TRUE = Any().apply {\n    with(this.asDynamic()) {\n        stream = true\n    }\n}\n\nprivate val FATAL_TRUE = Any().apply {\n    with(this.asDynamic()) {\n        fatal = true\n    }\n}\n\ninternal fun TextDecoderFatal(encoding: String, fatal: Boolean = true): TextDecoder {\n    // PhantomJS does not support TextDecoder yet so we use node module text-encoding for tests\n    // Node.js [TextDecoder] doesn't support ISO-8859-1\n    if (IS_NODE || js(\"typeof TextDecoder\") == \"undefined\") {\n        val module = js(\"require('text-encoding')\")\n        if (module.TextDecoder === undefined) throw IllegalStateException(\"TextDecoder is not supported by your browser and no text-encoding module found\")\n        val ctor = module.TextDecoder\n        val objPrototype = js(\"Object\").create(ctor.prototype)\n\n        @Suppress(\"UnsafeCastFromDynamic\")\n        return if (fatal) ctor.call(objPrototype, encoding, FATAL_TRUE)\n        else ctor.call(objPrototype, encoding)\n    }\n\n    return if (fatal) TextDecoder(encoding, FATAL_TRUE) else TextDecoder(encoding)\n}\n\ninternal inline fun TextDecoder.decodeStream(buffer: ArrayBufferView, stream: Boolean): String {\n    decodeWrap {\n        return if (stream) {\n            decode(buffer, STREAM_TRUE)\n        } else {\n            decode(buffer)\n        }\n    }\n}\n\ninternal inline fun TextDecoder.decodeStream(buffer: ArrayBuffer, stream: Boolean): String {\n    decodeWrap {\n        return if (stream) {\n            decode(buffer, STREAM_TRUE)\n        } else {\n            decode(buffer)\n        }\n    }\n}\n\ninternal inline fun <R> decodeWrap(block: () -> R): R {\n    try {\n        return block()\n    } catch (t: Throwable) {\n        throw MalformedInputException(\"Failed to decode bytes: ${t.message ?: \"no cause provided\"}\")\n    }\n}\n","package io.ktor.utils.io.charsets\n\nimport io.ktor.utils.io.js.*\nimport org.khronos.webgl.*\n\n// I don't know any characters that have longer characters\ninternal const val MAX_CHARACTERS_SIZE_IN_BYTES: Int = 8\nprivate const val MAX_CHARACTERS_COUNT = Int.MAX_VALUE / MAX_CHARACTERS_SIZE_IN_BYTES\n\ninternal data class DecodeBufferResult(val charactersDecoded: String, val bytesConsumed: Int)\n\ninternal fun Int8Array.decodeBufferImpl(nativeDecoder: TextDecoder, maxCharacters: Int): DecodeBufferResult {\n    if (maxCharacters == 0) {\n        return DecodeBufferResult(\"\", 0)\n    }\n\n    // fast-path: try to assume that we have 1 byte per character content\n    try {\n        val sizeInBytes = maxCharacters.coerceAtMost(byteLength)\n        val text = nativeDecoder.decode(subarray(0, sizeInBytes))\n        if (text.length <= maxCharacters) {\n            return DecodeBufferResult(text, sizeInBytes)\n        }\n    } catch (_: dynamic) {\n    }\n\n    return decodeBufferImplSlow(nativeDecoder, maxCharacters)\n}\n\nprivate fun Int8Array.decodeBufferImplSlow(nativeDecoder: TextDecoder, maxCharacters: Int): DecodeBufferResult {\n    val maxBytes = when {\n        maxCharacters >= MAX_CHARACTERS_COUNT -> Int.MAX_VALUE\n        else -> maxCharacters * MAX_CHARACTERS_SIZE_IN_BYTES\n    }.coerceAtMost(byteLength)\n\n    var sizeInBytes = maxBytes\n    while (sizeInBytes > MAX_CHARACTERS_SIZE_IN_BYTES) {\n        try {\n            val text = nativeDecoder.decode(subarray(0, sizeInBytes))\n            if (text.length <= maxCharacters) {\n                return DecodeBufferResult(text, sizeInBytes)\n            }\n        } catch (_: dynamic) {\n        }\n\n        sizeInBytes /= 2\n    }\n\n    sizeInBytes = MAX_CHARACTERS_SIZE_IN_BYTES\n    while (sizeInBytes > 0) {\n        try {\n            val text = nativeDecoder.decode(subarray(0, sizeInBytes))\n            if (text.length <= maxCharacters) {\n                return DecodeBufferResult(text, sizeInBytes)\n            }\n        } catch (_: dynamic) {\n        }\n\n        sizeInBytes--\n    }\n\n    // all attempts were failed so most likely we have a broken character but we can't find it for some reason\n    // so the following decode most likely will fail\n    decodeWrap {\n        nativeDecoder.decode(this)\n    }\n\n    // if it didn't for some reason we have no idea what to do\n    throw MalformedInputException(\"Unable to decode buffer\")\n}\n","package io.ktor.utils.io.charsets\n\nimport io.ktor.utils.io.core.*\nimport org.khronos.webgl.*\n\ninternal fun encodeISO88591(input: CharSequence, fromIndex: Int, toIndex: Int, dst: Buffer): Int {\n    if (fromIndex >= toIndex) return 0\n\n    dst.writeDirect { view ->\n        val i8 = Int8Array(view.buffer, view.byteOffset, view.byteLength)\n        var writeIndex = 0\n        for (index in fromIndex until toIndex) {\n            val character = input[index].toInt()\n            if (character > 0xff) {\n                failedToMapError(character)\n            }\n            i8[writeIndex++] = character.toByte()\n        }\n        writeIndex\n    }\n    return toIndex - fromIndex\n}\n\nprivate fun failedToMapError(ch: Int): Nothing {\n    throw MalformedInputException(\"The character with unicode point $ch couldn't be mapped to ISO-8859-1 character\")\n}\n","@file:Suppress(\"ReplaceRangeToWithUntil\", \"RedundantModalityModifier\", \"DEPRECATION\", \"DEPRECATION_ERROR\")\n\npackage io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.core.internal.*\nimport io.ktor.utils.io.pool.*\nimport org.khronos.webgl.*\nimport kotlin.contracts.*\n\n@Suppress(\"DIFFERENT_NAMES_FOR_THE_SAME_PARAMETER_IN_SUPERTYPES\")\n@Deprecated(\"Use Buffer instead.\", replaceWith = ReplaceWith(\"Buffer\", \"io.ktor.utils.io.core.Buffer\"))\npublic actual class IoBuffer actual constructor(\n    memory: Memory,\n    origin: ChunkBuffer?\n) : Input, Output, ChunkBuffer(memory, origin) {\n    private val content: ArrayBuffer get() = memory.view.buffer\n\n    override val endOfInput: Boolean get() = writePosition == readPosition\n\n    @Deprecated(\n        \"Not supported anymore. All operations are big endian by default. \" +\n            \"Read/write with readXXXLittleEndian/writeXXXLittleEndian or \" +\n            \"do readXXX/writeXXX with X.reverseByteOrder() instead.\",\n        level = DeprecationLevel.ERROR\n    )\n    actual final override var byteOrder: ByteOrder\n        get() = ByteOrder.BIG_ENDIAN\n        set(newOrder) {\n            if (newOrder != ByteOrder.BIG_ENDIAN) {\n                throw IllegalArgumentException(\"Only big endian is supported\")\n            }\n        }\n\n    final override fun peekTo(destination: Memory, destinationOffset: Long, offset: Long, min: Long, max: Long): Long {\n        return (this as Buffer).peekTo(destination, destinationOffset, offset, min, max)\n    }\n\n    final override fun tryPeek(): Int {\n        return tryPeekByte()\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    final override fun readFully(dst: ArrayBuffer, offset: Int, length: Int) {\n        (this as Buffer).readFully(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readAvailable(dst: ArrayBuffer, offset: Int, length: Int): Int {\n        return (this as Buffer).readAvailable(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    final override fun readAvailable(dst: IoBuffer, length: Int): Int {\n        return (this as Buffer).readAvailable(dst, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readFully(dst: ArrayBufferView, offset: Int, length: Int) {\n        if (readRemaining < length) throw IllegalStateException(\"Not enough bytes available ($readRemaining) to read $length bytes\")\n        if (length > dst.byteLength) throw IllegalArgumentException(\"Destination buffer overflow: length = $length, buffer capacity ${dst.byteLength}\")\n        require(offset >= 0) { \"offset should be positive\" }\n        require(offset + length <= dst.byteLength) { throw IndexOutOfBoundsException(\"\") }\n\n        (this as Buffer).readFully(dst.buffer, dst.byteOffset + offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readAvailable(dst: ArrayBufferView, offset: Int, length: Int): Int {\n        val readRemaining = readRemaining\n        if (readRemaining == 0) return -1\n        val size = minOf(length, readRemaining)\n        (this as Buffer).readFully(dst, offset, size)\n        return size\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readFully(dst: Int8Array, offset: Int, length: Int) {\n        (this as Buffer).readFully(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readAvailable(dst: Int8Array, offset: Int, length: Int): Int {\n        return (this as Buffer).readAvailable(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    final override fun readFully(dst: IoBuffer, length: Int) {\n        (this as Buffer).readFully(dst, length)\n    }\n\n    final override fun append(csq: CharSequence?, start: Int, end: Int): Appendable {\n        val idx = appendChars(csq ?: \"null\", start, end)\n        if (idx != end) throw IllegalStateException(\"Not enough free space to append char sequence\")\n        return this\n    }\n\n    final override fun append(csq: CharSequence?): Appendable {\n        return if (csq == null) append(\"null\") else append(csq, 0, csq.length)\n    }\n\n    final override fun append(csq: CharArray, start: Int, end: Int): Appendable {\n        val idx = appendChars(csq, start, end)\n\n        if (idx != end) throw IllegalStateException(\"Not enough free space to append char sequence\")\n        return this\n    }\n\n    override fun append(c: Char): Appendable {\n        (this as Buffer).append(c)\n        return this\n    }\n\n    @Deprecated(\n        \"Use writeFully instead\",\n        ReplaceWith(\"writeFully(array, offset, length)\"),\n        level = DeprecationLevel.ERROR\n    )\n    public fun write(array: ByteArray, offset: Int, length: Int) {\n        (this as Buffer).writeFully(array, offset, length)\n    }\n\n    @Deprecated(\n        \"Use writeFully instead\",\n        ReplaceWith(\"writeFully(array, offset, length)\"),\n        level = DeprecationLevel.ERROR\n    )\n    public fun write(src: Int8Array, offset: Int, length: Int) {\n        (this as Buffer).writeFully(src, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readShort(): Short {\n        return (this as Buffer).readShort()\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readInt(): Int {\n        return (this as Buffer).readInt()\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readFloat(): Float {\n        return (this as Buffer).readFloat()\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readDouble(): Double {\n        return (this as Buffer).readDouble()\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readFully(dst: ByteArray, offset: Int, length: Int) {\n        (this as Buffer).readFully(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readFully(dst: ShortArray, offset: Int, length: Int) {\n        (this as Buffer).readFully(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readFully(dst: IntArray, offset: Int, length: Int) {\n        (this as Buffer).readFully(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readFully(dst: LongArray, offset: Int, length: Int) {\n        (this as Buffer).readFully(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readFully(dst: FloatArray, offset: Int, length: Int) {\n        (this as Buffer).readFully(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readFully(dst: DoubleArray, offset: Int, length: Int) {\n        (this as Buffer).readFully(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readAvailable(dst: ByteArray, offset: Int, length: Int): Int {\n        return (this as Buffer).readAvailable(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readAvailable(dst: ShortArray, offset: Int, length: Int): Int {\n        return (this as Buffer).readAvailable(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readAvailable(dst: IntArray, offset: Int, length: Int): Int {\n        return (this as Buffer).readAvailable(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readAvailable(dst: LongArray, offset: Int, length: Int): Int {\n        return (this as Buffer).readAvailable(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readAvailable(dst: FloatArray, offset: Int, length: Int): Int {\n        return (this as Buffer).readAvailable(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readAvailable(dst: DoubleArray, offset: Int, length: Int): Int {\n        return (this as Buffer).readAvailable(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun peekTo(buffer: IoBuffer): Int {\n        return (this as Input).peekTo(buffer)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    final override fun readLong(): Long {\n        return (this as Buffer).readLong()\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun writeShort(v: Short) {\n        (this as Buffer).writeShort(v)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun writeInt(v: Int) {\n        (this as Buffer).writeInt(v)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun writeFloat(v: Float) {\n        (this as Buffer).writeFloat(v)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun writeDouble(v: Double) {\n        (this as Buffer).writeDouble(v)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun writeFully(src: ByteArray, offset: Int, length: Int) {\n        (this as Buffer).writeFully(src, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun writeFully(src: ShortArray, offset: Int, length: Int) {\n        (this as Buffer).writeFully(src, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun writeFully(src: IntArray, offset: Int, length: Int) {\n        (this as Buffer).writeFully(src, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun writeFully(src: LongArray, offset: Int, length: Int) {\n        (this as Buffer).writeFully(src, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun writeFully(src: FloatArray, offset: Int, length: Int) {\n        (this as Buffer).writeFully(src, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun writeFully(src: DoubleArray, offset: Int, length: Int) {\n        (this as Buffer).writeFully(src, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun writeFully(src: IoBuffer, length: Int) {\n        (this as Buffer).writeFully(src, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun fill(n: Long, v: Byte) {\n        (this as Buffer).fill(n, v)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    final override fun writeLong(v: Long) {\n        (this as Buffer).writeLong(v)\n    }\n\n    @Deprecated(\"Use writeFully instead\", ReplaceWith(\"writeFully(src, length)\"), level = DeprecationLevel.ERROR)\n    public fun writeBuffer(src: IoBuffer, length: Int): Int {\n        (this as Buffer).writeFully(src, length)\n        return length\n    }\n\n    actual final override fun flush() {\n    }\n\n    @PublishedApi\n    internal fun readableView(): DataView {\n        val readPosition = readPosition\n        val writePosition = writePosition\n\n        return when {\n            readPosition == writePosition -> EmptyDataView\n            readPosition == 0 && writePosition == content.byteLength -> memory.view\n            else -> DataView(content, readPosition, writePosition - readPosition)\n        }\n    }\n\n    @PublishedApi\n    internal fun writableView(): DataView {\n        val writePosition = writePosition\n        val limit = limit\n\n        return when {\n            writePosition == limit -> EmptyDataView\n            writePosition == 0 && limit == content.byteLength -> memory.view\n            else -> DataView(content, writePosition, limit - writePosition)\n        }\n    }\n\n    /**\n     * Apply [block] function on a [DataView] of readable bytes.\n     * The [block] function should return number of consumed bytes.\n     * @return number of bytes consumed\n     */\n    @ExperimentalIoApi\n    public inline fun readDirect(block: (DataView) -> Int): Int {\n        val view = readableView()\n        val rc = block(view)\n        check(rc >= 0) { \"The returned value from block function shouldn't be negative: $rc\" }\n        discard(rc)\n        return rc\n    }\n\n    /**\n     * Apply [block] function on a [DataView] of the free space.\n     * The [block] function should return number of written bytes.\n     * @return number of bytes written\n     */\n    @ExperimentalIoApi\n    public inline fun writeDirect(block: (DataView) -> Int): Int {\n        val view = writableView()\n        val rc = block(view)\n        check(rc >= 0) { \"The returned value from block function shouldn't be negative: $rc\" }\n        check(rc <= writeRemaining) { \"The returned value from block function is too big: $rc > $writeRemaining\" }\n        commitWritten(rc)\n        return rc\n    }\n\n    public actual fun release(pool: ObjectPool<IoBuffer>) {\n        releaseImpl(pool)\n    }\n\n    actual override fun close() {\n        throw UnsupportedOperationException(\"close for buffer view is not supported\")\n    }\n\n    override fun toString(): String =\n        \"Buffer[readable = $readRemaining, writable = $writeRemaining, startGap = $startGap, endGap = $endGap]\"\n\n    public actual companion object {\n        /**\n         * Number of bytes usually reserved in the end of chunk\n         * when several instances of [IoBuffer] are connected into a chain (usually inside of [ByteReadPacket]\n         * or [BytePacketBuilder])\n         */\n        @DangerousInternalIoApi\n        public actual val ReservedSize: Int\n            get() = Buffer.ReservedSize\n\n        private val EmptyBuffer = ArrayBuffer(0)\n        private val EmptyDataView = DataView(EmptyBuffer)\n\n        public actual val Empty: IoBuffer = IoBuffer(Memory.Empty, null)\n\n        /**\n         * The default buffer pool\n         */\n        public actual val Pool: ObjectPool<IoBuffer> = object : DefaultPool<IoBuffer>(BUFFER_VIEW_POOL_SIZE) {\n            override fun produceInstance(): IoBuffer {\n                return IoBuffer(DefaultAllocator.alloc(DEFAULT_BUFFER_SIZE), null)\n            }\n\n            override fun clearInstance(instance: IoBuffer): IoBuffer {\n                return super.clearInstance(instance).apply {\n                    unpark()\n                    reset()\n                }\n            }\n\n            override fun validateInstance(instance: IoBuffer) {\n                super.validateInstance(instance)\n\n                require(instance.referenceCount == 0) { \"unable to recycle buffer: buffer view is in use (refCount = ${instance.referenceCount})\" }\n                require(instance.origin == null) { \"Unable to recycle buffer view: view copy shouldn't be recycled\" }\n            }\n\n            override fun disposeInstance(instance: IoBuffer) {\n                DefaultAllocator.free(instance.memory)\n                instance.unlink()\n            }\n        }\n\n        public actual val NoPool: ObjectPool<IoBuffer> = object : NoPoolImpl<IoBuffer>() {\n            override fun borrow(): IoBuffer {\n                return IoBuffer(DefaultAllocator.alloc(DEFAULT_BUFFER_SIZE), null)\n            }\n\n            override fun recycle(instance: IoBuffer) {\n                DefaultAllocator.free(instance.memory)\n            }\n        }\n\n        public actual val EmptyPool: ObjectPool<IoBuffer> = EmptyBufferPoolImpl\n    }\n}\n\npublic fun Buffer.readFully(dst: ArrayBuffer, offset: Int = 0, length: Int = dst.byteLength - offset) {\n    read { memory, start, endExclusive ->\n        if (endExclusive - start < length) {\n            throw EOFException(\"Not enough bytes available to read $length bytes\")\n        }\n\n        memory.copyTo(dst, start, length, offset)\n        length\n    }\n}\n\npublic fun Buffer.readFully(dst: ArrayBufferView, offset: Int = 0, length: Int = dst.byteLength - offset) {\n    read { memory, start, endExclusive ->\n        if (endExclusive - start < length) {\n            throw EOFException(\"Not enough bytes available to read $length bytes\")\n        }\n\n        memory.copyTo(dst, start, length, offset)\n        length\n    }\n}\n\npublic fun Buffer.readAvailable(dst: ArrayBuffer, offset: Int = 0, length: Int = dst.byteLength - offset): Int {\n    if (!canRead()) return -1\n    val readSize = minOf(length, readRemaining)\n    readFully(dst, offset, readSize)\n    return readSize\n}\n\npublic fun Buffer.readAvailable(dst: ArrayBufferView, offset: Int = 0, length: Int = dst.byteLength - offset): Int {\n    if (!canRead()) return -1\n    val readSize = minOf(length, readRemaining)\n    readFully(dst, offset, readSize)\n    return readSize\n}\n\npublic fun Buffer.writeFully(src: ArrayBuffer, offset: Int = 0, length: Int = src.byteLength) {\n    write { memory, start, endExclusive ->\n        if (endExclusive - start < length) {\n            throw InsufficientSpaceException(\"Not enough free space to write $length bytes\")\n        }\n\n        src.copyTo(memory, offset, length, start)\n        length\n    }\n}\n\npublic fun Buffer.writeFully(src: ArrayBufferView, offset: Int = 0, length: Int = src.byteLength - offset) {\n    write { memory, dstOffset, endExclusive ->\n        if (endExclusive - dstOffset < length) {\n            throw InsufficientSpaceException(\"Not enough free space to write $length bytes\")\n        }\n\n        src.copyTo(memory, offset, length, dstOffset)\n        length\n    }\n}\n\npublic inline fun Buffer.writeDirect(block: (DataView) -> Int): Int {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n\n    return write { memory, start, endExclusive ->\n        block(memory.slice(start, endExclusive - start).view)\n    }\n}\n\npublic inline fun Buffer.readDirect(block: (DataView) -> Int): Int {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n\n    return read { memory, start, endExclusive ->\n        block(memory.slice(start, endExclusive - start).view)\n    }\n}\n\n\npublic inline fun Buffer.writeDirectInt8Array(block: (Int8Array) -> Int): Int {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n\n    return write { memory, start, endExclusive ->\n        block(Int8Array(memory.view.buffer, memory.view.byteOffset + start, endExclusive - start))\n    }\n}\n\npublic inline fun Buffer.readDirectInt8Array(block: (Int8Array) -> Int): Int {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n\n    return read { memory, start, endExclusive ->\n        block(Int8Array(memory.view.buffer, memory.view.byteOffset + start, endExclusive - start))\n    }\n}\n","/*\n * Copyright 2014-2020 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n */\n\npackage io.ktor.utils.io.concurrent\n\nimport io.ktor.utils.io.core.internal.*\nimport kotlin.properties.*\nimport kotlin.reflect.*\n\n/**\n * Allows to create mutate property with frozen value.\n * Please note that any assigned value will be frozen.\n *\n * Usage:\n * ```kotlin\n * var myCounter by shared(0)\n * ```\n */\n@Suppress(\"NOTHING_TO_INLINE\")\n@DangerousInternalIoApi\npublic actual inline fun <T> shared(value: T): ReadWriteProperty<Any, T> = object : ReadWriteProperty<Any, T> {\n    private var value: T = value\n\n    override fun getValue(thisRef: Any, property: KProperty<*>): T {\n        return this.value\n    }\n\n    override fun setValue(thisRef: Any, property: KProperty<*>, value: T) {\n        this.value = value\n    }\n}\n\n/**\n * Allow to create thread local reference without freezing.\n * Please note that reference is thread-local only in kotlin-native. Otherwise it will be simple [value] reference.\n *\n * This reference is allowed to use only from creation thread. Otherwise it will return null.\n */\n@DangerousInternalIoApi\npublic actual fun <T : Any> threadLocal(value: T): ReadOnlyProperty<Any, T?> =\n    ReadOnlyProperty<Any, T?> { thisRef, property -> value }\n","/*\n * Copyright 2014-2020 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n */\n\npackage io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.core.internal.*\n\ninternal actual class AbstractInputSharedState actual constructor(\n    actual var head: ChunkBuffer,\n    remaining: Long\n) {\n    actual var headMemory: Memory = head.memory\n\n    actual var headPosition: Int = head.readPosition\n\n    actual var headEndExclusive: Int = head.writePosition\n\n    actual var tailRemaining: Long = remaining - (headEndExclusive - headPosition)\n}\n","/*\n * Copyright 2014-2020 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n */\n\npackage io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.core.internal.*\n\ninternal actual class AbstractOutputSharedState {\n    actual var head: ChunkBuffer? = null\n\n    actual var tail: ChunkBuffer? = null\n\n    actual var tailMemory: Memory = Memory.Empty\n\n    actual var tailPosition: Int = 0\n\n    actual var tailEndExclusive: Int = 0\n\n    actual var tailInitialPosition: Int = 0\n\n    actual var chainedSize: Int = 0\n}\n","/*\n * Copyright 2014-2020 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n */\n\npackage io.ktor.utils.io.core\n\n\n\ninternal actual class BufferSharedState actual constructor(actual var limit: Int) {\n    actual var readPosition: Int = 0\n\n    actual var writePosition: Int = 0\n\n    actual var startGap: Int = 0\n\n    actual var attachment: Any? = null\n}\n\n","package io.ktor.utils.io.core\n\nimport org.khronos.webgl.*\n\npublic actual enum class ByteOrder {\n    BIG_ENDIAN, LITTLE_ENDIAN;\n\n    public actual companion object {\n        private val native: ByteOrder\n\n        init {\n            val buffer = ArrayBuffer(4)\n            val arr = Int32Array(buffer)\n            val view = DataView(buffer)\n\n            arr[0] = 0x11223344\n\n            native = if (view.getInt32(0, true) == 0x11223344) LITTLE_ENDIAN else BIG_ENDIAN\n        }\n\n        public actual fun nativeOrder(): ByteOrder = native\n    }\n}\n","@file:Suppress(\"FunctionName\")\n\npackage io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.core.internal.*\nimport io.ktor.utils.io.pool.*\nimport org.khronos.webgl.*\n\npublic actual fun ByteReadPacket(array: ByteArray, offset: Int, length: Int, block: (ByteArray) -> Unit): ByteReadPacket {\n    val content = array.asDynamic() as Int8Array\n    val sub = when {\n        offset == 0 && length == array.size -> content.buffer\n        else -> content.buffer.slice(offset, offset + length)\n    }\n\n    val pool = object : SingleInstancePool<ChunkBuffer>() {\n        override fun produceInstance(): ChunkBuffer {\n            @Suppress(\"DEPRECATION\")\n            return IoBuffer(Memory.of(sub), null)\n        }\n\n        override fun disposeInstance(instance: ChunkBuffer) {@Suppress(\"DEPRECATION\")\n            check(instance is IoBuffer) { \"Only IoBuffer could be recycled\" }\n            block(array)\n        }\n    }\n\n    return ByteReadPacket(pool.borrow().apply { resetForRead() }, pool)\n}\n","package io.ktor.utils.io.core\n\npublic actual interface Closeable {\n    public actual fun close()\n}\n\n@PublishedApi\ninternal actual fun Throwable.addSuppressedInternal(other: Throwable) {\n}\n","@file:Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\n\npackage io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.core.internal.*\nimport org.khronos.webgl.*\n\npublic fun Input.readFully(dst: Int8Array, offset: Int = 0, length: Int = dst.length - offset) {\n    if (this is AbstractInput) {\n        return readFully(dst, offset, length)\n    }\n\n    val rc = readAvailable(dst, offset, length)\n    if (rc != length) {\n        prematureEndOfStream(length)\n    }\n}\n\npublic fun Input.readFully(dst: ArrayBuffer, offset: Int = 0, length: Int = dst.byteLength - offset) {\n    if (this is AbstractInput) {\n        return readFully(dst, offset, length)\n    }\n\n    val rc = readAvailable(dst, offset, length)\n    if (rc != length) {\n        prematureEndOfStream(length)\n    }\n}\n\npublic fun Input.readFully(dst: ArrayBufferView, byteOffset: Int = 0, byteLength: Int = dst.byteLength - byteOffset) {\n    if (this is AbstractInput) {\n        return readFully(dst, byteOffset, byteLength)\n    }\n\n    val rc = readAvailable(dst, byteOffset, byteLength)\n    if (rc != byteLength) {\n        prematureEndOfStream(byteLength)\n    }\n}\n\npublic fun Input.readAvailable(dst: Int8Array, offset: Int = 0, length: Int = dst.length - offset): Int {\n    if (this is AbstractInput) {\n        return readAvailable(dst, offset, length)\n    }\n\n    @Suppress(\"UNCHECKED_CAST_TO_EXTERNAL_INTERFACE\")\n    return readAvailable(dst as ArrayBufferView, offset, length)\n}\n\n@Suppress(\"Duplicates\")\npublic fun Input.readAvailable(dst: ArrayBuffer, offset: Int = 0, length: Int = dst.byteLength - offset): Int {\n    if (this is AbstractInput) {\n        return readAvailable(dst, offset, length)\n    }\n\n    var bytesCopied = 0\n    takeWhile { buffer ->\n        val partSize = minOf(buffer.readRemaining, length - bytesCopied)\n        buffer.memory.copyTo(dst, buffer.readPosition, partSize, bytesCopied)\n        bytesCopied += partSize\n        bytesCopied < length\n    }\n\n    return bytesCopied\n}\n\n@Suppress(\"Duplicates\")\npublic fun Input.readAvailable(dst: ArrayBufferView, byteOffset: Int = 0, byteLength: Int = dst.byteLength - byteOffset): Int {\n    if (this is AbstractInput) {\n        return readAvailable(dst, byteOffset, byteLength)\n    }\n\n    var bytesCopied = 0\n    takeWhile { buffer ->\n        val partSize = minOf(buffer.readRemaining, byteLength - bytesCopied)\n        buffer.memory.copyTo(dst, buffer.readPosition, partSize, bytesCopied)\n        bytesCopied += partSize\n        bytesCopied < byteLength\n    }\n\n    return bytesCopied\n}\n\ninternal fun AbstractInput.readFully(dst: Int8Array, offset: Int, length: Int) {\n    @Suppress(\"UNCHECKED_CAST_TO_EXTERNAL_INTERFACE\")\n    return readFully(dst as ArrayBufferView, offset, length)\n}\n\ninternal fun AbstractInput.readFully(dst: ArrayBuffer, offset: Int, length: Int) {\n    if (remaining < length) throw IllegalArgumentException(\"Not enough bytes available ($remaining) to read $length bytes\")\n    var copied = 0\n\n    takeWhile { buffer: Buffer ->\n        val rc = buffer.readAvailable(dst, offset + copied, length - copied)\n        if (rc > 0) copied += rc\n        copied < length\n    }\n}\n\ninternal fun AbstractInput.readFully(dst: ArrayBufferView, offset: Int, length: Int) {\n    require(length <= dst.byteLength) {\n        throw IndexOutOfBoundsException(\"length $length is greater than view size ${dst.byteLength}\")\n    }\n\n    return readFully(dst.buffer, dst.byteOffset + offset, length)\n}\n\ninternal fun AbstractInput.readAvailable(dst: Int8Array, offset: Int, length: Int): Int {\n    val remaining = remaining\n    if (remaining == 0L) return -1\n    val size = minOf(remaining, length.toLong()).toInt()\n    readFully(dst, offset, size)\n    return size\n}\n\ninternal fun AbstractInput.readAvailable(dst: ArrayBuffer, offset: Int, length: Int): Int {\n    val remaining = remaining\n    if (remaining == 0L) return -1\n    val size = minOf(remaining, length.toLong()).toInt()\n    readFully(dst, offset, size)\n    return size\n}\n\ninternal fun AbstractInput.readAvailable(dst: ArrayBufferView, offset: Int, length: Int): Int {\n    val remaining = remaining\n    if (remaining == 0L) return -1\n    val size = minOf(remaining, length.toLong()).toInt()\n    readFully(dst, offset, size)\n    return size\n}\n","package io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.Memory\nimport org.khronos.webgl.*\n\n/**\n * Shouldn't be implemented directly. Inherit [AbstractInput] instead.\n */\n@Suppress(\"NO_ACTUAL_CLASS_MEMBER_FOR_EXPECTED_CLASS\")\npublic actual interface Input : Closeable {\n    @Deprecated(\n        \"Not supported anymore. All operations are big endian by default. \" +\n            \"Read and readXXXLittleEndian or readXXX then X.reverseByteOrder() instead.\",\n        level = DeprecationLevel.ERROR\n    )\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual var byteOrder: ByteOrder\n        get() = ByteOrder.BIG_ENDIAN\n        set(newValue) {\n            if (newValue != ByteOrder.BIG_ENDIAN) {\n                throw IllegalArgumentException(\"Only BIG_ENDIAN is supported\")\n            }\n        }\n\n    /**\n     * It is `true` when it is known that no more bytes will be available. When it is `false` then this means that\n     * it is not known yet or there are available bytes.\n     * Please note that `false` value doesn't guarantee that there are available bytes so `readByte()` may fail.\n     */\n    public actual val endOfInput: Boolean\n\n    /**\n     * Copy at least [min] but up to [max] bytes to the specified [destination] buffer from this input\n     * skipping [offset] bytes. If there are not enough bytes available to provide [min] bytes then\n     * it fails with an exception.\n     * It is safe to specify `max > destination.writeRemaining` but\n     * `min` shouldn't be bigger than the [destination] free space.\n     * This function could trigger the underlying source reading that may lead to blocking I/O.\n     * It is safe to specify too big [offset] but only if `min = 0`, fails otherwise.\n     * This function usually copy more bytes than [min] (unless `max = min`).\n     *\n     * @param destination to write bytes\n     * @param offset to skip input\n     * @param min bytes to be copied, shouldn't be greater than the buffer free space. Could be `0`.\n     * @param max bytes to be copied even if there are more bytes buffered, could be [Int.MAX_VALUE].\n     * @return number of bytes copied to the [destination] possibly `0`\n     * @throws Throwable when not enough bytes available to provide\n     */\n    public actual fun peekTo(\n        destination: Memory,\n        destinationOffset: Long,\n        offset: Long,\n        min: Long,\n        max: Long\n    ): Long\n\n    /**\n     * Read the next upcoming byte\n     * @throws EOFException if no more bytes available.\n     */\n    public actual fun readByte(): Byte\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun readShort(): Short {\n        return readShort()\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun readInt(): Int {\n        return readInt()\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun readLong(): Long {\n        return readLong()\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun readFloat(): Float {\n        return readFloat()\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun readDouble(): Double {\n        return readDouble()\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun readFully(dst: ByteArray, offset: Int, length: Int) {\n        return readFully(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun readFully(dst: ShortArray, offset: Int, length: Int) {\n        return readFully(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun readFully(dst: IntArray, offset: Int, length: Int) {\n        return readFully(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun readFully(dst: LongArray, offset: Int, length: Int) {\n        return readFully(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun readFully(dst: FloatArray, offset: Int, length: Int) {\n        return readFully(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun readFully(dst: DoubleArray, offset: Int, length: Int) {\n        return readFully(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\", \"DEPRECATION\")\n    public actual fun readFully(dst: IoBuffer, length: Int) {\n        return readFully(dst, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun readAvailable(dst: ByteArray, offset: Int, length: Int): Int {\n        return readAvailable(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun readAvailable(dst: ShortArray, offset: Int, length: Int): Int {\n        return readAvailable(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun readAvailable(dst: IntArray, offset: Int, length: Int): Int {\n        return readAvailable(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun readAvailable(dst: LongArray, offset: Int, length: Int): Int {\n        return readAvailable(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun readAvailable(dst: FloatArray, offset: Int, length: Int): Int {\n        return readAvailable(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun readAvailable(dst: DoubleArray, offset: Int, length: Int): Int {\n        return readAvailable(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\", \"DEPRECATION\")\n    public actual fun readAvailable(dst: IoBuffer, length: Int): Int {\n        return readAvailable(dst, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readFully(dst: Int8Array, offset: Int, length: Int) {\n        return readFully(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readFully(dst: ArrayBuffer, offset: Int, length: Int) {\n        return readFully(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readFully(dst: ArrayBufferView, offset: Int, length: Int) {\n        return readFully(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readAvailable(dst: Int8Array, offset: Int, length: Int): Int {\n        return readAvailable(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readAvailable(dst: ArrayBuffer, offset: Int, length: Int): Int {\n        return readAvailable(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readAvailable(dst: ArrayBufferView, offset: Int, length: Int): Int {\n        return readAvailable(dst, offset, length)\n    }\n\n    /*\n     * Returns next byte (unsigned) or `-1` if no more bytes available\n     */\n    public actual fun tryPeek(): Int\n\n    /**\n     * Copy available bytes to the specified [buffer] but keep them available.\n     * If the underlying implementation could trigger\n     * bytes population from the underlying source and block until any bytes available\n     *\n     * Very similar to [readAvailable] but don't discard copied bytes.\n     *\n     * @return number of bytes were copied\n     */\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"DEPRECATION\", \"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun peekTo(buffer: IoBuffer): Int {\n        return peekTo(buffer)\n    }\n\n    public actual fun discard(n: Long): Long\n\n    actual override fun close()\n}\n","package io.ktor.utils.io.core\n\n/**\n * This shouldn't be implemented directly. Inherit [AbstractOutput] instead.\n */\n@Suppress(\"NO_ACTUAL_CLASS_MEMBER_FOR_EXPECTED_CLASS\")\npublic actual interface Output : Appendable, Closeable {\n    @Deprecated(\"Write with writeXXXLittleEndian or do X.reverseByteOrder() and then writeXXX instead.\")\n    public actual var byteOrder: ByteOrder\n\n    public actual fun writeByte(v: Byte)\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun writeShort(v: Short) {\n        writeShort(v)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun writeInt(v: Int) {\n        writeInt(v)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun writeLong(v: Long) {\n        writeLong(v)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun writeFloat(v: Float) {\n        writeFloat(v)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun writeDouble(v: Double) {\n        writeDouble(v)\n    }\n\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun writeFully(src: ByteArray, offset: Int, length: Int) {\n        writeFully(src, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun writeFully(src: ShortArray, offset: Int, length: Int) {\n        writeFully(src, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun writeFully(src: IntArray, offset: Int, length: Int) {\n        writeFully(src, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun writeFully(src: LongArray, offset: Int, length: Int) {\n        writeFully(src, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun writeFully(src: FloatArray, offset: Int, length: Int) {\n        writeFully(src, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun writeFully(src: DoubleArray, offset: Int, length: Int) {\n        writeFully(src, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun writeFully(src: IoBuffer, length: Int) {\n        writeFully(src, length)\n    }\n\n    public actual fun append(csq: CharArray, start: Int, end: Int): Appendable\n\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public actual fun fill(n: Long, v: Byte) {\n        fill(n, v)\n    }\n\n    public actual fun flush()\n\n    actual override fun close()\n}\n","package io.ktor.utils.io.core\n\nimport io.ktor.utils.io.core.internal.*\n\npublic actual val PACKET_MAX_COPY_SIZE: Int = 200\ninternal const val BUFFER_VIEW_POOL_SIZE = 100\ninternal const val BUFFER_VIEW_SIZE = 4096\n\npublic actual fun BytePacketBuilder(headerSizeHint: Int): BytePacketBuilder =\n    BytePacketBuilder(headerSizeHint, ChunkBuffer.Pool)\n\npublic actual typealias EOFException = io.ktor.utils.io.errors.EOFException\n\n","package io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\nimport org.khronos.webgl.*\n\nprivate fun Memory.asInt8Array(): Int8Array {\n    return Int8Array(view.buffer, view.byteOffset, view.byteLength)\n}\n\ninternal actual fun Buffer.discardUntilDelimiterImpl(delimiter: Byte): Int {\n    val content = memory.asInt8Array()\n    var idx = readPosition\n    val end = writePosition\n\n    while (idx < end) {\n        if (content[idx] == delimiter) break\n        idx++\n    }\n\n    val start = readPosition\n    discardUntilIndex(idx)\n    return idx - start\n}\n\ninternal actual fun Buffer.discardUntilDelimitersImpl(delimiter1: Byte, delimiter2: Byte): Int {\n    val content = memory.asInt8Array()\n    var idx = readPosition\n    val end = writePosition\n\n    while (idx < end) {\n        val v = content[idx]\n        if (v == delimiter1 || v == delimiter2) break\n        idx++\n    }\n\n    val start = readPosition\n    discardUntilIndex(idx)\n    return idx - start\n}\n\n\ninternal actual fun Buffer.readUntilDelimiterImpl(\n    delimiter: Byte,\n    dst: ByteArray, offset: Int, length: Int): Int {\n    check(offset >= 0)\n    check(length >= 0)\n    check(offset + length <= dst.size)\n\n    return readUntilImpl({ it == delimiter }, dst, offset, length)\n}\n\ninternal actual fun Buffer.readUntilDelimitersImpl(\n    delimiter1: Byte, delimiter2: Byte,\n    dst: ByteArray, offset: Int, length: Int): Int {\n    check(offset >= 0)\n    check(length >= 0)\n    check(offset + length <= dst.size)\n    check(delimiter1 != delimiter2)\n\n    return readUntilImpl({ it == delimiter1 || it == delimiter2 }, dst, offset, length)\n}\n\ninternal actual fun Buffer.readUntilDelimiterImpl(delimiter: Byte, dst: Output): Int {\n    return readUntilImpl({ it == delimiter }, dst)\n}\n\ninternal actual fun Buffer.readUntilDelimitersImpl(delimiter1: Byte, delimiter2: Byte, dst: Output): Int {\n    check(delimiter1 != delimiter2)\n\n    return readUntilImpl({ it == delimiter1 || it == delimiter2 }, dst)\n}\n\nprivate inline fun Buffer.readUntilImpl(\n    predicate: (Byte) -> Boolean,\n    dst: ByteArray, offset: Int, length: Int): Int {\n\n    val array = memory.asInt8Array()\n    val start = readPosition\n    var i = start\n    val end = i + minOf(length, readRemaining)\n\n    while (i < end) {\n        if (predicate(array[i])) break\n        i++\n    }\n\n    val copied = i - start\n    val dstArray = dst.asDynamic() as Int8Array\n    dstArray.set(array.subarray(start, end), offset)\n    discardUntilIndex(i)\n\n    return copied\n}\n\nprivate inline fun Buffer.readUntilImpl(\n    predicate: (Byte) -> Boolean,\n    dst: Output): Int {\n    val array = memory.asInt8Array()\n    var i = readPosition\n    var copiedTotal = 0\n\n    dst.writeWhile { chunk ->\n        chunk.writeFully(chunk, 0)\n        val start = i\n        val end = minOf(i + chunk.writeRemaining, writePosition)\n\n        while (i < end) {\n            if (predicate(array[i])) break\n            i++\n        }\n\n        val size = i - start\n\n        chunk.memory.asInt8Array().set(array.subarray(start, i), chunk.writePosition)\n        chunk.commitWritten(size)\n        copiedTotal += size\n\n        chunk.writeRemaining == 0 && i < end\n    }\n\n    discardUntilIndex(i)\n    return copiedTotal\n}\n","package io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.charsets.*\nimport io.ktor.utils.io.core.internal.*\nimport org.khronos.webgl.*\nimport kotlin.require\n\n/**\n * Create an instance of [String] from the specified [bytes] range starting at [offset] and bytes [length]\n * interpreting characters in the specified [charset].\n */\n@Suppress(\"FunctionName\")\npublic actual fun String(bytes: ByteArray, offset: Int, length: Int, charset: Charset): String {\n    if (offset < 0 || length < 0 || offset + length > bytes.size) {\n        checkIndices(offset, length, bytes)\n    }\n\n    @Suppress(\"UnsafeCastFromDynamic\")\n    val i8: Int8Array = bytes.asDynamic() // we know that K/JS generates Int8Array for ByteBuffer\n    val bufferOffset = i8.byteOffset + offset\n    val buffer = i8.buffer.slice(bufferOffset, bufferOffset + length)\n\n    @Suppress(\"DEPRECATION\")\n    val view = IoBuffer(Memory.of(buffer), null)\n    view.resetForRead()\n    val packet = ByteReadPacket(view, ChunkBuffer.NoPoolManuallyManaged)\n\n    return charset.newDecoder().decode(packet, Int.MAX_VALUE)\n}\n\npublic fun checkIndices(offset: Int, length: Int, bytes: ByteArray): Nothing {\n    require(offset >= 0) { throw IndexOutOfBoundsException(\"offset ($offset) shouldn't be negative\") }\n    require(length >= 0) { throw IndexOutOfBoundsException(\"length ($length) shouldn't be negative\") }\n    require(offset + length <= bytes.size) {\n        throw IndexOutOfBoundsException(\"offset ($offset) + length ($length) > bytes.size (${bytes.size})\")\n    }\n\n    throw IndexOutOfBoundsException()\n}\n\ninternal actual fun String.getCharsInternal(dst: CharArray, dstOffset: Int) {\n    val length = length\n    require(dstOffset + length <= dst.size)\n\n    var dstIndex = dstOffset\n    for (srcIndex in 0 until length) {\n        dst[dstIndex++] = this[srcIndex]\n    }\n}\n","package io.ktor.utils.io.errors\n\npublic actual open class IOException actual constructor(message: String, cause: Throwable?) : Exception(message, cause) {\n    public actual constructor(message: String) : this(message, null)\n}\n\npublic actual open class EOFException actual constructor(message: String) : IOException(message)\n"],"names":[],"mappings":";;;;;;;;;;;;;;;uBAmBkB,qB;4BAK0B,a;;;;;aAs0BlB,kB;;;;;;;;;;;;;;;;;;;;;;4BCzwB1B,sE;;uBCsLA,oB;mCCqBA,M;;oBCtHY,oB;kBCgPZ,kB;;;;;;;;;;oBC5JA,kB;uBChMyC,oC;;mBC2DH,a;;;;;;;iBC6CvB,mC;;;;;;;uBC/If,yC;;;;;;iBCeA,e;WA6FA,e;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;8DC5FA,a,cAKI,mBAAgB,iBAAhB,C;;IAEJ,oD;;EC1CA,gF;EAOgB,2C;;;IAPhB,gC;;EAUY,qB;IAVZ,2D;;EAAA,kEbOA,uBaPA,C;Eb2B+C,qB;;QAG3C,IAAgC,W;MADhC,+C;IAQA,wBAAoB,Y;IAQpB,oBAA4C,6C;IAC5C,gBAAyC,sBAAe,CAAf,EAAe,IAAf,C;IAEzC,gBAAA,mBAAmB,e;IAqDnB,wC;IACA,gCAA6C,GAA7C,E;;;gFAzEA,Y;;G;;WAWY,2B;;IAEJ,mC;;;;;;WAWmB,0B;;;;;EAGf,sBAAA,yBAAY,UAAZ,EAAqB,mBAArB,wC;;;GAAA,E;EAGA,qBAR6B,CAAA,yBAAmB,UAAnB,EAA4B,eAA5B,iBcJlC,IdIkC,mB;;GAAA,wB;;GAAA,E;8FAYrC,I,OACI,Y;;G;;;EAII,oH;QAEJ,kB;;;;GAFI,E;EAMA,qH;WAAA,W;GAAA,E;;WAGR,oB;;;;8FAGA,I,OAAQ,Y;;G;EAEJ,iI;;GAAA,wB;IAGkC,sCAAM,Q;GAHxC,E;;WAMJ,oB;;2FACA,I,OACI,Y;;G;;;;;;;;;2GAOJ,I,cACI,e;;;EAMR,uF;;;QAAA,qB;eAAA,C;YAAA,gB;;;;;;;;;;;;;;;;;;;kBACI,gB;;;;;UACS,oC;;;;UADT,oB;;;;G;;;;;;;;;;;;;;EAGJ,oD,sEAJA,e;;;;;;QAMA,qB;eAAA,C;YAAA,gB;YAAA,Q;eAAA,C;;;;;;;;;;;;;;;;;;kBACI,IAAO,KAAP,CAAO,qCAAP,C;;;;UACS,oC;;;yBAAA,qB;;;;;;;;;;;;;;;;;;;;IAEb,I;;EAJA,sE;IAAA,uD;G;;;IAIA,gB;gDAEA,I,GAAA,4D;;EAGa,mC;;;MAWL,U;;EAKR,qF;QAOiB,I;IAEjB,sC;;MAIc,U;M;;;IAKV,qB;IAAA,kB;IAAmB,Y;;kDAInB,M,yBAAA,I,cACc,e;;;EAKlB,6D;;;QAAA,qB;eAAA,C;YAAA,gB;;;;;;;;;;;;;;;YACI,kB;UAAA,oC;;;;;;;;G;;;;;;;;;;;;;;;;;;IADJ,kB;;IAAA,kB;;;mDAQe,iB,cACP,I;;;;;;QAMR,qB;eAAA,C;YAAA,gB;YAAA,a;YAAA,0C;;;;;;;;;;;;;;;YACI,6B;;kBAAA,gB;kBAAA,gD;;;;UACA,oC;;;UARI,oC;;;;;;EAQK,sD;mBACT,2D;;;;;;;;;;;;;uDAHJ,uB;EAAA,6E;;;;;;;YAMA,+E;YAAA,0C;cAAA,0B;YAAA,Q;eAAA,C;;;;;;;;;;;;;;kBACI,gB;;;;YAAA,kB;;;;UACA,oC;UAfO,oB;;;;;EAemC,oD;;;;;;;;;;;;;;;;EAE9C,2B;;;;eAJA,C;;;gBAAA,qC;;YAMA,Q;eAAA,C;YAAA,sB;eAAA,C;YAAA,8B;;;;;;;;;;;;;;;;UACI,oC;;;;;;;;;EApBW,kG;mBACP,0D;;;;;G;;;;;;;;;;;;;;;;YAkBR,+E;YAAA,0C;qBAAA,mB;;;;eAMA,C;YAAA,8B;YAAA,U;YAAA,qE;cAAA,qB;;;;;;;;;;;;;;;;UACI,oC;UAAA,oB;;;;;;mBACA,2D;;;;;;;;IAAS,yB;IACT,kB;;;;;;;;;;;;;;;;eAHJ,C;kBAAA,gB;;uBAAA,mB;;YAMA,qE;cAAA,qB;;cAAA,yC;;;;;;;;;;;;;;;UACI,oB;;;;;;;;;;aAhCO,iB;;;;IAiCsC,yB;;;;EAC7C,mH;;;;;;;;;;;;;;;;YAHJ,8C;YAAA,mB;;;kBAMA,gB;YAAA,sD;;;YAAA,kB;;;;;;;;;;EAAA,yG;;;;;aACI,iB;G;;IAAA,wC;;;;;EACW,uCAAO,UAClB,iBADkB,cAElB,IAFkB,8B;;;;;;;;;;;;;;;;;;;;;;QAKtB,uB;UAAA,oC;UAAA,O;;UAAA,oC;;;;;;;;;;;;;;;;IACI,kB;;;EAAA,uC,UAAA,iB;;;;;;;;;;;;;;;;;;;;;;;;QAGJ,uB;UAAA,oC;UAAA,O;;UAAA,oC;;;;;;;;;;;;;;;IACI,yB;;IAAA,gC;IAAA,4B;IAAA,sB;;;;EACY,uCelJ6B,UfmJhC,iBenJgC,cfoJzC,IepJyC,8B;;;;;;;;;;;;;;;;;;;;;gBfgJ7C,qC;;YAOA,Q;eAAA,C;YAAA,oC;YAAA,yD;YAAA,iC;YAAA,uF;YAAA,uB;YAAA,6B;YAAA,gB;;;;;;;;;;;;;;;;;;;;;;;;;;6BAKQ,c;IAAA,yB;;;;IAEqB,oC;IAAmB,gC;;EACxC,iDAEA,iBAFA,cAGA,IAHA,cAJJ,eAII,C;;;;;;;;;;;;;;;;;;;4BARR,+D;gBAAA,qC;cAAA,0B;;;oBAAA,4B;;YAeA,iC;YAAA,0F;YAAA,uB;YAAA,6B;YAAA,gB;YAAA,Q;eAAA,C;YAAA,M;;;;;;;;;;;;;;;EAGI,mC;;;;;aAAO,uB;;;;IACH,yB;;IAAA,wB;IAAA,gC;IAAA,sB;;EAEqB,qDAAJ,iBAAI,cAArB,IAAqB,cACZ,eADY,C;EAGrB,mF;EACA,0CAAW,Y;;;;;;;;;;;;;;;;;;;;;8BAVnB,gE;kBAAA,qC;gBAAA,0B;;;cAAA,wD;;cAcA,sB;cAAA,gB;cAAA,Q;;;eAAA,C;YAAA,+B;YAAA,gB;;;;;;;;;;;;;;;;;;EAEI,mC;;;;;;;;IACA,mBcWG,IdXH,EcWQ,cdXR,C;IAEO,yB;IAAe,kB;;IAAA,sB;wBAAA,Q;;;EAElB,8CAAS,OACT,iBADS,cAET,IAFS,cAFN,eAEM,C;;;;;;gBAFS,Y;;;;;;;;;;;;;;;;;;;;;cAL1B,2E;cAAA,U;cAAA,e;;;;;eAaA,C;YAAA,+B;YAAA,gB;YAAA,Q;eAAA,C;YAAA,sB;kBAAA,gB;;;;;;;;;;;;;;;mBACQ,qF;;;;;;;;;;IACqB,8B;;2DAEH,iB;EAAA,8C;;;;;gBAGlB,Y;;0BAHG,U;;;;;;;;;;;;;;;;;;;;;;;;EAJX,iH;uBAAA,oC,CAAA,I,EAAA,S,EAAA,c;;;;aAAA,uB;G;EAYA,mG;IAAA,oE;G;;QAAA,I;IAKA,gE;;;;;;;;EALA,yE;;;;;IAGkB,yB;IACd,kB;;;EAAA,qC,UAAA,iB;;;;;;;;;;;;;;;;;;;;;eAJJ,C;;;;;kBASW,gB;;;;YAEC,IAAI,c;UAAwB,qB;UAC5B,O;;;UAIA,oB;;;;;;IAMJ,wE;IAEA,c;MAAA,e;;MAAA,8B;;EAIA,yD;;;;;;;;;;;IAHI,aAAI,K;IACA,wB;;EAAA,wG;EADJ,4B;;;;;;;;kBAAA,0C;;;;;;;;;;;;;;;;;;;;mBADJ,e;;;;;;;;;;UAfJ,oB;;;;;EAyBA,mC;IACJ,2D;IAEA,c;MAAA,e;;MAAA,8B;;EAMA,yB;;;;;;;;;;;;;EAJQ,qDAA2B,iBAA3B,cAAoB,IAApB,cADG,eACH,C;;;;;;;;YAEA,gB;;;;;;YAAA,wD;gBAHG,qC;;;;;;;;;;;;;;;;;;;;;YADX,kB;;;;;UAUc,gB;;;IAAN,a;;;QAKJ,WAAO,qCAAa,IAAb,EAAa,cAAb,C;IACX,c;MAEA,e;;MAAA,8B;;EAOA,oD;;;;;G;;;;;;;;;;;kBALQ,4B;kBAAA,+D;gBAAA,wC;;gBAAA,4B;;kBAEA,cAAI,4B;cAAgD,4BAApB,G;cAA2B,6B;cAAlC,YUrP1B,I;;;;;;;;;;;;;;;;;;;;;;;;;;UViPP,Y;;;;;;EASA,qF;QAAA,wD;QAAA,S;MAAA,e;;;G;;;;;;;;;EACwB,oDAAb,e;;;gBACkB,Y;;YAqBmB,gB;;;;;YArBE,gB;YAAP,gBAAA,UU5PpC,qBV4PoC,S;gBADhC,qC;;;;gBAGH,uC;8BAAA,gC;;kBAAA,U;;;;;;cAAA,+B;qBAHG,W;;;;;;;;;;;;;;;;;;;UADX,oB;;;;G;EAAA,mC;IAMA,0E;IAEA,c;MAAA,e;;MAAA,8B;;;;;;;;;EAAA,iF;;;;;G;;;;;;;EA0cQ,yD;QAAA,yD;;;aAEI,6B;;EA3cmC,yD;QAe3C,yD;;;aAD4C,6B;;EAda,yD;QAAO,yD;;;aA2c5D,6B;;;;;IACA,kB;IAJJ,wB;;;;;;;;;;;;;;;;gBAzcJ,4B;;;cAAA,4B;;;cAMI,Q;;;cAIA,sD;cACA,IAAA,aAAK,wBAAL,C;;;;;eAI4C,C;;eAAA,C;;;YAO5C,Q;eADwC,C;;;;;;;UAME,qBAE7B,GAAA,IAAL,Q;;;UAKR,oC;UAD4C,gBACH,I;;;IADG,a;;;QAO5C,sD;QAD8C,S;;;;;;IAKlD,wC;IAAA,qB;IAAA,kB;;;;;;;;;;;;;kBAE2B,gB;;YAxBvB,gB;YADwC,gBAAA,+BACC,S;;qBADD,mB;;;gBAyBI,oC;kBAAP,YAAA,SUhTlC,qB;kBV+SI,4B;;;;gBAGH,4D;;gCAAA,4B;cAAA,4B;;;;;;;;YAHG,gC;;;;;;;;;;;;;;;;;EAKX,yB;uDANA,I,EAAA,c;;aAAA,Q;;;;EAMA,mD;IAEA,wC;IAAA,yB;IAAA,kB;IAAA,wB;G;;;;;;;;;;;kBAqZI,4B;;;;;;gCACI,4B;cAAA,+B;cAAA,6B;cAAA,Y;;;cApZ0B,gB;cAAA,uD;kBAhC9B,qC;uBADwC,mB;;;;;kBAiCI,gB;;YUxTzC,+B;;;;;;kBV+sBC,gD;;;;;;;;;;;;;;;;;;;;;IAzZR,kB;;IAAA,kB;;EAMA,sH;;EAMA,gC;;;;;;;;;;;;;;qBALe,mB;;;gBA/BX,uC;8BAD0C,WAAA,UACD,SADC,C;;kBAAA,6BAAA,gCAE7B,E;;;gBA+BgC,+BAAU,kBAAV,W;;kBADtC,0C;;;;;;;;;;;;;kBAGH,gD;;;;UAHJ,oC;;;;;;;;;;;;;;;;;IADJ,wC;IAAA,qB;IAAA,kB;;EAAA,uEAQA,IARA,cAQA,eARA,C;EAQA,6B;EAAA,6B;EAIA,mB;;;;;;;;;;;;;;cAmYI,4B;;;;;kBACI,a;;;;;;;;mBAtY2B,a;;;;sBAzCW,K,CAAA,qC;;;YAyCU,kB;UUtUjD,oC;;;;;;;;;EV2sBH,mC;;;;;;;;;;;;;6DAvYJ,uB;EAAA,yF;;;;;;;YAMA,Q;eAAA,C;YAAA,sB;eAAA,C;;;;;;;;;;;;;;;kBACyB,0C;cAAA,+B;qBAvCrB,W;;;;;;;YAuC0C,mC;YU3UvC,gB;;;sBV6UH,K,CAAA,qC;;;;;;;;UAAA,oB;;;;;;;;;;;;;;;;;4FAHJ,e;;;EAAA,uC;;;QAMA,qB;eAAA,C;YAAA,4C;cAAA,iD;;;;;;;;;;;;;;gBA2XI,0B;;;;;;;;;;;kBAGI,IAAI,KAAJ,CAAI,qCAAJ,C;;;YA1aJ,kB;UAD4C,oC;;;;UA+CE,oB;;;;;EA4X1C,mC;;;;;aACA,uB;;;;;;;;;;;;;;;;;eA/XR,C;kBAAA,gB;;YAAA,gB;;YAMA,0C;cAAA,0B;YAAA,Q;eAAA,C;;;;;;;;;;;;;;;;;;YA5CI,mC;YAD8C,gB;;;kBA8CV,gD;;;;UAEpC,oC;;;yBAAA,qB;UAAA,oB;;;;;;;;;;;;;;;;;;;;;8CAHJ,sC;EAAA,uF;;;;;;;YAMA,4D;YAAA,qC;YAAA,0E;YAAA,2B;;;;;;;;;;;;;;;;;;;;YAgXQ,gB;;;;;kBAEA,IAAI,KAAJ,CAAI,qCAAJ,C;;;YApaJ,kB;UAD8C,oC;;;;UAqDC,oB;;;;;EAgX3C,mC;;;;;aACA,uB;;;;;;;;;;;;;;;;;YAnXR,Y;;;kBAAA,gB;;YAMA,2D;cAAA,gB;cAAA,Q;;YAAA,+E;YAAA,qC;YAAA,iD;;;;;;;;;;;;;;;gBACI,qC;qBAEA,mB;;;YAGA,YAAQ,I;;;YAIJ,oCAAU,oB;mBACV,0B;kBAFG,gB;;;;;UAKH,oC;;;;;;;;;EAAA,kE;mBALG,sF;;;;;;;;;;;;;;;yDATX,uB;EAAA,iF;;;;;;;YAkBA,+B;YAAA,sC;YAAA,qC;YAAA,0D;YAAA,oC;YAAA,2B;;;;;;;;;;;;;;;kBACI,gB;;;;;;mBAAA,e;;kBACoB,UAAM,qCAAN,C;;;YAChB,kB;UACA,oC;;;UAII,oC;;;;;;;;;;;aAGJ,uB;;;;IAVJ,yB;;;IAaA,8B;IACO,wB;;;;;;;;;;;;;;;eAfX,C;gBAAA,oB;;;;YAkBA,iD;YAAA,qC;YAAA,0D;YAAA,oB;YAAA,sC;YAAA,4B;YAAA,6B;;;;;;;;;;;;;;;YACI,gB;;;mBAGe,kBAA0B,MAAS,E;kBAClD,gB;kBACA,UAAQ,qCAAR,C;;;YAG0B,kB;kCAAA,Y;;;UAAA,oC;;;;;;;;;;;aAAA,uB;;;;QAA1B,iC;;;;;;;;;;;;;;sDATJ,iB,cAAA,I,cAAA,e;;EAAA,yC;EAWA,+B;;;QAEA,qB;eAAA,C;YAAA,mC;cAAA,2C;;cAAA,kC;;;;;;;;;;;;;;;oBAEI,a;;;;;;;;;;kBACmB,gB;;mBAAf,a;;YAEA,gB;;;YAII,gB;;;2BAAA,C;;;;;;;;;;;;;UAID,oB;;;;;;;;;;;;;;;;;;+DAbX,iB,gCAAA,e;EAcA,wC;EAEA,yG;;;;gBACuB,I;eACnB,C;;;YAGmE,0C;cAAd,0B;;eAEzD,C;YAAA,sB;eAAA,C;YAAA,gB;YAAA,sE;;;;;;;;;;;;;;UAC2B,eAAA,IAAM,iB;;;;;;EAEyC,mCcrP/D,+BdqP+D,+C;mBACzD,6CAAU,IAAV,EAAe,KAAf,iB;;;;aAIb,uB;G;;IACA,yBAAC,cAAD,C;IATmD,yB;;qBAU3C,K;;;EAAA,iH;;;;;;;;gBAV2C,I;;YAQnD,oI;;;;;;;;;;;;;;;;;;;;;;;;;;;aARJ,iB;;;;MAaA,oF;;;;IAAA,gC;;;;;;;;;;;;EACI,mF;EAAA,+D;;;gBAAA,Y;;;;cACO,U;;kBAAA,iB;4BAAA,qB;cAAA,U;;gBAAP,UAAO,Y;;;;;;;;;;;;;;;;2BAFX,mB;kBAAA,Q;;;;;;YAKA,sB;eAAA,C;YAAA,+B;YAAA,gB;YAAA,Q;eAAA,C;;;;;;;;;;;;;;;;UACI,oC;UAAA,oB;;;;G;;;;;;;;;;;;;;;;;;;;;;eAIiC,C;YAAA,gB;YAAE,8DAAsD,IAAtD,C;;;YACnB,Q;eAAE,C;;eAFtB,C;YAAA,gB;YAAA,kF;YAAA,0C;cAAA,0B;YAAA,Q;eAAA,C;;;;;;;;;;;;;;;;;;;;;;;;;IAMQ,yB;iBAAsD,K;IAAO,sB;IAAP,4B;IAAtD,4B;;sDACA,iB;EACQ,yC;EAAA,uF;EAAA,iE;;;;;;;;;;;qBAAA,I;;;;;;;gBAHR,0C;;;;;;;;;;;;;;;;;;;YALR,kB;UAAA,qB;;;UAAA,oC;;;;IAYA,a;G;;QAAA,+F;QAAA,S;;;;;;;;;;;;;+DACI,iB;;;;;;;;;YACO,wD;gBAAA,qC;qBAAA,mB;;;;;;;;;;;;;;;;;UAFX,oC;gBAAA,C;;;UAAA,oB;;;IAKA,a;;EAAA,mC;QAAA,wG;QAAA,S;MAAA,e;;;;;;;;;;;;;iFACI,I,cACe,e;EAAuB,wCAAS,aAAT,yB;Ec3R/B,iDAAJ,GAAY,2B;Ed4RX,8CAAmB,e;;;gBAHyD,Y;;YAOhF,gB;YAPgF,gBAOtE,gCAPsE,4D;;qBAQxE,mB;;;;;;;;;;;;;;gBAPR,oB;;;;;;;;;;;;;;;;;;UADJ,oB;;;;G;EAAA,mC;;IAWA,c;MAAA,e;;MAAA,8B;;;IAAA,wC;;;;;;;;;;;;;;gBACI,Y;;YAAA,kB;;;;kBACO,gB;;gBAAA,uC;cAAA,gB;;;YAAP,YAAO,I;;;;;;;;;;;;;;;4BAFX,qC;;;;UAAA,oC;;;UAKA,oC;UAAA,oB;;;IAAA,a;;EAAA,mC;QAAA,oG;IAMA,c;;;;;;;;;;;2EALa,I;EAAA,wE;EAAA,2C;;;;;;gBAAA,6B;kBACT,YAAI,UAAM,kBAAV,gB;cAAkB,U;;cAAlB,gB;;;;;kBACA,IAAI,iC;uBAAU,mB;;;;;;;;YAEd,YAAO,I;;;;;;;;;;;;;;;;;;;;;;;MAGX,8B;;;IAAA,wC;IAAA,qB;IAAA,kB;;EAQA,mC;;;;;;;;;;;;;;;;;YALI,YAAO,I;YAAP,4C;;;;;mBACa,a;kBAAA,Y;;;;YACK,iBAAM,C;UACpB,oC;;;;;;;;;;;;;;;;;IAER,6C;;;;sGARA,I;IAUA,wC;UAAA,iB;IAAA,oB;G;EAGA,yB;;;;;;;;;;;;;;;;;;;;;EADS,yD;UAAA,Y;;;;;MAAA,Y;;;cADL,oB;;;;;;;;;;;EAEJ,uC;EAHA,uG;EAAA,yE;;;gBAAA,Y;;iBAAA,8B;;;cAKA,gB;cAAA,wD;cAAA,0C;;;;;;;;;;;;;;;;UACI,oC;;;;;;;;G;EAEO,iE;mBAAA,iE;;;;aAAA,uB;;;;;;;;;;;EACX,8B;;;;eAJA,C;;;kBAAA,+B;;;;YAOI,a;YAAQ,0C;;;eAEJ,C;;;;;cAIJ,U;;;kBAEI,gB;;;;YAIY,kB;UAAhB,qBe9hByC,e;Uf+hBzC,O;;UAEa,oC;UAEb,gB;;;IAGA,a;;EAEJ,yB;IAG0B,kF;QAAA,S;aAAE,Q;;;;;QACgB,I;;;SajnB5C,CAAI,KbgnBQ,C;aa/mBR,C;SADJ,YbinBY,IAAW,yBAAX,G;IahnBR,yB;IAKA,8B;Wb6mBA,S;;EAE0B,mC;QAC1B,I;SAAmC,OAAO,IAAP,Y;MAEnC,U;KAGJ,gC;WAAA,uC;;;;;;;;;;;;;;;;;;IAGI,yB;;IAAA,wB;;;;;EAAA,mC;;;;;;;;;;;;;;;;;;;;;YAHJ,e;;;;;kBAMA,gB;YAAA,sD;;;QAQA,uB;;;;;;;;;;;;;;;aAPY,uB;;;;IAER,yB;;IAAA,6B;qBAAA,K;;;wFACA,I,cAEA,e;;;EACQ,4CAAD,SAAoB,e;;;;;;;;;;;;;;;;;;cAP/B,Y;;;cAAA,gB;;;;eAWI,C;YAAA,mI;YAAmB,4F;cAEf,Y;cACA,Q;;YAIA,gB;YACA,Q;eU5jBD,C;;;kBVikBH,gB;YAAmB,sD;;;QAKvB,uB;;UAOe,MAAS,C;;UAHhB,oC;UAGJ,gBAAoB,I;;;IAGhB,a;G;;QAGA,4F;QACA,S;;;;;EAMR,uD;;MAAA,c;;MAAA,8B;;;;;;;;;;;;;;;EAG4B,mDAAO,UAC3B,iBAD2B,cAE3B,IAF2B,8B;;EAI3B,iEAAe,wC;EAAf,2D;;;gBAAA,Y;;;;;;qBAAA,mB;;;;YAJJ,wB;;;;;;;;;;;;;;;;kBAHJ,Y;kBAAA,gD;;;QASA,uB;UAEA,oC;UAAA,O;;UAAA,oC;UAAA,oB;;;IAAA,a;;;;;;;;;;;;;;;;;;EAIa,mE;;;;;;YAAL,YAAK,I;YAAU,8F;;;;;;;;kBADnB,YAGS,I;kBAHT,gD;;;YAAA,kB;;;;UAOA,eAAO,qB;;;;;;;;;;;;;;;EACX,yB;;kBAXA,gB;UAAA,a;;;;;;;IAmBQ,yB;;;;;oFAOJ,I;EAGJ,iF;EAAA,oD;;;;QAAA,qB;;;;;;;;;;;;;;;;;;;mBAIQ,wB;;;;;;;;;;;;;;;EAEA,wD;;;;;;;;;;;;;;;;;IAER,kB;;MARA,uB;MAAA,0B;;;;IAQA,I;IAYiD,W;;EAAA,mC;QAAA,I;QAAA,8B;IAI7C,qC;;;;;;;;;;;;;IAHI,kB;IACI,kB;;;EAAA,wC,UAAA,iB;;EAAA,uCAAa,4C;;;;;;;;;;;;;;;;eAFwB,C;YAAA,uD;cAAA,kB;YAAA,gC;YAAA,gB;;;;;;YARzC,YAAY,M;UACZ,qB;gBACI,C;;UAMR,YAAO,wB;;;;IAOX,a;;;QAAA,gF;QAAA,S;;;;;;;;;;;;;EAES,+DAAe,4C;EAAf,mD;;;gBAAA,Y;;;;gBAAL,IAAI,SAAC,KAAL,mB;qBACI,mB;;;;;;;gBAGJ,aAAO,wB;;;;;;;;;;;;;;;;;IANX,a;;;mBAAA,0E;IAOA,c;;;aAIQ,Q;;EAIR,qG;;IAGI,IAAI,iBAAU,I;IAAqB,UAAO,Q;IAC1C,sB;IACA,iB;IACA,IAAI,a;G;gEAGA,iB,gCAEA,e;;EAGQ,mD;;;;;eAML,C;YADP,YAAW,I;YACA,+E;YACP,IAAI,aAAS,wBAAb,C;cACI,0B;YACJ,Q;eACA,C;;;;YAJJ,a;;cAUJ,0B;YAAA,Q;eAAA,C;YAAA,oB;kBAAA,gB;;;;;;;;;;;;;;;mBACI,8F;;;;;;EACI,6D;IAAA,0B;G;;;;MAE0B,uB;MAC1B,gC;;;;;;;;;;;EAER,wB;;;;gBAPA,Y;;;YAAA,gB;;YASA,0C;cAAA,0B;YAAA,Q;eAAA,C;YAAA,sB;;;;;;;;;;;;;UAEI,oB;;;;;;;;;;aACO,uB;;;IAAA,kB;;IAAA,yB;;;;;;;;;;;EACX,iD;yEAJA,Y;;;gBAAA,Y;;;8BAAA,Y;;YAMA,qE;YAAA,0C;cAAA,0B;YAAA,Q;eAAA,C;YAAA,sB;eAAA,C;;;;;;;;;;;;;;;mBACI,I;kBAAA,gB;4BAAA,qC;;;;;;;UACO,oC;UAAA,oB;;;;G;;;;;;;;;;;;;;;;IAFX,kD;IAAA,iB;IAAA,sB;;;EAGA,gC,oDAII,I;+CAGJ,sC;EACI,yF;;;;gBAII,Y;eAEA,C;YACA,sB,OAER,E;YAEA,gB;YAAA,yO;YAAA,0C;cAAA,0B;;;;;;;;;;;;;;UAEI,oC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EgBvnBR,0B;IAEA,oC;G;EAWA,4G;IAKA,yE;;WALA,4D;UAAA,yB;QAAA,kB;UAIQ,oB;UAAJ,YAAI,iC;;QACR,O;;;YAEwE,6B;;UAExE,S;;;;MASyE,mG;;K;GAlBzE,E;EC/DA,8C;IACI,0BAAO,UAAW,IAAX,C;;G;EAMoC,sC,kCAE/C,6B,cACiB,uB;mFAoCjB,yB;QChNA,mE;QAAA,6C;QDgNA,sB;WAAuD,gD;MAAA,qE;UAChC,gE;UCzMnB,M;;QDyM+C,oB;;;;;K;GADnD,C;EAKW,wG;;;;;;;;;;;;;;;GAAA,E;;;;;;;;;;;;;;MExNX,a;;;;;;;;;;;;;;;;;;;;2BASmD,gD;;;;;;;;;;;;;;;EAI5B,sH;;oBAuFf,SAvF+B,wB;iBAuFP,a;;MAChB,mBAAA,SAxFoC,sCAwFpC,C;;;UAxFZ,wD;;;;;;;GAAmB,E;;;;;;MAsFN,iE;oBACT,sBAnFgC,CAAA,MAmFhC,oBAnFgC,C;;;;;;;;;;;2BAId,gD;oBAAA,uB;iBAAA,M;;;;;UA8DT,wD;iBACT,O;;;;;;;;;oBA3DkB,e;;;yBAAA,mB;oBAAA,M;;;;;iBA0DT,gB;;;;;;;;;;MAtDS,oE;oBAAA,kD;;iBAAA,uB,EAAA,S;iBAAA,O;;;;;;;;;;;;qFAmC1B,K;;;EAAA,sB,sCAAA,a;EAIA,uB;G;EAAA,wG;;;;;;;;;;;;;;;;;;qDAuBiB,iB,cACT,I,cAA2B,e;;EAnBI,wCAAT,6C;;;;gBAA1B,Y;;;;cAAA,0B;;;;;;;;;;;;;;;;;;;;;;;;;;YAGJ,M;eAAA,C;YAAA,sB;kBAAA,gB;;;;;;;;;;;;;;;;qBAgBQ,mCADS,mBACT,8F;;;;;;;;;MAfJ,oC;;;;;;;;;;;;;;;;;;IADJ,gD;;EAAA,uB,8DAAA,0C;EAEA,uC;;IAEA,gC;G;EAAA,6DAGiB,Y;WACT,sB;GAJR,E;;WAKsB,gBAAA,IAAN,W;;;IAIhB,+B;;EAGQ,qBADS,uBACT,UADS,EACT,MAA2B,Y;;GAA3B,CADS,C;EAAb,qB;;;EAMJ,6E;WAEiB,IAAN,W;GAFX,E;EAGgC,qE;WAChB,mB;GADgB,E;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ECvE5B,oD;WAAA,oBAAqC,c;G;;IAKzC,4C;;EACI,iCAAqC,sB;WACrC,4B;G;EAEW,iCAAc,oB;;G;EAMzB,0B;WAAA,e;;EAMkC,qBAA3B,kCAGX,YAHW,cAOP,2BAPO,C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAmFgB,4DACnB,aADmB,cAEvB,EAFuB,C;;;EA9B3B,oG;QAUI,iBAAiB,C;MACjB,UAAU,C;WAmBN,mBAAA,gBAAmB,uBAAnB,oD;G;EAKR,sB,qBAE0B,c,cAEtB,wB,cAC0B,a;;;;IAD1B,+B;;;;8CAC0B,iB;;;;;;;eAEN,C;YACpB,Q;YACA,gE;;;cAAA,8C;;;;gBAEA,8B;cAAkC,aAAA,IAAa,kBAAb,2D;;;;gBADZ,gB;;;;cAAA,Y;cAAA,Q;;;;;eAAA,C;YAAA,gB;;;;;eAAA,C;;;;YAAA,a;YAAA,0C;;;;mBAAA,a;;;;;;kCAAA,Y;UAAA,O;;;UAAA,oB;;;;;;+CAAA,W,EAAA,a;IAAA,c;;;MAAA,8B;;;IAAA,wC;;;IAAA,4B;;;EAAA,yH;;EAAA,yD;EAAA,sD;;;;eAAA,C;;;cAAA,oD;;;YAAA,wD;;;;;;;;cCnJ1B,iD;cAAA,wD;gBAAA,oB;eAAA,M;;cAAA,gB;cAAA,Q;;;;;;;;;;;;;;;;;;;YAiBiB,gB;;;;kBAAA,Y;;;;;UAIT,oC;;;yBAAA,qB;;;;;;;;;;;aAGA,uB;;;;IALJ,yB;;;;EAMU,yC;;;;;;;;;;;;;;;;;;;;;YAzBd,Y;;;;;;;;IAAA,a;;;IAAA,6F;QAcI,S;aAAA,Q;;MAGa,8B;;;IAGT,yBAAgB,cAAhB,C;IACA,yB;IACA,gBAAO,S;;IACT,sC;;qFAJF,I;;;;;;;eAsCmB,C;YAAA,gB;YAZnB,gB;;;;;;;;;mDAkBA,c;YAQyB,uB;kBARzB,gB;;;;;;;;UAWJ,oC;UAAA,oB;;;IAAA,a;;EAmBA,sF;;;;;;G;;;;EA6C+E,sG;;iBAAA,uBAEnE,O;;;UA1CR,uB;QAGI,gB;;MAEI,2F;oBACA,2D;;;QAHR,iH;;;;;;;GAqC2E,E;;;6FA3BvE,E;;;;;;;;;;;;;;;EAER,4B;EAlBA,iF;EAAA,8D;;;gBAAA,Y;;;;cAoBA,iE;;cAAA,sB;;;YAAA,2C;;;;;;;;;;;;;;;kBAEI,gB;;YAAA,gB;YAAA,qF;gBAAA,a;;;;mBACA,IAAO,S;;;;;;;;;;;;;;;IAHX,a;G;;mBAAA,6E;;aAAA,Q;;MAMA,8B;;;IAAA,8C;MAAA,iC;MAAA,M;;;;;;;;;;EACgB,4DAAA,aAAiB,UAAjB,C;;EAER,mE;;;;;;;;kBADJ,aACI,wB;gBACJ,0B;;;;;;;;;;;;;;;;;;YAJJ,Y;;;;;;;;;G;;;;MAgBA,e;;MAC+E,OACjD,uB;;;;IC3I9B,yB;IAAA,8B;IAAA,wC;;EAAA,uC,UAAA,iB,cAAA,I,cAAA,e;EAwBA,4B;;;;;;;;;4BAxBA,mC;;;;;kBAYI,gB;;oBAGa,kE;;sBAAA,K,CAAA,qC;;;;kCAAA,Y;;;UAGT,oC;UACA,oB;;;;;;;;;;;;;;;IAGA,+B;;;;;EAoCG,sF;;ICeX,yB;MAGwE,a;QhB1CpE,kB;MiBnCA,OD6E+E,GC7E3E,Y;QAAuB,kB;QjBmCtB,UAAA,mBAAuC,G;;;;;UgBgEhD,2B;QAG2D,eE8MjB,E;;;;;IAV1C,yB;;;IlBtPA,gBgB8DA,ShB9DA,C;QgBiE0E,kB;MCrHtE,M;QAA2B,OAAA,kBDqHuD,MCrHvD,CDqHuD,EhBrDnD,IgBqDmD,C;;MhB7DlF,Q;MACA,Y;;;;UmB1DJ,6B;UAAA,oD;SAOI,oBAAyB,EAAzB,I;QACA,uB;UAAA,YAAa,I;eAEb,WAAO,CAAP,C;;;;;QAGJ,mB;QAQI,c;UAAA,K;QACA,0C;;;;;;;;QAaA,c;MAAA,gB;QACA,4B;QAAA,IAAA,YAAa,O;QAEb,cAAA,oBCkkGO,EDlkGP,CAAkC,gBAAe,gBCkkG1C,U;IDjkGX,Q;;;;;IAwCA,6F;;;QAQI,oB;MACA,a;QAAA,OAAa,W;MAEb,sB;IACJ,0B;;MAEA,qB;IAAA,8D;;UAQI,2D;MACA,0B;UAAA,OAAa,Y;QAEb,2BAAe,MAAQ,cC6jGhB,GAAA,MD7jG4C,aAAnD,GAAsE,CAAtE,C;;;OA2BJ,sB;MAAA,oC;;QAQI,iC;QACA,yD;QAAA,kBAAyB,GAAA,OAAO,Q;;;;;;UAKpC,O;;aAQI,+B;;MACA,sBAAyB,0C;;;;;MA6B7B,0B;SAAA,4C;MAQI,2B;UAAA,O;MACA,wC;;MAEA,U;;;mBAGJ,C;IAAA,yB;QAQI,uC;;aACA,I;QAEA,e;;;;;UE9MJ,uB;;QFwQI,sF;QAAA,eAAoB,CAApB,E;UACA,K;QAAA,OAAA,kBAA2B,c;;;;;IAO/B,OAAA,YAWkC,E;;;IAXlC,0B;QAOI,kB;MACA,Q;QAAA,eAAoB,M;IAKxB,mD;;;ME7RA,Y;QAAA,e;QF+RA,gB;QAOI,gD;QAAA,6D;QACA,e;UAAA,cAAoB,e;UAEpB,oD;;;;UAzBJ,YAWkC,I;eE3RlC,a;UAAA,gB;;UFmTI,gB;;QACA,mB;QAAA,IAAA,IAAa,KAAb,C;UAEA,K;QE5Sc,IAAP,GAAA,kBFgRP,cA4B6C,IA5B7C,EA4B2D,IA5B3D,C;;;;;IAuDJ,gF;WAQI,c;;EACA,iC;EAAoB,iCAAO,Y;;IAG/B,I;;;EAEA,uD;UAAA,qD;G;8CASI,U,cAAA,uB;;IAGJ,mC;;;IA0BA,yB;MAAA,8B;QAQI,e;MAAA,+C;IACA,gB;IAAA,oBAAoB,GAAP,IAAc,wBAAd,iB;IAEb,oCAAsB,Q;;6FAG1B,Y;WAAA,yB;G;IASI,yB;IAAoB,+BAAO,GAAA,OAAd,O;IAEb,iCAAc,GAAd,OCmtFO,a;;;wEDxrFX,I,OAAA,Y;QAQI,+B;IAAA,mC;WACA,S;G,OAEA,mB;;G;8EAGJ,I,OAAA,Y;WAQI,+B;G,OACA,iB;IAAoB,+BAAO,Q;G;2FtB7b/B,Y;WAKI,oBAAa,a;G,OAUjB,iB;IAMI,iC;G;EACA,kFAAe,IAAf,OAEA,Y;IACJ,4C;GAHI,OAUqB,iB;IAAA,oB;GAVrB,E;EAUyC,qBAAqB,0DAC9C,IAD8C,OczC9D,oBAAc,4F;;GAAA,CdyCgD,OctC1D,wB;;GdsC0D,E;;WcnC1D,Y;;K;;EdoCY,oGAIpB,Y;WAC8E,oB;GAL1D,2B;QAMhB,2B;Uc7CI,gCAAe,oDAAf,W;;KAEQ,kC;GdqCI,E;;WAK0D,gC;UAK9E,oB;QAEI,+C;MAEA,MAAI,6BAAJ,iC;M;;QyB4JI,Y;aACA,I;wBACW,I;QzB5JF,mCAAA,WAAuB,QAAvB,2E;aHqBb,I;WACI,yBAdW,K;;EGNX,8C;;IAFA,sC;kBAMI,S;iBANJ,E;;wBAAA,iB;;sByB4JI,mB;WACA,MAAI,gB;;UACJ,YAAO,mBAAiB,GAAA,KAAM,aAA9B,I;;;QAGJ,sC;;QzBtJJ,6BAAmB,uF;;QAcvB,yB;QAC+C,uC;;QAC/B,OAAU,cAAA,MAAJ,KAAI,oB;;MC6TS,mB;MD5T3B,iB;QADJ,K;OAmB6B,c;;;;;;;;;MAIjC,iB;QACI,oC;QACA,OAAO,K;OAcX,0D;MAEI,uD;QAAA,mB;QACA,W;;QAEA,gB;QACA,IAAI,wB;;MACJ,YAAA,SAAa,oC;;;WAGT,I;;EAEA,qBAAa,sDACT,IADS,mB;WAGT,MAAO,a;GAHE,E;EcxIjB,uBAAc,uB;;G;EdgJN,wD;Wc7IJ,oBAAO,qBAAP,yB;G;EACF,yEACE,IADF,mB;;GAAA,E;8Ed6II,I;WAEF,cAAO,M;;EAEf,M,sEAEA,I,OACI,Y;YADsC,IACjB,iB;G;EACK,+B;QAAN,gB;QAFkB,QU3G3B,iCV2G2B,Q;;MAAA,mB;;MAO1C,2B;;EyBgC4B,gCzB5BxB,Y;;QyB8BI,qC;MACS,oC;KzB7BL,kB;G;;eAGA,S;;QAEJ,c;;;IyByBW,iC;;;EAGX,uBzBnCJ,c;;QAWA,OAAO,S;IACX,qD;IAEA,mB;MAMI,W;QACA,IAAI,Q;MAAkB,mB;MAEtB,4B;;;MyB2BI,4B;;IAEW,gB;WAAA,I;;EzBzBX,uBAAS,mC;QH9GT,UG+GM,iCH/GN,Q;;eAEA,YAAM,O;QG8GN,wBAAS,iCAAT,Q;MACA,2B;MAGI,4B;;eACA,mB;;;G;;eyBkBA,mB;eACI,mB;eAAW,I;;;SAInB,I;;IzBlBJ,oC;QACA,SAAO,S;;;MStNX,0F;;WAOgB,I;;;IAPhB,6B;QASgB,YAAM,a;IACV,sC;MAVZ,6B;MAAA,0C;KAAA,oC;;EiBq0BI,8C;QA3zBA,I;QAAA,QAAoB,iB;QACpB,6B;UAAA,QAAA,IAAuB,WAAL,KAAlB,e;MACA,yB;UAAA,OAA2C,mB;MAA3C,8B;MAEA,uBAAoB,M;MAgMpB,Y;;;IAnKI,gC;WAAQ,I;;EACR,iC;WACI,iB;;EAEA,gD;WACA,iB;G;;;;EAMJ,uB;WAAc,e;;EpBwCX,uB;;;EoBrCC,yC;;;;;;WAKI,Y;;K;;;;;;YAOA,sC;;EACR,4C;QACI,6B;MACJ,gF;;;;;WAIQ,iB;;oBACR,kC;UACI,oC;;;;;;UAMW,MAAA,0BAAmB,2C;aAClC,sC;UAEI,+B;;;;;K;;;;;WAIJ,oB;UAAQ,I;;2BACR,M;;QjBrFA,a;;YiBuFI,mC;QACJ,mC;;;UAOA,uB;;;;;K;;;;QAQA,OAAI,S;SAAU,qB;MACd,OAAA,gBA3Be,E;SA4BmD,OAAO,IAAP,6B;MAElE,OAAO,E;IACX,4H;;;QAGI,I,EAAA,M;IAEA,sC;QACA,Y;MACA,S;SAEkB,OCjHsC,I;QDiHxD,SAAA,YhB0JO,uBAAJ,GgB1JqB,C;QAExB,IAAA,IAAO,iBAAA,IAAS,aAAO,I;eACH,qB;IAAhB,cAAA,MfpDqC,yBAAgB,MAAhB,CAAgB,sBeoDrD,a;WACA,I;;EACe,uBAAwB,gBAAc,gB;QAAjD,YhBqJD,K;agBpJC,E;WAMA,sC;G;;;IAIA,wB;;;QAGM,I;;WAAV,I;;;IAIR,gB;;MAOI,gBAAiB,MAAN,wBAAM,a;MACjB,aAAA,IAAgB,mBAvED,I;;MA0EX,iB;WACA,IAAI,K,EAAA,CAAJ,O;QACI,kF;;YAKJ,I;;;;;EAKI,gGAGJ,YAHI,C;;QAIC,e;MAET,OAAO,E;IACX,mF;;;EAKiC,uB;QAAQ,QAAc,M;;;;QAKjB,wCAAgB,gBAAoB,K;;;MAK7B,e;;;EAOzC,uB;IAAQ,4D;;;;;QAKR,c;MAAQ,gB;;;;;aAKR,oB;QAAQ,YA7HO,oBAAmB,gBAAA,aA6H1B,MAAsB,EAAtB,CA7H0B,EA6HJ,GA7HI,E;;;;EAqIvB,uB;WACX,qBAAY,kC;;EAGR,2C;QACA,sB;aACK,C;;;QAKT,Q;;QAEI,0CAAwB,K;SAE5B,c;;qBAIA,C;QACA,WAEA,KAFA,C;;MAIA,gB;MACA,kB;;;QAIA,qB;OAEA,cAAY,I;;;UAIR,oB;UACA,gB;;;;YAMQ,+B;;;8BAIhB,0B;cACkB,mCAAY,G;;gBAET,SAAN,WAAM,mB;gBACb,mB;gBACA,IAAA,MAAQ,EAAR,S;kBACA,eAAgB,Q;;kBAEhB,iC;kBACA,2B;;;;eAMO,If3M8B,Me2M9B,C;gBAEP,M;;gBfxMsC,uB;;YeyMrC,SAAL,YAA8B,QAAzB,I;YAED,MAAS,qB;YACT,kBAAwB,O;;;UAExB,6B;;YAGG,Y;;;;YAKP,MAAgB,O;YACZ,YAAY,Q;;UAGZ,IAAO,aAAP,C;YAGG,gB;;;UAIP,IAAY,cAAZ,C;YACI,gB;WAEA,iB;UACA,OAAW,O;UACN,c;;QACL,a;;QAIJ,Y;UACA,kBAAgB,e;;;;;MAMoB,0F;;MAGA,wC;;;EAGE,6D;;;EAI/B,iD;IACX,6G;;EAIW,2D;IACX,4H;;EAOa,0CAAmB,GAAnB,yB;QACT,SAAU,M;;MAQM,gB;MAAE,kB;;;;OjB3VlB,kB;MAKA,IAAE,Q;;;UiB8VE,mB;UAAuB,aAAA,KAAa,iBAAA,KAAoB,aAApB,I;;;;cE1WhD,oB;cF6WI,gB;;;;;gBEjWQ,oBAAgB,M;gBAGhB,aAAiB,MAAO,O;gBACxB,YAAA,MAAW,a;;gBAEX,iBAAe,KAAf,gC;;;;;;oBAlBZ,mB;oBAAA,qB;sBFmXI,e;;sBE7Wa,iC;sBACb,MAAqB,EAAO,mB;;;;sBAIxB,MAAoB,qB;sBAChB,iB;sBACM,sB;4BAGN,sB;;oBAEA,OAAe,I;;;;;wBFuWvB,iC;;;;;oBASQ,6B;;oBAEG,uBAAA,YAAgB,GAAhB,KAAA,M;;sBAGX,mC;;;;;oBfvT8C,IAAA,Se4TzB,Ef5TiC,MAAR,C;sBALD,IAAA,cAAgB,CAAA,KAAhB,EAAgB,CAAhB,C;wBDkMjC,uC;wBgBgIP,qB;;;;;;0BAOM,oBAAwB,I;;wBAMrB,uB;0BAAA,2B;;;;wBAIF,mBAAA,KAAY,EAAZ,C;;;;;0BAKI,iB;;0BAEA,GAAO,e;;;;wBAGH,aAAY,kB;;;;;4BAQd,iB;;;;;;;;0BAtBd,oE;0BA0BO,iB;;;;;;gBASK,SAAA,YAAgC,Y;gBACpC,2B;gBACK,iB;;cAEN,c;;;gBAOP,YAAc,I;;;;;;cAM2B,mB;;;cAEzC,KAAgB,mD;;;YzBlDW,KAAxB,S;;UK/UA,OL+U6C,Q;;;;;;cyBmErC,IAAP,iB;;aACkB,IAAO,MAAP,C;;;;cAClB,M;;UAGJ,iB;UACA,IAAA,IAAW,IAAX,IAAA,C;;WG5PJ,OAAc,O;UACA,c;;gBAAA,I;;QAAd,Y;;;;IAIa,c;QH0PW,c;;WfpFf,Q;G;EAAA,yD;;kBmBjZD,E;;;;;;;eJwemB,CAAP,wBAAO,CAAA,e;IACX,kC;IAHJ,gD;;;;EIpeA,yDAAa,yB;;;;WnB+YzB,wBmB1YI,G;gBJ8da,I;;;YAAT,4C;eAUI,M;IAAM,kC;IACN,gD;IAXJ,yBAWqB,OAXrB,C;;G;EAAA,sD;;QG1PA,WAAI,C;;WAGJ,wB;QACW,Y;aAAA,M;mBAAX,I;YACA,qB;eACA,UAAU,W;;IACL,wC;;;MAGL,UAAA,qBAAiB,uBAAjB,W;;;MHmQJ,MAAI,sG;;MAGA,SAAA,MAAS,OAAT,I;;WACJ,M;;;UAIA,IAAM,YAAN,CAAM,6BAAa,2CAAnB,kB;;EAEJ,2E;QACI,cAAM,qBAAyB,gB;;;;G;EAO/B,uB;;;EGtQJ,uB;WACc,gC;;EAAqC,0C;WAAnD,yB;;;;;QAKQ,Y;aACA,sC;;oBAIe,qB;iBAAA,gB;sBH8PG,wB;;;KIzZ1B,kC;QnB6RS,uB;Me4HU,+B;Mf5HV,wBAAA,Oe4HU,c;MItZD,+BAAA,IAAd,8D;;MAGQ,0B;MACQ,yJ;;MACC,wBAAA,IAAW,KAAX,C;;;EJkZT,yD;;MAEQ,wC;MACJ,6C;MAHJ,iC;;gBIjZQ,4CAAqB,I;iBACrB,gC;kBAAA,mB;;;;kBASJ,kB;MACQ,8B;mBACA,iBAAQ,E;+BACR,O,EAAO,I;MACP,2B;;IAEA,kC;;;iBAIR,kB;iBACA,kB;IAEI,+B;IACA,+B;;kBACA,mB;;sBAKJ,M,EAAA,O,EAAS,O;IACT,4B;IAEI,mD;;EAES,4CAAe,6B;;;aJ8WhC,uB;gBAEQ,mB;4BACJ,S;;;MIjXY,iC;aACA,uC;;UACA,sC;;QAGJ,qI;;;eAEK,sC;;;G;EJyWT,2C;iBACJ,kB;;;mBI1WY,+F;;QAC8B,2C;cAA7B,0C;UJsWb,iC;;UAGA,oC;;;;QI1WQ,iC;;;;;G;;;MAcL,2C;;;;;gBJkWP,W;;;;KAVJ,gC;;;;;;;;eGzPI,QAAQ,qB;;MAGF,2B;WAGN,wC;gBAAc,4D;;;;MACE,iB;;;;;eAIR,S;;aANZ,I;WASA,8B;;EAIA,uB;SACA,qB;;WACK,8B;;EAEL,uB;cACA,M;;;;IHkPA,iBAAS,IAAT,+C;QAAc,c;MAElB,OAAO,I;;QAKO,Q;MADd,IAAI,kDAAJ,C;QAAa,wB;OACC,oD;;UAAd,0C;MACW,aAA4B,iBAAtB,Of/dwB,Ie+dxB,Ef/dwB,iBe+dxB,C;MAAjB,qBhBpRO,qB;MgBqRP,4BAAqB,qE;MACrB,8C;QACA,gB;QAEA,SAAO,mB;;;QAKO,4B;;;SAAA,sC;MAAA,W;QAAkB,OAAO,I;MAAvC,8B;WACW,IAAM,oCf1ewC,Ie0exC,C;;EACT,iD;UACR,qG;;EAGO,8D;IACX,uD;;M;EAG4B,uB;QACV,I;QAAA,2F;IAAkB,mB;IAAhC,4B;IACW,oBfrf8B,W;WeqfzC,I;;;IAKW,gC;;Ef1f8B,4Ce0flC,Wf1fkC,ce2frC,Wf3fqC,ce4frC,Ef5fqC,C;;;;Me0fzC,6B;;;EAUJ,a,6CAMI,e,cAEI,O;;IAqBe,6B;IAAA,SAAR,O;IAAA,oB;IAAgB,wBAAO,qC;;EAElC,qBAAgB,CAAA,cfniByB,UemiBzB,oCACmB,IADnB,OAChB,Y;WACI,IAAK,gBAAW,K;GAFJ,OAMX,iB;IAEL,oBAAgB,a;GARA,E;EAWZ,sBAAA,cAAgC,UAAhC,EAAgC,iBAAhC,iBACA,IADA,mB;WAGA,oBAAa,K;GAHb,OAKA,iB;IACA,oBAAQ,QAAQ,K;GANhB,E;EAQR,M,oFAGI,Y;QACI,I;WACgC,CAAhC,2BAAgC,4D;G;EAEhC,qB,kDAGO,I,OACG,Y;WAAd,6B;G;EAGI,+DAA2C,0BAE3C,Y;WACA,IAAI,yB;GAHuC,OAMvC,oB;IACJ,kC;GAP2C,CAA3C,C;EAUJ,qBAAQ,uF;WAOR,oBAAkB,W;GAPV,OAUR,iB;IACA,oBAAO,mB;GAXC,E;EAaR,qBAAc,kEAEP,IAFO,OAGP,Y;WAEP,oBAAa,a;GALC,wB;;GAAA,E;EAUV,qBAAY,sEACL,IADK,OAIhB,Y;WACA,IAAQ,gBAAQ,iB;GALA,OASR,iB;IACA,qC;GAVQ,E;kGf7SsB,I;We4T9B,wC;;IAGI,wCAAW,GAAX,K;;EAXZ,qB;WAqBA,oBAAkB,Y;UAEd,iB;IACA,oBAAa,eAAK,K;G;EAGd,gDAAwB,uBAAxB,iBAEK,IAFL,OAGW,yH;WACP,6B;GADO,CAHX,E;EAUJ,qB,8DACF,Y;WACE,0BAAe,mE;G;;;WAMd,wB;;;QASL,KAAI,uC;YAAuB,6B;;EAGvB,6C;IACA,yB;G;;IAIR,Q;IAMqC,8B;QACzB,IAAM,Q;;SAEY,UAAN,I;;MALpB,IAAI,M;UACA,iB;;YjBnvBJ,e;QAKE,kB;QiBkvBE,qB;;UAEA,K;;;;;MAOJ,WAAW,OAAX,Y;;;EAEO,yCAAgB,e;IAC3B,gB;;QAII,IAAI,Q;aAA4C,I;KAEpD,e;;IAMoB,oB;IAHhB,oBA/rBe,O;IAgsBf,yB;IAAyB,6B;IAEd,sC;IAAA,0B;IAAyB,uB;WAApC,I;G;EAGQ,wBAAS,4BAAY,Y;eACrB,iB;QAGJ,SAAO,iCAAgB,Q;;QAEvB,6B;QACA,MAAA,0BAAa,CAAA,OAAuB,SAAM,EAA7B,C;OAEb,oB;MACA,4BfhakC,Cega7B,Ifha6C,yBAAhB,C;Meia9B,0B;MACA,yBAAiB,qB;MACjB,kC;;M;;QAMR,EAAI,MfjuBqC,aeiuBzC,C;UAAmC,+C;MACnC,MAAI,0BAAJ,oB;KAEA,8BAAO,mB;;;QAIP,OAAM,c;IACV,4G;;QAGI,Sf5uByC,ee4uBrC,U;MACA,wC;;;;EAKY,wBAAL,wC;QACX,0B;IACA,8B;IACA,8BAAa,O;WAEb,K;G;EAGJ,kD;QAAA,4B;;;;;;;;MAAA,iH;;IAAA,8B;IAAA,8E;;;;;;;IArzBA,qC;QAEmB,qC;MAAA,yBAAiB,gB;MACxB,4B;;YACA,IAAgC,+B;;;IAAoB,6BAAK,uB;IAJrE,yB;;EKHJ,6C;;MAEI,Y;;MA4FA,uB;;G;;;SAvEY,6BAAM,e;;cACd,K;UACI,kB;MACJ,uB;;;;QAGA,sB;QAAQ,kE;;aACR,4B;QACI,gE;;;;;QAIJ,sB;QAAQ,S;QAAA,oDAAA,GAAS,cAAT,E;;;;;;UAMJ,OAAO,kB;MACX,I;;;WAIA,I;;;iBACA,6B;;MAEA,6B;;;;UAGA,kB;QAAQ,+BAAM,SAAN,C;;aACR,0B;QACI,+BAAA,MAAmB,mBAAnB,C;;;;;QAIJ,sB;QAAQ,uBAAA,MAAM,QAAN,EAAM,MAAN,e;;aACR,+B;QACI,+BAAA,MAAqB,mBAArB,C;;;;;;QAII,qBAAA,kBAAM,G;;iBACd,kB;MACI,kC;MACJ,iB;;;;;;;;;;;;;;;;EAaI,uCAAoB,8B;;;;;G;;;;;;;QAUxB,a;MAEA,I;;;;EAEJ,iD;;QAWI,a;MACI,qC;;;;;QAUJ,I,EAAA,M,EAAA,M;IACJ,I;mBAEA,0C;QACkB,uE;QAAA,kC;QAAA,+B;QAAc,M;MAA5B,SAAA,QAAc,kF;S1B3BI,M;MAHtB,e;;MAEI,S;qB0BgCQ,I;Q1B/BU,WAAR,W;MAAA,iB;;MAAV,W;;QACK,iB;;W0BiCO,IAAA,gBAAW,EAAA,IAAX,UAAW,eAAX,C;;;kDAIhB,I;QAKoB,wB;OAAL,6B;WAAc,IAAO,UAAP,oC;MAAzB,qC;;MAIA,mF;;;EAGA,yD;QACA,I;IACA,uC;QACA,M;SAEA,IAAO,uB;;;MAIP,iH;;QlC1EJ,QkC4Ec,M;QlC3EV,c;MACA,oBAAM,gB;;UkC4EF,MAAK,K;aACA,I;QACL,yBAAA,GAAe,KAAf,C;QACA,kB;UACA,K;;;MlClFR,QkCuFU,gB;;IlCrFN,oBAAM,W;IkCsFN,8C;;iDAGJ,gB;QACI,I;QACkE,kB;WXvLlE,e;UAAuB,gBAAA,kBAA8B,GAA9B,CAA8B,aAA9B,I;MWuLvB,qBAAA,SXtLG,EWsLH,C;QACA,cAAA,2BAA4B,I;;;UAI5B,UAAU,YAAV,CAAe,0BAAf,C;SAGA,8BAAkB,M;;;qBAKtB,8E;QACI,qBAAY,mB;;UAER,wC;;;UAGA,mC;YACA,MAAA,0BAAmB,2C;WAEnB,2C;;;YAIJ,8B;;;QAGA,K;;;G;EAKY,4C;QACZ,I;QACI,kB;WAEA,S;UAGJ,gBAAO,oBAAA,CAAkB,iBAAlB,sB;;;QAIP,wB;QACA,iB;;;;;QAUI,2F;;;sCAIR,mB;;UAKQ,uC;UACsB,IAAA,aAAX,iBAAW,C;YAAA,MAA4B,0BAA5B,2C;WDqG9B,IAAA,aAAQ,yBAAR,C;YH1TI,oBAAK,CIqNiC,MJrNjC,C;;YG8TT,8B;;;;;;;EAQI,wBHtUK,eIqNiC,GDiHjC,2B;IAbsD,gE;;G;EAkB3D,wBH3UK,8BG2U8C,gC;cACnD,K;QACA,U;aApB2D,G;;IAAA,qB;;MCpGvD,iD;MACA,qB;;WAIJ,G;G;EAEJ,c;;;;IAIiC,qB;;EAAoC,wB;QAApC,iG;WD0FjC,wB;UH1TI,kB;QGyT2D,2B;;aAM3D,QH/TA,IG+TA,C;YACA,0B;YAP2D,yB;oBAU/D,uB;YACI,iBHpUK,SGoUA,MAA0C,QAA/B,I;YAChB,cHrUK,I;gBGsUL,+BAAK,OAAqC,CAArC,EAAqC,cAArC,C;wBAGJ,M;YACD,SH1UA,K;QG2UA,aH3UA,QAAK,SG2UA,MAAS,CAAT,GH3UA,GG2U8C,OAA/B,KAAN,CH3UT,C;QG4UL,aH5UA,QAAK,CAAA,MG4UA,QH5UA,EG4UA,MAA6C,OAA9B,KAAU,CAAA,KAAoB,CH5U7C,C;QG6UL,aH7UA,QAAK,CAAA,MG6UA,QH7UA,EG6UA,MAAqC,OAAtB,MAAsB,CH7UrC,C;YGyTsD,M;;eAAA,C;;YCzFvD,4B;YAmPmB,WAlPZ,gB;YAkPP,iC;YlC7ZR,gD;YACI,gBkC6ZyB,I;gBlC5ZzB,+BAA4B,SAAQ,CAAR,EAAQ,gBAAR,C;akCgaxB,mB;;;gDAlPR,oB;QACI,IAAI,Q;QACA,qC;;;K;;EAKR,c;;;EAIe,iD;QAGX,I;SAEA,IAAO,yB;;;QAOP,W;eAGI,I;;EAIA,wB;QACA,I;SACA,I;MAGJ,8C;;EAOY,sC;QACZ,6E;WACI,uB;UACA,4C;;;;UAca,wD;UAPjB,MAAK,2BAAA,OAAwB,WAAxB,C;SAGL,a;;QAIqB,qB;;K;;EACjB,wB;;UACG,0D;MAFP,oD;SAMQ,uE;;YACG,0B;KAEX,yBAAI,GAAoB,yBAApB,Q;;EAGO,qCAAqB,qB;QAEvB,I;IACL,8B;G;EAEI,wC;;WAIG,qBAAc,IAAd,yBAAkC,EAAlC,W;;;;;;IAaC,wD;IAAA,mC;WAAA,K;;;;;IAQJ,oBAAW,kB;IACX,0B;;;;;8CAOH,U,cAEL,uB;EACJ,wB;;IAYgC,W;IAN5B,0B;IAEA,aAAO,8B;G;EAEH,qBAAI,CAAA,MAAiB,UAAjB,iCACA,IADA,mB;WAEkB,0B;GAFlB,wB;;GAAA,E;EH/XZ,qBAAa,mDACb,IADa,mB;WGoYG,0BHjYN,c;GAHG,wB;IAML,wCAAgB,Q;GANX,E;EASL,wCAAwB,UAAxB,iBACA,IADA,mB;WAGA,0BAAe,S;GAHf,wB;;GAAA,E;;WG4YwB,I;UAJ5B,iB;IACI,0BAAoC,c;G;EAEhC,kDAAa,eACO,IADP,yG;WACkB,aAAM,aAAa,I;GADrC,EAAb,C;0EHpZC,I,OAAA,yG;WACb,qBAAqB,iB;GADR,C;EGwZG,sBAAA,MHrZN,UGqZM,EAAiB,gBAAjB,4BHnZZ,0G;WACA,UAAI,qBAAgB,I;GADpB,CGmZY,E;EH/YR,wCAAwB,YAAxB,iBACA,IADA,mB;WAGA,0BAAe,W;GAHf,wB;;GAAA,E;;IGoZR,qB;cAEA,0C;SAEI,KAAO,M;;;QAQP,QAAU,CAAA,wC;MACV,aAAW,CAAX,KAAW,6C;KACX,iBAAM,kB;;EAGN,gBAAa,gB;QACT,IAAA,IAAuB,cAAjB,oBAAiB,GAAM,C;QAC7B,2B;;WAGJ,I;;;QAKA,mE;IACJ,8D;;WAII,mB;;;QCmPR,iD;QDhPI,0C;MAEI,+D;;;EAKI,gD;gBpBtCC,U;QAAA,WAAA,IAAc,c;MqBsRnB,oBAAA,QrBtRkC,qBqBsRb,IAArB,sC;SAEI,YAAM,K;UAEV,kB;QAAA,kBAAc,W;eDnPN,K;OJzaH,oBAAA,QI2aU,GAAA,IAAS,cAAM,IJ3azB,EI2akC,IAAM,MJ3axC,0B;KhBmYT,6B;WoB+BgD,I;;EAcxC,0C;QpB9CC,gBAAA,QAAM,qB;MAAN,cAAA,QAAc,oBAAd,iD;SqBuRL,iBAAI,a;MACM,4B;;EDzOF,gBJjbR,eIibe,oB;QACP,UJlbR,KAAK,C;MhBkYT,6C;0BACA,iBAAc,GAAd,K;;;;G;;;;;;EoB+DQ,+D;UACO,a;UACH,wE;MAGR,U;;MAKA,a;MAAA,M;;;QlChaR,mD;OkCqaQ,kBAAa,W;;MAET,wB;;KlC3ZE,yC;G;;WkCgaF,Y;;K;;;QlClaR,EAAI,MkCyaW,KlCzaf,C;UACI,gCkCwagB,mClCxahB,C;MACM,U;SADN,WAAA,akCya4B,a;QlCxa5B,QAAM,sB;MkC2aN,qB;;SAMkB,Q;MAAlB,oCAAkB,c;;MAOmB,oC;;;;;;;;EApgBzC,4C;IAAA,iB;IAAoD,qB;QAApD,wB;;G;EAEA,6C;IAAuB,0BAAK,CAAA,6BAAY,IAAZ,C;G;;ItBnBhC,4B;IAAA,4B;IAAA,6B;IAOgB,kB;;;IAPhB,+B;IASgB,0BAAM,E;;EATtB,qD;IAAA,0B;G;;IEawB,mB;aAkWpB,yC;K;;;;;;;EAxVY,wCAAY,8B;;cACpB,2E;MACI,U;;;;KAUI,mC;;MACR,+B;M;;;;IAQA,qC;IAAQ,uC;;EACR,0B;QACI,mC;;;;;;QAWI,mC;;WACR,wB;;;;;;;WAOkC,wBAAW,c;;;;;;;;;;;QAeH,kBAAA,IAAQ,M;;;;;EAQ1C,qC;;IACR,oB;G;;;;;IAdyC,gC;IAwBzC,iB;;EAEA,sBAAA,gBAAsB,UAAtB,EAAsB,OAAtB,iBACY,IADZ,OAEI,Y;WAEJ,8BAAe,E;GAJf,E;uCASW,W,cAAX,W,cACA,E;MACA,gC;EACJ,wC;sCAEA,I;MAEe,sB;KACX,gC;G;EAEJ,M,6CAII,Q,cACI,E;;UA6BA,iBAAc,4BA/EuB,qBAAgB,aAAA,GAAhB,wBA+ErC,C;;;;;;UAYU,6BAA4B,wF;;;QAGtC,WAAa,SAAO,S;MAExB,mH;KAQuB,gL;;;IAA8C,oO;;;IF7KzE,ME6KY,6BF7KZ,wE;;;UE+KQ,6B;;;UAKA,6BAAgB,uL;;;IAKhB,iC;;;QAGA,O;MAGJ,iC;;IASqB,wC;;EAAE,6H;;IAKnB,oE;;WAIA,K;;;QAaJ,gD;;2BAGJ,uB;MAII,0B;KAGA,UAAA,SAAe,O;IACf,gBAAA,SAAgB,c;;;IAOhB,kC;;6CAGJ,S;IAMI,a;IACA,0BAAe,I;IACf,a;IACA,+B;;;;IAQA,uD;;;MAIA,yF;KAI8B,6C;IAAA,2B;IAAE,gC;IAA0D,S;;;;QAEtF,oDAAA,kBAA2D,qBAA3D,CAAA,SAA8E,S;;4BAHtF,uC;IF3QA,IAAI,cE4QQ,gBF5QR,sB;QACA,e;MAKA,SAAE,sB;;;EE2Qa,6C;;IAEX,oBAAW,kB;;;EAKF,iC;UACb,6B;;EAEqB,4F;;ILnNzB,mB;aKyNsC,+B;K;;;IAalC,OAAI,Y;UAA+B,OAAO,6DAAP,wB;UACnC,QAAO,S;MACX,qD;K;;;QAWuC,a;MACnC,oCAAoB,WAApB,Q;MACA,QAAO,E;qBAGX,yC;MAQI,sE;MACA,GAAI,S;KAGJ,yBAAoB,uBAApB,e;IACA,SAAO,sBgB5TK,ChB4TE,KgB5TF,C;;;QhBwUZ,UgB1TA,EAAK,c;MhB2TL,uBAAqB,Q;;;;WA4BI,a;;;;;;;;;;;QAb7B,yB;QAAA,+B;;;;;;;;WAoB0C,0B;;;MAKC,sB;;;MAc3C,WAAS,QAAM,CAAA,SAAN,GAAc,CAAR,EAAQ,aAAA,KAAd,CAA4B,KAAd,CAAR,C;MACf,oBAAA,SAAa,IAAb,uB;MACA,kB;;;MAeA,WAAS,QAAM,CAAA,SAAN,GAAc,CAAR,EAAQ,aAAA,OAAe,KAAf,CAAR,C;MACf,oBAAA,SAAc,GAAd,CAAA,4B;MACA,MAAO,K;;;MAIP,kBAAM,GAAa,qB;;IAGvB,6B;IACI,IAAA,IAAM,IAAA,YAAa,YAAb,CAAN,C;;;MAIA,YAAM,O;;IAGV,qB;IACI,SAAI,sBAAW,I;WACX,S;;EAmCR,8B;IAGuC,+G;G;MAzDnC,mB;;EFvaJ,4D;IASgB,IAAA,UAAM,WAAN,C;;IAThB,wB;MAAA,e;IAAA,yB;;IwBWwB,gC;IAAA,8B;IAAE,4B;G;;IACW,4E;;;;IAAE,qBtBoEW,wBAAQ,qB;;;EsBzE1D,oD;IAIY,qB;QxBJJ,aAAA,8BwBIgB,Q;YxBCd,0B;SALF,eAAA,8BwBK6B,QxBL7B,C;UAKA,+C;YwBEG,0BAAK,CAAA,gBAAL,EAAK,C;KAEhB,yD;MAEA,qD;MAII,MAAA,0B/B+ImC,C+B/InC,S/B+ImC,Y;K+B5IvC,8D;MbxBI,Ia6BK,Yb7BD,qC;YAAuB,gD;Ka8B/B,qC;MAEA,6D;MAI2C,sD;KAE3C,6B;MACuC,mE;;SAGU,0B;;MAEjD,sD;;EAKW,iDAAY,uB;IACvB,gF;IAEA,0B;IACI,iB;WAGI,S;G;EnCwNqC,4BoC5NmB,UvBmX5D,UuBnX4D,cDSrD,mBCTqD,4B;EDYhE,iC;EtBsWmB,iC;;IAAN,oBAA6B,kB;IAA7B,qB;;EsBnWa,iC;UH2RjB,6B;;EAD0D,kC,kCHzT3D,uB;;WGyT2D,Y;gBAU/D,Y,CAAA,6B;K;;EG3QI,kF;EACa,iC;;;IAIrB,gC;;EAEA,uB;IAEA,2D;;EAGA,uB,qBAEA,U,cAC0F,uB;;QA6C5C,OAAM,e;;;IEnJpD,kC;IAAA,kD;MAAA,qE;MAOI,QAAkD,E;;;IAW3C,S;IADP,c;;;IA2CI,WAAS,iB;;IAIH,6B;IAEN,IAAI,QAAA,SAAa,a;QtCkEwB,EsCjE/B,CtCiE+B,SAAM,sBsCjErC,UtCiE+B,C;MA/C7C,IAAI,IsCfM,4BAAa,uBAAb,U;MtCgBN,U;KADA,OsCdM,GAAA,WAAa,uB;QtCenB,M;IACM,kC;WsCfA,O;;;;IH8lB+D,qB;QACjE,SAAM,gB;IACV,kC;;MAXR,oCAQS,uBART,U;MvBnqBA,U;KAAA,qB;IAAA,kB;IAAA,2J;IAAA,U;IAOgB,kC;WAAS,O;;;IuBGjB,kC;QACI,QAAM,S;IrB2Yd,aqBzYI,gB;IrB0YJ,kC;;MqBtYJ,qE;MAGuC,Q9BgPG,E;;I8B9O1C,U;IAAA,8B;IAAA,c;;;;IAiBA,gBAIuC,IAJvC,C;IAkoBI,6B;IrBnRS,YAAA,SAAM,a;IAAN,OAAA,SAAc,sBAAd,Y;MFhZT,IuBsqB2C,IrBtRN,4BqBsRM,uBrBtRN,U;MF/YjC,U;KuBwqBA,UAAA,MAAc,K7B5qB4C,W6B4qBpC,Q7B5qB0D,K6B4qB1D,C;IrBzR1B,SqB3W6C,C;IrB4W7C,+BAAa,EAAb,C;IqB5WmC,OAwoB5B,O;;EAhoBX,wC;IAIyC,WAAa,e;IAknBlD,6B;IrBnRS,YAAA,SAAM,c;IAAN,qBAAc,eAAd,Y;IFhZT,IAAI,cEgZiC,IFhZrC,C;MACI,MAAA,iCuBqqBqE,yB;KAGrE,WlC9ZqC,iBkC8ZvB,KlC9ZuB,EK9QqB,KL8QrB,C;IaqIzC,SqB/V+C,C;IrBgW/C,+BAAa,I;G;;;IqB1UjB,6B;IAIqC,YAAa,uB;IAwlB9C,gD;IrBnRS,IAAA,cAAM,IAAN,C;MAAA,gE;KF/YL,yC;QAKE,M;IuBmqBF,+B7BxqBsD,I;;;I6B2F9D,yB;QAE+C,yB;QAAD,QAAiB,SAAhB,c;;;MAE/C,gE;KAmkBI,qB;IrBnRS,aAAM,K;IAAN,aAAc,sD;IFhZvB,QEgZqC,eAAA,MqBsRM,IAAe,IrBtRrB,EqBsRM,SvBtqBvC,CAAJ,WAAI,CEgZiC,gB;QF/YjC,M;IAKE,+B;;;;;IuBoHV,mC;IAIyC,qBAAa,uBAAb,I;IAqiBrC,uB;MrBnRS,gE;KFhZT,MuBsqB2C,KrBtRN,mBqBsRM,KrBtRN,EqBsRqB,KrBtRrB,C;QF/YjC,M;IAKE,+B;;;QuB8HwC,OAAiB,4B;;;IAGnE,gD;IAImD,IAAA,cAAc,IAAd,C;MrBsRtC,gE;KqBsRL,sBrBtRkC,eqBsRb,KrBtRa,C;IqBuRlC,IAAI,M;IACM,mC;;;;;IAtiBlB,sB;MAIqD,SAAc,2BAAd,I;IrB0QxC,uB;IAAA,YAAc,IqBsRnB,IrBtRmB,C;IqBuRnB,IAAI,SAAA,SAAJ,O;QACI,QAAM,sB;QAEJ,E7BtpBkC,CAA5C,SAAK,cLqIgC,QKrIhC,GAAuC,CAAA,W6BspBlC,C;MrB1RV,0E;MACA,U;;IqBvQJ,c;IAAA,e;IAAA,kC;IAAA,O;;;;;;;;IrBsQa,mB;aqBsRL,gCAAqB,GAAe,c;K;;;IrBtRxC,mB;aACA,4D;K;;;IqB/OJ,sB;MAAA,U;IAAA,sB;MAE2D,wC;QAAgB,EAAA,MAAhB,KAAgB,C;;;KAM1B,MAAA,MAAc,KAAd,E;MrBsOpC,cAAM,uBAAN,gC;MAAA,UAAc,E;KqBuRnB,IAAI,8CAAJ,C;MACI,UAAM,4BAAA,sBAAuC,6BAAvC,C;MAEV,Y;KA/fJ,MAAA,S7BzIK,iBAAkB,sB6ByIvB,E;MAAA,O7BxIA,E;IQ6WA,4D;IACA,oC;;;;;;;IqBvNJ,sB;MAAA,mC;IAAA,uB;IAAA,6B;QAE6D,+B;QAAgB,iBAAhB,2B;;;KAMV,eAAc,M;IrB8MpD,gBAAM,K;IAAN,qBAAc,MAAd,EAAc,MAAd,S;IqBsRL,e;IACA,SAAI,sB;;;IrBvRR,sB;MACA,U;;;IqB/LJ,yB;IAAA,iC;IAAA,qB;QAE+D,yB;QAAgB,QAAA,SAAhB,a;;;MAE/D,U;;IAGqE,c;QAAA,S;IACjE,8B;IAwbA,O;;;IAUO,mB;MA/bX,wD;K;;;IAEA,mB;aAAA,iD;K;;;WAE8E,Y;aACzE,4D;K;;;IAGL,sB;MAGqD,U;QAAA,MAAc,W;MAAG,wC;QAAA,EAAA,MAAc,KAAd,C;MAClE,oCTw2FO,sBSx2FP,S;;KAUqB,mB;MAAE,qE;;KACF,mD;MAAA,0F;MAAE,Y;;MACsB,S;IAAA,yB;QACzC,wD;IAEJ,kC;;IAZJ,e;;;QvBvPQ,MAAE,W;MANN,MuBsQQ,I;QvBrQJ,iB;MAKA,MAAE,6B;QuBqQN,OrBkH0C,c;QqBlH1B,6B;IACD,arBvM8B,gB;IqBuM7C,YAAA,StBLY,c;IsBMZ,qBAAA,SAAU,MAAa,QAAQ,I;IAC/B,0B;;KAGJ,sD;IAAA,a;IAAA,mC;;;IAMA,sB;MAMyD,U;QAAA,MAAc,W;MAAG,wC;QAAA,OAAc,UAAY,I;IAChG,WAAO,gB;oBAGX,I;IAGgD,6B;QAAA,8B;IAAiB,qD;MAAA,YAAc,uBAAd,qC;MAC7D,U;KrB4HS,YAAc,4C;IqBsRnB,c;IACA,IAAI,S;IACM,kC;IAEV,O;;;IAjZR,mB;aAEyD,gC;K;;;WACpD,Y;aAAgB,gCAAhB,iB;K;;EAGL,qF;IAGiD,mB;aAAA,4D;K;G;;;MAIjD,U;IAIqD,sB;MAAA,SAAc,WAAd,oB;IAAiB,mB;MAAA,YAAc,uBAAd,CAAc,sBAAd,S;MAClE,U;KAuWA,mB;MrBnRS,cAAM,uBAAN,gC;MAAA,UAAc,E;SF/YnB,2BAAA,WuBqqBqE,OvBrqBrE,C;MAKA,IAAE,sF;MuBuTK,Y;KrBmFX,wD;MACA,S;IqB4RO,yB;;IA5WX,kC;IAIsD,qD;WAAA,Q;;;IAc7B,sB;MAAA,U;QAAE,iB;;;IACsB,2B;IAAA,6B;QACzC,+B;IAEJ,gD;;MAdJ,mE;;IAQ0E,a;IAAA,+BAAc,CAAmB,EAAnB,C;;;QAQpF,MrBoC0C,W;MqBpC1B,MAAO,I;IACF,oBAAS,CAAT,C;MAAN,MrBrR8B,GAAA,2BAAgB,I;IqBqR7D,WAAA,MtBnFO,IAAK,I;IsBoFZ,gC;IACA,YAAO,S;IAGX,6B;IAQ0D,kC;QAAA,gD;MAAiB,wE;MAAA,U;;IAI3E,c;IAIiD,a;IAAA,8B;IAAiB,O;;;IrBkD9D,mB;aACA,gC;K;;;WqBzC8C,Y;aAAiB,gC;K;;EAEnE,sF;IAEA,mB;aAImD,4D;K;G;;IAC/C,IAAA,MAAU,UAAS,CAAnB,C;MAAA,SAAsB,C;IAiStB,sB;MrBnRS,SAAA,WAAM,OAAN,a;IAAA,MAAA,MAAc,KAAd,E;MFhZT,IuBsqB2C,IrBtRN,4BqBsRM,sBrBtRN,S;MF/YjC,U;SuBkYO,YAsSO,CAtSP,C;MAsSP,qE;MrBzRJ,Y;KqB6RO,mD;;MAtSX,Y;SAIoD,mD;MAAiB,S;QAAA,OAAc,UAAY,I;IAC3F,QAAA,uBAAU,GTiuFH,SSjuFP,aAA4C,I;;IAYvB,qD;IAAA,e;;EAEwB,yD;IAAA,sB;MACzC,U;IAEJ,sB;;IAdJ,yB;IAQuD,gC;QAAA,yB;IAAiB,mC;QAAA,iBAAc,eAAmB,GAAnB,KAAd,I;IvBvZpE,IAAI,cAAJ,Q;MACI,MAAA,iCuBuZiB,4B;KACb,qD;QvBxZJ,S;IAKE,+B;G;;IuB4ZN,IAAA,MAAO,WAAP,C;;IAGJ,sB;MAQwD,wC;QAAA,OAAc,MAAd,Q;IAAiB,yC;QAAA,QAAc,IACnF,IADmF,C;;IAIvF,kC;IAI+C,qD;MAAA,wE;MAAiB,U;KAC5D,cAAW,4C;IAAX,c;IrBrBS,a;IAAA,8BAAc,I;IqBsRnB,O;;;WAhQO,Y;arBtBX,gC;K;;EqB0BJ,iD;IAIgD,mB;aAAA,gC;K;G;;;MAIhD,oJ;;;;QAIqE,MAAc,W;MAC/E,SAAU,C;IAAV,IAAA,MAAsB,WAAtB,C;MA2NA,wC;IrBnRS,MAAA,MAAM,KAAN,E;MAAA,YAAc,uBAAd,iC;MFhZT,QEgZqC,E;SF1Y/B,c;MuBmcK,cAgOO,uBAhOP,iC;MAgOP,Y;KrBxRJ,+BAAa,WAAb,S;MqB4RO,2F;;KA5N0C,wD;MAAA,S;IAAiB,yB;QAAA,IAAA,SAAc,cAAmB,yBAAjC,I;IAClE,eAAA,UAAU,S;;IAYW,e;;;IAA0C,sB;;IAC1C,sB;MAAA,mC;QAAE,qB;IAAwC,yC;;IAClB,mC;IAAA,gD;QACzC,qB;;KAZR,sD;IAQwD,a;IAAA,+B;;;IvB7dpD,IAAI,MuB8dI,WvB9dR,C;MACI,U;QAKE,iB;MANN,MuB+dQ,kC;QvB9dJ,qB;QAKA,OAAE,8B;QANN,QuBgeQ,S;QvB1dJ,SAAE,SAAF,O;QuB+dJ,QrBxG0C,sB;QqBwG1B,gD;MACK,wE;MAAN,QrBja8B,E;KqBka7C,wBAAU,KAAV,EAAU,WAAV,EAA+B,MAA/B,S;IACA,OAAO,O;;IAGX,kC;IAQyD,O;;;WAAiB,Y;aACtE,gCAAqB,iB;K;;;WAOuB,Y;aAAiB,gC;K;;;IrB1FpD,mB;aAAA,4D;K;;;QqB4FE,gBA8LD,C;MrB1RV,U;IACA,sB;;IqB+FJ,mB;MAIiD,oE;MAAA,U;SAAiB,EAAA,MAAc,KAAd,C;MAC9D,sCAAiC,uBAAjC,S;;KAOiD,mD;MAAA,2F;MAAiB,Y;KAClE,MAAA,SAAU,cAAV,2B;MAAA,S;IAqJA,yB;IrBnRS,QAAA,SAAM,cAAN,6B;IAAA,eAAc,mB;IFhZvB,YEgZqC,yBqBsRqB,MrBtRrB,EqBsRM,QrBtRN,C;WF/YjC,Q;;;IuBwqBA,sB;MrBzRJ,U;IACA,sB;MqB4RO,M;;IAjJc,yC;IAAA,6B;QAAE,+B;IAAwC,gD;;MAC1C,mE;KAAE,gDAAgC,MAAhC,C;IAAwC,a;;;;QAE3D,iB;;KAZR,mB;MAQyD,mC;MAAA,uD;SAAiB,EAAA,MAAc,KAAA,SAAY,GAAZ,GAAmB,cAAnB,KAAd,C;MvB3hBtE,IuB4hBQ,YvB5hBR,qB;MACI,oCuB2hBiB,oBvB3hBjB,C;SADJ,OuB6hBQ,gB;QvB5hBJ,iB;QADJ,SuB8hBQ,SAAS,O;QvB7hBb,8B;QAKA,GAAE,SAAF,sC;MuB6hBJ,IAAI,IrBtKsC,4BAAgB,uBAAhB,e;MqBsK1B,QAAO,E;KACR,qBrB/d8B,aAAgB,KAAhB,EAAgB,MAAhB,EAAgB,iBAAhB,C;IqB+d7C,yBtB7RY,Q;IsB8RZ,c;IACA,SAAO,M;;IAGX,O;IAIiD,a;;;QAAiB,MAAc,UAAO,C;MACnF,SAAW,6BAAX,I;KrB7IS,MAAA,SAAM,cAAN,2B;MAAA,S;IqBsRL,WAAA,SrBtRkC,oBqBsRE,I;IACpC,IAAI,wD;QACA,WAAM,2B;QA1IH,uB;IrB9IX,gBACA,IADA,C;;IqBkJJ,kC;IAIsD,yD;MAAA,4E;MAAiB,U;KACnE,qBAAU,gD;IAAV,yBAAsB,U;IA2GtB,c;IrBnRS,iB;IAAA,8BAAc,I;IFhZvB,KAAI,E;WACA,Q;;EuBukByC,2C;IAAA,mB;aACzC,iD;K;G;EAZR,0D;IAQ0D,mB;UAAA,8F;UAAiB,mB;aAAA,QAAc,mBAAmB,GAAA,KAAnB,aAAd,K;K;G;;WAE/D,Y;UvBtkBJ,0G;UAKA,QAAE,e;aANF,IuBwkBI,IAAA,KAAS,MAAT,GAAA,KAAmB,cAAY,IAA/B,C;K;;;QAKQ,c;MACK,8D;MAAN,QrBzgB8B,E;KqB0gB7C,qCAAuB,gBAAvB,O;MACA,UAAO,6D;;KAOuC,iE;MAAA,6E;MAAiB,Y;KAC/D,WAAW,yB;IAAX,aAAuB,gB;IrBvLd,YAAA,SAAM,c;IAAN,qBAAc,eAAd,Y;IqBsRL,qBrBtRkC,MqBsRlC,C;MACA,MAAI,iCAAJ,8B;SA/FO,iB;IrBxLX,kB;IACA,qE;;IqB2LJ,e;IAIyC,+B;;;QAwF7B,SAAM,kB;MAEV,6B;MAAA,oC;QAnCI,SAAO,eAAO,E;QACd,4B;;QrBvPR,+B;;;;IFxaJ,mC;IAAA,qB;;EAAA,mD;WAAA,sC;G;EAOgB,wCAAS,WAAT,iDAPhB,YAOgB,C;MAEA,+BAAM,I;;IATtB,0C;MAAA,yB;KAAA,mC;;;QuB6qBY,SAAM,Q;MACV,M;;IAXR,yBAQS,M;IvB3qBT,sB;;;IAAA,Q;iBuB2qBS,qB;IAAA,qB;QAC8B,Y;aAAA,M;gBvBrqB/B,I;WAKE,+B;;;QuBqqBN,I;;;IAdJ,qB;QAMI,Y;MrBnRS,W;SFhZT,OEgZqC,I;WF/YjC,6B;;;QE+YJ,I;IACA,qB;QqB4RA,IAAO,Q;;;IAGX,qB;;;WrB/Qa,cAAc,e;;;QACvB,I;IqB4RJ,0F;;I3BvoBA,iB;MAG4B,U;SACxB,OAAI,I;WACA,cAAO,W;;;QAqBf,mF;QAAA,6E;;IAKA,sD;IACI,SAAI,sB;WAAc,I;;;IAGb,cAAL,CAAK,OAAL,O;;;mDAOA,U,0DAEU,W;;;;EAsBd,6B,qBAEA,U,2DACe,uB;;;;EACJ,gC,kCAGX,uB,cAI8C,gB;;EAE9C,iC;;;IAIA,gC;;EAC4B,iCMtEqB,sB;UNuE7B,6B;G;8CAAhB,U,cAEY,uB;EAChB,iD;IAEA,8B;MAEoB,c;IADhB,6BM7E6C,KAAgB,Y;IN6EtC,qB;IACP,MAAA,IAAL,iBAAK,O;MAAL,wE;MAAa,QAAO,E;M;EAEnC,M,+EAEA,Y;WAAA,U;G;EACqD,qBKwHtC,8BLxH4C,SKwH5C,ELxH0E,sC;;GAAA,CKwH1E,C;ELtHf,2FAEI,Y;WAAmC,UAAM,I;GAF7C,E;wFAMA,Y;WAEQ,S;G;EK8GO,4CAAJ,e;G;ELzGP,2BAAO,cACH,qC;G;EAOR,iB;IAEyC,Q;WAA8B,6G;;;;;;;;8GSnLvE,G,GAAA,iB;;EAAA,2B;WAAA,sB;;EAG8B,2B;WAK1B,mBAAc,K;;EAEJ,2B;WACN,mBAAe,iB;;EACjB,2C;;iBAEE,S;;aALJ,a;;MAOJ,M;;IAIA,W;;EAMA,iB;IAMA,Q;QAAsD,gB;;;;;;;;;;;;;;;ILpCtD,2D;;EAAA,+D;IAOgB,mB;aAAS,0C;K;G;EAEH,8DATtB,mBASsB,cATtB,+BASsB,C;;;I2BuBQ,4D;IAAC,8B;;EAC3B,4C;WAD2B,iE;G;E3BzBvB,4C;WAKE,I;G;;;;E2B8BM,wB;;;;;;;;;;WAYA,C;;iGAIR,E;MAAQ,wC;;;;;;qCAeK,U,cAAN,gB;;IAIA,KAAM,mD;IAAb,cAAO,aAAM,IAAN,EAAM,kBAAN,EAAM,IAAN,C;;;;mDAYX,I;;yEAQwF,4B;ECxC3C,sC;IAI7C,gBAAA,yBAAyB,G;;;M;;;;;QRoToB,MAAc,W;MAAG,U;QAAA,MAAc,KAAI,M;MAChF,gC;wBAEJ,M;IAGkD,2B;;MAC9C,gB;;MAEJ,yC;MAGmD,iB;QAAA,qB;OAAiB,cAAkB,I;;;UAItF,oB;UAGoD,wB;UAAA,sD;UAAiB,iC;UAAA,WAAkB,SAAO,GAAP,EAAJ,SAAI,U;UACnF,cAAA,cAAc,KAAK,I;;UAEvB,uB;YAE0C,K;WAAwC,e;;UAElF,mB;YAG8C,K;WAAiB,iB;UAAA,OAAkB,O;UAC7E,c;;;;QAK2C,Y;UAAA,kB;;;IAC3C,c;;IAEJ,oB;MAG6C,oB;;;IACzC,sB;;IAEJ,sB;MAG8C,gC;QAAA,gBAAiB,MAAjB,C;QAAiB,YAAkB,IAC7E,MAD6E,C;;MAMlC,gB;MAAA,kB;MAAiB,yC;MAAA,IAAA,IAAc,IAAI,IAAlB,C;QAC5D,yB;OAEJ,kB;MAGgD,Y;;;UAAiB,IAAc,QAAI,O;UAC/E,aAAA,KAAU,cAAa,GAAvB,KAAuB,aAAvB,I;;UzB7aJ,mB;;;cAC4D,gB;cAAc,IAAI,SAAO,SAAP,E;cAiI1E,SAhI+B,MAgI/B,iD;cACA,YAjIuB,MAiIvB,e;;cyByGc,S;cADd,S;cACc,oB;gBAAA,Y;;gBAAd,Y;;;;czBtGsB,qB;cAAN,KAAiB,GO3DY,qBP2DZ,GO3D4B,oBP2D5B,I;;;YAE7B,c;;UyBwGI,OzBrGJ,Q;UyBsGQ,gB;YAEJ,MAAU,0C;;YACC,yB;YAAgC,Y;cAA3C,qB;cACA,MAAU,6C;;cAEL,kB;;;cAGL,gB;;;;YzBtPN,K;WAmME,c;;;QAhMR,iB;;QAC4C,Y;UAAiB,kB;;;IA2KzD,c;;QyBuFc,e;MADd,oB;;;QACA,gBAAc,C;MACd,U;;;;;;gBASuB,M;oBzB9FD,I;aAAN,oBO3G6B,YP2GZ,CO3GY,C;UP2GzC,Y;;qBAGA,I;iBAGI,C;;;cANJ,e;;cyB8FY,K;;;cAEA,alB3M6B,O;;;ckB8MjC,IAAQ,4D;;cAGZ,W;cAGI,W;cAAc,oCAAoB,C;;gBAClC,eAAQ,C;;gBAAQ,gB;;cAAhB,mB;;cAEI,qB;;;;YAJR,c;;UAUI,O;UAGJ,IAAA,KAAU,MAAV,C;YACA,MAAU,0C;;YACL,yB;;cAEL,qB;cACA,UAAA,gBAAiB,gBAAjB,S;;;czBrSN,MAsLK,wC;;cAMH,gB;;UAzLR,iB;UAC0C,iB;YAAA,K;WAAiB,OAAkB,O;UAmKzE,c;;QAlKkB,QAmKlB,IAnKkB,K;;QyB0PJ,Y;UADd,kB;;;IACmD,c;QAAnD,cAAc,SAAd,E;QACA,W;;;;QAKQ,iB;MAEA,SAAI,C;;eAEW,aAAM,M;oBAAN,W;oBzB9FP,W;;gBAGZ,M;oBAGI,I;;;;qByBwFQ,I;;;;;;UAKJ,S;;;cAMA,oB;cAAc,gB;;cACd,gE;cAAA,iC;0BAAgB,M;cAAA,SlB/NU,KAAA,cAAW,KAAA,I;ckB+NrC,S;cACI,oB;gBACA,gB;;gBAEI,Y;;cANZ,mB;;cAUI,qB;cAGJ,KAAU,mD;;;YAEL,c;;UAEL,O;UACA,gB;;;;YzB9RN,Y;cAoLE,qB;cACA,UAAA,OAAqB,SAArB,yB;aAlLR,W;cAC2C,kB;;;cAA+B,MAAI,GAAJ,O;;UA6JtE,iB;;YyBuFc,K;WAAA,c;UAAA,c;;QAAqC,iB;;QACnD,Y;;;;IAIQ,c;;QAGI,e;;;;QzB5FI,gBAAiB,C;eAA7B,C;QA9JI,iB;eAgKJ,uB;oBACA,W;oBAHA,W;;gByB8FY,M;;;UAEA,Y;;WAGJ,UAAQ,I;;;;UAMM,mB;;UACd,S;UAAA,mB;;cAAgB,alB/NU,O;ckB+N1B,gB;cACI,wB;cACA,gE;;cAEI,6C;;cANZ,W;cASI,oB;;;gBAKJ,Y;;cACK,OAAO,Y;;cAEZ,qB;cACA,QAAA,qBAAiB,uBAAjB,I;;;;;UzB1GJ,UAAO,K;UACP,gB;;;YA1KoC,yB;YAAA,Y;cAAiB,qB;cAAc,MAAI,IAAJ,OAAW,SAAP,yB;aAsJ3E,W;;cyBuFc,M;;cAAA,gB;;UAAqC,iB;UAAnD,IAAA,IAAc,QAAd,C;YACA,K;;oBAIqB,I;;QlBpMwB,QkBoMrC,IlBpMqC,K;;QkBuMrC,IAAI,OAAJ,C;;;;IzB5Fc,c;sBAAW,SO3GY,E;QP2GzC,e;MAvJI,qBAwJM,WAxJN,C;;;mBAuJJ,M;;mBAAA,M;;oByB8FY,W;;;UAKJ,I,EAAA,M;;MAGJ,yC;UAGI,Y;;WACA,c;UAAA,Q;;;cAAA,e;cACI,SAAA,mBAAiB,qBAAjB,I;cACA,K;;;;cAJR,gB;cASI,wB;cACA,gE;cAGJ,iC;cACA,Y;;cACK,S;;gBAEL,Y;;;;;;czBzGJ,qB;cACA,QAAA,OAAqB,cAArB,2B;;;YAnKqC,c;;UAAiB,e;UAAA,IAAc,KAAI,KAAJ,CAAd,C;YA8I1D,gD;;;YyBwFc,Y;cADd,IAAc,iB;cACA,6BAFuC,OAEvC,e;aAAqC,W;cAAnD,kB;cACA,M;;;;UAIQ,WlBpMqC,M;UkBqMrC,iB;YAEI,K;WAEW,c;UAAA,c;;QzB9FD,iB;;YAAlB,O;UACU,8BAAQ,OAAR,C;;;IAKN,c;sBANJ,SAjJ8B,E;;MAiJ9B,iC;;;;eyBgGY,SlB3M6B,uBAAgB,C;;;;;UkBqNjD,c;MAAA,yC;;;qBACI,I;;;cAGI,gB;;UANZ,sD;UASA,IAAI,6B;UACA,Y;UAGJ,SAAU,4B;UACV,SAAU,E;;YACL,K;WAEL,O;UACA,SAAA,mBAAiB,oB;;;WzBzQvB,WA0JK,M;UAKH,UAAO,I;UACP,c;;;;QA5JgC,Y;UAAA,kBOqCkB,oB;;;;QkB4JxC,yB;QADd,WAAc,I;MACA,iC;;;QzBnGV,iB;MyBuGI,SAAI,C;QACA,iB;MAEJ,gC;oBACW,W;;;;MAGN,kB;;MAET,IAAI,YAAJ,C;QACI,qB;;;;UzBpDJ,oB;UACA,aAAA,SAAqB,E;;UAtJ7B,iC;UACI,oBAAU,GAAV,EAAU,SAA+B,EAAzC,EAAyC,KAAzC,C;;UAGJ,qC;UACQ,uB;YACA,K;WAIR,e;UAC+C,gD;UAAA,mB;YAAiB,K;WAsE5D,iB;UACA,c;;;QyByGc,a;;QAAA,Y;UAAA,kB;;;;;;;QzBtGE,WAAiB,KO3DY,C;MP2DzC,U;QAxEI,gBAyEM,C;MACV,gC;oBACA,W;;;UyB2G+C,I;UAA3C,UAAW,I;MACX,yC;UACA,QAAU,I;;;MAGd,IAAI,OAAJ,C;;;;;UzB5LG,S;;;cAMqC,oB;;cAAiB,wB;cAAc,IAAI,KAAJ,MAAW,cAAP,mC;cA+G/E,YA9G0C,MA8G1C,e;cACA,WA/GkC,iC;;cyBsMpB,S;cADd,IAAc,SAAd,O;gBACc,gB;;gBAAqC,gB;;cACnD,I;;;cAIqB,wD;;;YAGT,c;;UAEW,e;cAAA,W;YzB9FD,gD;;YAAlB,aMuFG,KAAK,O;YNxMJ,Y;cAmHJ,qB;cACA,UAAA,gBAAa,gBAAb,S;iBAHA,M;;cAAA,8C;;cyB8FY,gB;;;cAEA,QlB3M6B,I;;WkB8MjC,OAAQ,O;;;QAGF,QAAV,IAAU,K;;YAGQ,O;;;;;WACE,SAAA,SlB/NU,EAAA,I;;;QkBiOtB,iB;;QAEI,iB;;oBANZ,W;;;MAeK,gB;;MAET,IAAI,qC;UACA,Y;;;MzB5OR,IAAO,Q;;;UAMmC,mB;UAAA,yD;UAAiB,S;UAAA,IAAc,MAAI,IAAJ,IAAd,C;;cAyG3D,aAxGkC,O;;cyB+LpB,wB;cADd,IAAc,4D;cACA,iC;cAAA,W;cAAqC,qC;cAAnD,S;cACA,oB;;;;;cAKQ,I;;;cAIe,QAAA,OAAM,cAAN,2B;;;YzB9FP,QAAiB,M;;UA1GzB,e;cA4GJ,W;YACA,SAAA,mBAAa,oB;;gBAHb,qB;;cAAA,qB;;;cyBgGoB,sC;cAAR,MlB3M6B,wBAAgB,SAAhB,EAAgB,IAAhB,C;;;;;UkBiNrC,IAAA,IAAU,QAAV,C;YAGI,K;;UACA,c;;gBAAA,I;;YAAgB,O;;;;;WAIR,oB;;;QAGR,iB;MACA,U;QAGJ,gBAAU,C;MACV,gC;;;;;;MzBjOR,IAAO,qC;;QAKX,yB;OAC+C,kB;MAAiB,Y;;;UAkG5D,YAjGkC,O;;UyBwLpB,S;UADd,IAAA,MAAc,QAAd,C;;cACc,oB;cAAqC,gB;cAAnD,wB;cACA,gE;;;cAIqB,qC;cAAb,SlBpMqC,KAAA,mBAAgB,I;ckBqMrD,oB;gBAEI,Y;;gBAEW,YAAM,I;;czB9FP,mB;;cAAlB,cMuFG,O;cN1LC,QAAA,OAoGM,cAAQ,GAAA,OAAW,aApGzB,I;;;YAyGA,c;;;cANJ,W;;;;;cyBgGY,clB3M6B,O;;akB8MjC,W;;cAGJ,MAAU,wC;;cAGQ,gB;;UACd,iB;UAAA,iB;;WAAA,c;UACI,c;;QACA,iB;;YAEI,O;;;;IAIR,c;WAGJ,oB;;;QAEK,iB;;QAET,MAAI,KAAJ,M;MACI,gC;;wBzB9NR,M;;MAM4C,gB;MAAA,kB;MAAiB,yC;MAAA,IAAA,IAAc,IAAI,IAAlB,C;QA0F7D,yB;;MyBwFc,Y;;;UAAA,mB;UAAqC,yD;UAAnD,S;UACA,mB;;;;cAIQ,alBpMqC,W;ckBqMrC,gE;cAEI,YAAJ,MAAI,e;;cAEW,WAAM,0B;cAAN,qC;czB9FD,oB;gBAAN,YO3G6B,I;;gBPerC,YA6FM,GA7FN,C;;cA+FJ,mB;;cAHA,qB;;;;YyB8FY,c;;;cAEA,KlB3M6B,M;;;YkB8MjC,yB;;cAGJ,IAAU,iB;cAGN,mD;;cACA,kBAAQ,oB;cAAR,8C;;cAAgB,SlB/NU,O;;ckBgOtB,a;cACA,Y;;;UAJR,c;;QASI,eAAJ,CAAI,C;;YAIJ,O;UACA,kB;;;;WAGJ,MAAI,c;;;;;IzBtNR,IAAA,MAAO,UAwGA,CAxGP,C;;IAKJ,oBACiD,MADjD,C;QACiD,gBAAiB,MAAjB,C;;MAoF7C,gB;;MyBuFc,yC;MADd,YAAc,IAAd,C;QACc,yB;OAAqC,kB;MAAnD,Y;;;;uBAKqB,K;UAAb,S;UACA,mB;;;cAIe,gB;cAAA,wB;czB9FD,gE;cAAN,YAAiB,MO3GY,aP2GZ,CO3GY,C;cP2GzC,YMuFG,SAAK,GAAL,EAAK,SAAL,U;cN5KC,WAsFM,GAAA,SAtFN,EAsFc,WAtFd,C;cAuFJ,cAAA,WAAa,QAAb,I;cACA,oB;gBAGI,gB;;;;;;;sByB0FgB,qB;;;;;;UAMhB,IAAA,KAAU,MAAV,C;YAGI,gD;;;YACA,Y;cAAA,qB;wBAAgB,gB;aAAhB,W;cACI,8BAAiB,OAAjB,C;cACA,yCAAqB,IAArB,C;;cAEI,gB;;UANZ,iB;UASA,IAAI,YAAJ,C;YACI,K;WAIJ,OAAU,O;;;QACL,iB;;QAET,IAAI,OAAJ,C;UACI,8BAAiB,OAAjB,C;;;;IzBhNR,OAAO,SAiGA,WAjGA,I;;EAKX,kD;IAA4C,sB;MAAA,SAAc,GOrBR,SPqBQ,GOrBA,cAAR,I;KPmD9C,2B;QyByGc,kB;;MAA2B,gB;MAAzC,cAAc,I;;;QAID,qB;WzB1GG,UAAiB,I;;;UAE7B,oB;UACA,wB;UyBuGI,IzBrGJ,kD;UyBsGQ,iC;UAEJ,YAAU,oB;UACC,qC;UAAA,qC;UAAgC,uB;YAA3C,K;WAEA,OAAU,Q;;UACL,mB;;WAGL,iB;;;;;;;UzB/IZ,sC;;;IAIA,c;IAKW,+B;G;;QyBwHO,I;QAAA,uB;QAAd,kC;;UzB/EsB,M,EAAA,M;UAAN,UAAsC,I;MAAlD,SAAA,oBMyHO,c;UNxHP,UAAU,I;QAAV,qB;WA7CA,UAAI,M;;;UAgDJ,oB;UyB+EI,IzB7EJ,oB;UyB8EQ,2E;UAEJ,aAAU,MAAV,8C;UACW,uB;UAAA,wD;UAAgC,6B;UAA3C,kB;UACA,2B;UACA,SAAU,E;;UACL,kC;;WAGL,e;;;;WzBvIR,WAAa,M;UAET,c;;;;;QADJ,Y;;;;IyB6GJ,c;IAAA,6B;IAAA,yC;IzBvGA,+C;MAQI,U;;;WyB0Gc,I;;ESlOlB,4D;IAEW,sB;;QAmCH,c;MAAA,O;QAAyB,QZqCV,M;MYrCnB,gB;IACI,yBAAY,MAAZ,EAAY,GAAZ,M;QACA,SAAA,wBArCiB,CAqCF,WArCE,4MAqCjB,Q;IACA,iCAAY,Q;WAAZ,M;G;;;;MAnCR,kD;MA0Ce,S;QAAX,IAAW,+DAA8B,C;OAEzC,S;QA3CA,IA4CO,8B;;QAzCX,uE;QAEW,yB;OA0BH,mD;;;WAAyB,oB;;;QAEzB,I;QACO,QAAA,IAAK,qCAAL,0C;QAAP,yB;IAAA,mC;WAGJ,K;;;IAhCA,wB;;MAoCW,kD;MAAX,S;QACA,QAjCqC,SAiCpB,iBAAjB,kC;OAjCA,IAmCO,IAnCP,C;;QAGJ,sC;QAEW,oB;;OAiBH,oB;;IAAyB,c;WAA7B,oB;;;QAGI,I;QAAA,2F;QAGJ,uB;;;;EAtBJ,+B;IAEA,wB;;MAyBI,WAxBqC,uC;MAyBrC,S;QAzBA,IA0BO,gE;OAvBX,S;QAEW,kC;;QAQH,iC;QAAA,oB;QAAyB,yB;OACzB,oBAAY,8B;;IACZ,c;WACA,oB;G;;;;IAXJ,4B;;IAGJ,Y;;;IAgBI,wB;;;MAZJ,S;QACQ,oE;OAAyB,S;QAA7B,kC;QACI,SAAY,6B;QACZ,oBAAe,GAAA,SAAQ,WAAR,8B;QACf,yB;;;IAMR,c;IACe,2B;;;IAEX,Q;IACA,+F;;IbwCJ,mC;IAC4C,Y;;;QAAgB,oB;;MAI5D,kD;MACyC,S;QAAA,I;OAAgB,IAAW,IAAX,C;QACrD,IAAO,8B;;QAGX,yE;QAC6C,yB;OAAiB,oB;;IAAc,c;IA8IxE,2B;;;;QAjDI,2F;QACS,0B;IAoDQ,mC;WAAN,K;;;;MA1BX,U;;;IA3GR,wBAC4C,MAD5C,C;QAC4C,gBAAiB,MAAjB,C;QAAiB,OAAc,kBAAW,CAAX,SAAW,U;;MAqKlF,Y;QArEA,aAAW,I;;QAGP,+C;QACA,8B;QACW,aAAM,MAAN,6B;QAmEM,4C;QAAN,SAAiB,KdrNc,ScqNd,SdrNsB,I;QcqNlD,MAAA,SfxBG,KAAK,CewBR,E;UAtKO,K;QAwKP,qCAAiB,CAAjB,EAAiB,IAAjB,C;;;;;;;;MAhEA,U;;;IApGR,wBAC6C,MAD7C,C;QAC6C,gBAAiB,MAAjB,C;QAAiB,OAAc,kBAAW,CAAX,SAAW,U;;MA8JnF,Q;MArEA,Y;;QAGI,sB;QACA,QAAO,MAAP,iC;QACW,aAAM,MAAN,a;QAmEM,kD;QAAN,aAAiB,EdrNc,GAAA,aAAQ,WAAR,I;QcqN1C,cfxBG,SAAK,WewBR,I;QA/JO,OAAA,MAgKD,MAhKC,SAgKO,EAAR,EAAQ,CAAR,C;QACN,c;UACA,K;QAtEI,OAuEJ,yC;;;MArEW,iC;;;;;;IA1FnB,sB;MAC8C,gC;QAAA,oBAAiB,MAAjB,C;QAAiB,YAAkB,IAsJ7E,MAtJ6E,C;IAuJ7E,iD;;;MAlEI,Y;QACA,iB;QACW,sB;QAmEM,+C;QAAN,aAAiB,MdrNc,IcqNd,OdrNsB,CcqNtB,C;QAA5B,afxBG,MewBH,EfxBQ,GewBR,EfxBQ,aewBR,W;QAxJO,aAyJD,KAAA,aAAQ,WAAe,I;QAC7B,qCAAiB,C;QACjB,mBAAA,SAAa,EAAb,EAAa,CAAb,C;QAtEI,IAAA,IAuEJ,KAvEI,C;UACA,K;QAAe,gD;;;;;;EApF3B,uD;IAEA,sB;MAC+C,U;QAAA,MAAc,W;MAAG,gC;QAAA,gBAAkB,IA+I9E,MA/I8E,C;IAgJ9E,oBArEA,MAqEA,C;;;MAjEI,Q;aACW,I;QAmEM,iB;QAAN,WAAiB,SdrNc,E;QcqN1C,QAAA,MfxBG,MAAK,uBewBR,I;QAjJO,aAAA,MAkJD,IAlJC,OAkJO,CAlJP,C;QAmJP,0BAAA,aAAiB,EAAjB,S;QACA,kBAAA,aAAa,EAAb,a;QAtEI,SAuEJ,6B;QAtEI,IAAI,GAAA,MAAJ,KAAI,gB;YAAW,I;UACf,K;;;;;;G;;QA1EgC,MAAc,Kd/ET,M;McgFlC,M;IAAX,sB;;IAGJ,wBAA0C,MAA1C,C;QAA0C,YdnFO,IckL7C,MdlL6C,C;IcmL7C,iD;;;MAlDI,Y;QACS,aAAM,I;QAoDE,sB;QAAN,QAAiB,MdjLc,SciLd,MdjLsB,cAAR,I;QciL1C,afYG,MAAK,a;Qe7GD,kD;QAmGP,oCAAiB,MAAjB,I;QACA,4BAAa,MAAb,I;eACA,2B;;UAvDI,K;;;;;;;;;MAtCZ,U;IAsGI,sB;MACA,SAAA,UAtGgC,SAsGhC,I;IArEA,oBAAwB,W;QAEpB,uB;QAsEiB,6C;;UAAjB,I;aAxGI,I;QA0GJ,aAAO,I;QACP,sB;QACA,+C;qBACA,mB;;QAzEI,aAAO,KAAA,wBAAoB,I;;;QAG/B,c;;;;;MAlC4B,gB;;;;QAMxB,iB;eACA,oC;yBAwBO,M;;;;MArBX,Y;;;QAIR,+C;QACoB,8B;QAAA,aAAQ,SAAR,GAAQ,EAAR,IAAQ,C;QAAxB,aAAgB,+B;QAAA,oC;QACZ,uB;;;;;MAIR,iC;;;;IAUiB,uF;;;;;;;MAQjB,Y;QAAA,iB;QAAA,sB;QAOwC,oE;QAAA,kD;QACpC,kBAAW,gBAAA,aAAiB,EAAjB,EAA8B,IAA9B,4C;;QAGP,a;QACA,SAAO,E;YACH,EAAA,SAAa,WAAb,O;UACA,K;QAAe,6C;;;;;;;;MAQ3B,S;IAEI,IAAI,wCAAJ,C;MACI,qB;;;QIHJ,Y;UACc,iB;UAAA,oE;UAA2B,iC;UAAzC,2D;;;UJOI,MAAA,yBIHe,CJGf,KIHe,CJGf,M;YIHI,K;UACI,6C;;;QAGO,iC;;;MACX,qC;;;;;IAIJ,OAAA,KAAI,UAAJ,W;WACI,c;;;;;;;;MUnNJ,6C;QACA,0C;;UAIR,8C;UACS,iC;;UAsCD,kC;UAGA,6B;;IACA,c;QAAA,8B;MAGJ,oC;;;QA5CI,qC;;MAKR,6C;QACS,gD;;QAeD,0B;QACA,qCAAY,O;QACZ,0C;OpCGC,6C;;IoCAG,c;;MAIR,gD;;;;;;;QATI,0C;QACA,KAAA,SAAY,yBAAZ,kB;UACI,iCAAA,KAAmB,IAAnB,I;UACA,iCAAe,8B;UACT,6BpCed,GAAK,I;UoCdG,kC;;;;IAdR,IAAI,8BAAJ,C;MACI,kC;;;QASA,qC;;MAGI,IAAA,MAAM,kCAAN,C;QACA,gD;QAIR,U;;QAGJ,4C;QAIQ,0C;OAEA,qC;;IACA,c;QACA,sC;MAGJ,kB;;;IC/EA,2BAAc,EAAd,C;;IAQA,6C;IAAA,iC;;;;;QAOgB,6B;;;;;;;;UAPhB,0E;UAAA,oC;UAAA,kC;;;;;;;;IAFkD,yC;;;;QAoB1C,wB;;QAWR,qC;QAEI,0C;OADgB,qC;;IAChB,c;QACI,sC;MACA,kB;MAEJ,kB;;;;;;;QZtDR,yD;UAAA,8C;UAAA,iC;UACuC,6B;UAAS,kC;UAM5C,6BAA4B,Q;;;QAExB,8B;;;;;;UASI,yBAAe,cAAf,C;;;;;;UajBZ,kC;UAYI,6B;;;QAEI,8B;;;;;;;;ICLA,4C;;wFACiB,I;;;EbyOF,0EAAgC,WAAhC,cAAX,EAAW,C;;;;UAGN,4B;YAET,qC;;mGa3OG,e;;;;abkOM,K;QavNa,CAAtB,OAAA,oBAAsB,cAAA,KAAN,I;MAChB,mC;aACA,I;;;;;ebyNe,sB;QAAgC,kD;MAA3C,mD;;MAEA,0D;;;;QAVM,Y;MAAA,qC;UAA2B,+D;UAAzC,WAAc,gB;;;ScsIV,O;UAEgB,8B;;ahCkCX,W;;aAAA,c;;;QkB7IT,YAAc,M;MACA,sC;QAAA,c;MAAqC,gB;WAAnD,4C;;;yBckJQ,C;;Wb3RY,6D;;;2BAcI,C;;;;;;oBAOR,oBAAgB,Q;aAChB,kD;kBaoQL,kBbjQS,E,EAAA,S,EAAa,I,EAAA,S,EAAb,O;;;;;oBAOJ,M;gBAEA,W;yBACI,C;gBACS,4B;oBauPjB,4B;aAAJ,yF;cAGQ,oB,EAAA,I,EAAA,S;;;;eb1PY,sC;;;;;;;wBAOC,oB;uBagPjB,Y;mBAAJ,2BACI,KADJ,iC;;oCAGQ,2B;6BACA,uB;QAEJ,gD;YANJ,mCAOI,KAPJ,Y;;mBbhPoB,iB;yBAAA,C;;;;;;;easPhB,yC;;;kCbrPgB,I;;;;Ic7HO,uBAA/B,oCAA+B,mB;;EAiI+B,kF;;;;IAEtD,qBAAM,W;;;IAKV,2D;;;;;;;;;EAhER,+C;IAAA,oB;;EAAA,iEAhH6B,mBAgH7B,C;;;;;;;KAsEJ,6B;IAMyD,2B;;;MxBtMzD,4D;EAAA,sEAGQ,IAHR,mB;WAII,IAAO,iB;GAJX,yB;IAOA,iF;GAPA,E;iFXEA,Y;WAAA,sB;G,OAAA,oB;QAAA,gB;MAAA,gB;;MAOyB,mC;;G;EAET,qBAAM,wBAAyB,gBAAzB,4BATtB,Y;IAAA,8B;GASsB,E;EATtB,W;QAAA,kB;aAMI,KAAK,kB;QACD,+B;eAKE,I;;KAZV,M;MAgBA,wE;;;WAhBA,iB;;;MAAA,e;KAAA,M;;EAOgB,8C;QAAS,I;;IAPzB,2B;QASgB,YAAM,6BAAyB,SAAzB,C;IACV,I;IAVZ,gB;G;EAAA,wD;IAAA,2B;;MqBEA,mB;QAAA,qB;QAAA,4B;;QnBoZa,oBAAc,M;;M;EmBhZX,uCAA8B,Y;;aAE9B,wB;;enB8YZ,I;YACA,K;;MmBvYJ,uE;KAEA,gB;IAAA,kB;G;EAAA,qC;QAAA,mC;;MAAA,Y;QAAA,iC;QAAA,a;UAAA,oF;;;;;;;;;;;;;;;;;;YAWI,O;;;;mBAAA,C;;;YACgB,8B;;;;;;;IAAA,c;;;;;;;;;gBAAZ,0B;;;iBD2OJ,wB;YACc,8B;;;;;;;;;;;;;;ECzOQ,0C;;0CAsFtB,wB;;KnB+RS,iC;;IAAA,6B;G;;ImBvRS,qC;;;8BAEG,0C;IAAA,oG;;wBA/FH,+B;WAGM,sC;;;;;;;EAQJ,kD;WAXR,iC;;EAeQ,kDAAI,gB;;YAEA,yE;;;EAIM,yE;;G;EAGN,kG;;;;;;EA4EZ,8D;;;;;;EAS4B,uD;uBAChB,yC;;;;EAMQ,uD;;EAGZ,wDAAgB,+C;;;;EAQpB,2D;;;EAI4B,oE;;;;;EAhIpB,oG;;;;;UAMR,sE;;;;;;;;QAcI,uC;;;;;;;;;;;;UAjBA,8CAAK,KAAL,iE;;;;;sCAHI,8C;EACA,uE;;;;;EAJZ,uD;;G;;;;;;;2BnBoXZ,C;yBmBrXe,C;0BA4Jf,C;;;IA5JQ,kC;;EAgCW,yH;EDqNK,6C;ElB3MqB,yDAAgB,sC;;;;;;YkBiNrD,qBAAU,M;YAGQ,wB;YACd,0B;;YAAA,gB;;;;;;cAFJ,gB;;;YAaA,gB;YACA,gBAAA,IAAU,gBAAV,yB;;qBACK,mB;;;YAGL,+B;;;;;;;;;;gBCrOR,QAAI,e;;cAIJ,UAAO,M;;;;;;;;;;;;;;sBA7DX,oB;;;;wBAgEA,oBACI,CADJ,C;wCAGA,C;gDAGI,C;;wBAGA,+B;wBACQ,IAAJ,mC;;0BAGI,wC;;;;;;;8BASZ,sB;;kCAMA,oB;;;oCAAA,oB;;kCAAA,sB;kCAAA,sB;kCAAA,oB;;;kCAHY,U;;;;;;oCnB2Se,oB;;kCmB1RO,8C;oCACP,MAAmB,wG;;;kCAGa,IAAnB,U;kCACJ,e;kCACZ,oB;;;;4BAIR,qB;;;8BAMI,sB;oCAE0B,sB;;4BAElB,W;;;;;gCAMQ,S;;gCAGI,K;;;4BAEhB,a;;4BAKK,IAAD,aAAC,gC;8BACT,2B;;8BAGuB,sB;;4BAGX,O;4BAAA,S;4BAEI,IAAA,WAAiB,MAAjB,C;8BACR,IAAmB,cAAnB,U;;gCAEmC,qB;;;;;;;;;;;;;;;;sCA9D/D,oB;;wCAAA,uB;wCAAA,yB;wCAAA,oB;;sCAAA,8C;;;;;;;;;gCAckC,c;gCACP,KHtGP,iBGsGO,C;;;kCAGgC,sB;wCAEnC,IAAa,0BAAb,C;;;;;;;;sCAcI,oB;;;;;;;sCASY,oB;yCACH,E;;;;;;wCAWW,IAAN,U;wCACV,iBAA6B,Q;;;;;;sCAS7B,IAAa,gBAAgB,GAAA,kBAAhB,EAAgB,Q;;;;;;;gCAWrD,+B;gCnB6NJ,Y;;;;;;;;;;;;;wCmBjNA,oB;;;wCAIiB,IAAN,E;;wCAIkB,oB;8CAAE,IAAA,IAAoC,WAApC,C;;;0CACG,oB;;wCAA6B,IAAA,kBAA3B,OAAyC,gBAAd,C;;;wCAClB,mD;;wCAA2B,iBAAzB,O;;;;kCACX,c;;;;kCAJpC,sB;;;8BAE0B,K;;;wBrBxMtB,SAAA,YqByMyC,Y;;wBACrB,iB;;sBrB1MpB,c;;sBqB4MO,aAAkB,CAAlB,C;;uBAID,iBAA0B,wCAAA,eAAuC,EAAvC,EAAuC,CAAvC,C;;;;;;;oBAKN,c;;;;;;oBI1KK,yB;oBpCqNvC,Y;sBgCxCkC,qB;sBhCkDW,UoC/NiB,OJ6KpB,SI7KM,gBpC+NH,S;;;;;;;kBAV7C,iB;kBgCvC6B,iB;oBhCiDgB,gB;;;;;;gBAV7C,Y;kBgCrCI,kB;;;;;YI7KkC,Q;epCkNtC,C;YgCpCI,0B;cAA2C,uBI9KiB,CAAA,IJ2K3B,WI3KU,EAAiB,C;;;;;;;;;YJwKX,kB;UAAjD,qB;;;;;;;IAFJ,a;;;IAAA,mG;IACmC,c;MADnC,e;;;;;IAWA,mG;;;IAsJA,oB;IAEI,aAAM,S;;;;;;EAQV,sC;QACgD,SAAA,IAAQ,O;;YAGC,aAAA,KAAa,gBAAb,K;;EAEzD,kE;IAC0C,mB;;K;G;;IAK1C,mB;aAII,2BAA+B,GAAf,kB;K;;EAIpB,0F;IAEwC,mB;;K;G;;;;;;EexZxC,+C;;;;;;MAUA,Y;SAE8B,6C;MAAR,6F;MAAsB,U;SACxC,yB;MAEA,IAAI,kCAAe,sCAAoD,sBAAnE,C;MACA,UAAQ,E;YAIZ,sBAAO,YAAP,4D;;EAGJ,8C;UAE8B,2F;;EAAA,sCAAR,UAAQ,+CAA1B,cAA0B,C;;IAGtB,UAAQ,Q;;EAIZ,sBAAA,YAAO,UAAP,+BACO,IADP,yI;IAKJ,4B;QAIW,kC;WAAP,Y;MACJ,kD;K;GAVI,I;EAeI,qBAAO,yBAAgB,OAAhB,iBAEP,IAFO,OAGP,oBlC6UsC,yG;QkC1U1C,UAAO,c;IACX,sC;IAEA,mB;aACQ,4C;K;GlCsUsC,EkChV/B,E;EAaX,sBAAa,cAAA,oBAEY,iFAGC,yB;QAE1B,UAAO,c;QAEP,cAAa,MAAb,c;WACI,Y;aAGJ,IAAO,WAAP,4B;K;GAR0B,CAHD,C;EAiBzB,iCAAiB,iI;IACrB,4B;IAEA,sC;WAEQ,Y;aACA,4C;K;GANa,E;EAUT,yDACO,cADP,cAEA,EAFA,C;;IAIA,+BAAe,YAAQ,UAAvB,C;;;;EAKR,2C;IACJ,iB;G;EAGI,sBAAoB,SAAQ,e;WAC5B,qBAAa,8B;G;EAEjB,Y;IAEA,c;IAIW,sD;WAAP,M;;EAGJ,iD;WAEQ,cAAY,+J;G;;QAIZ,I,EAAO,M;QAGX,IAAO,QAAA,+BAA4B,aAA5B,CAAP,I;;IAGJ,wF;IACI,qBAAoB,S;IACpB,gB;;MAGA,IAAI,6BAAc,aAAO,aAAzB,C;QACI,OAAQ,iBAAQ,yBAAA,QAAY,IAApB,IAAQ,6D;OAIpB,yF;;QAGJ,6G;;QAGI,K;;;IAGJ,a;IAEI,KAAI,gB;WACI,gB;;;QAMR,I,EAAO,M,EAAA,M;;IAGX,oC;IACI,IAAI,iC;;MAEA,gBAAQ,WAAR,qB;MACA,6C;QAGJ,K;OAGJ,2E;MAGI,IAAA,eAAO,WAAP,C;;UAGJ,W;;UAGQ,MAAO,0F;;;;MAUf,sB;MACI,2B;MACA,sB;;QpChMJ,iD;QAAA,sB;aAAA,0C;QAOgB,iE;QAAS,oE;;aAPzB,yBAAA,SAQY,SARZ,C;QASgB,SAAM,sBAAA,MAAyB,OAAA,SAAzB,MAAyB,MAAzB,C;;QATtB,oE;QAAA,sB;aAAA,+C;;QqCMA,sB;QxCmBkD,SAAM,cAAA,SAAoB,CAAA,IAApB,EAAoB,iCAApB,C;;QwCfxD,kB;;;;MAKwD,6B;MAAE,0C;;;;MACL,4G;YAAE,kCAA6B,QAAA,KAA7B,OAA6B,KAA7B,4D;;;IACA,wB;IAAA,kB;QAAE,gC;;;MACqB,6C;QAAA,K;uBAEI,e;MAD1E,gC;;;QALR,uE;UAC2C,W;;UrCHjC,M;;;MAAF,IAAE,kB;MANN,IAAI,qB;MACA,uC;QAKA,qB;aqCMmC,IAAA,GAAO,anC8DA,IAAA,SmC9DA,InC8DQ,ImC9Df,C;QrCXnC,yB;aAKE,4C;;aqCYV,+C;QACmD,qBAC/C,I;;QCpBJ,qB;;MAUQ,sC;;QAGJ,K;OAAA,2B;MAAA,sB;;;;;;;;;uCAAA,kC;;;;;QAIQ,sB;QAAA,0E;QAAA,yE;QAAA,oE;;;;;iBAAA,kB;;;;WAAJ,uH;;;UAuBI,kF;;EAER,mC;IAEA,+E;G;MAAA,Y;MAAA,e;MAAA,gB;EAUA,oB;;;;;;;;;;;;;;;oBANQ,kBAAW,I;mBACX,iBAAY,I;WACR,0B;;;4BAAA,I;IAAA,yC;;EAFR,sC;EAMJ,0C;;sBAVA,Y;IAAA,iC;QAAA,Y;;;;;;;IChDJ,kB;G;EAGA,kD;;;;;;G;;;;;iBAFI,wB;IAAA,oC;iBAAA,O;MAAA,6B;;;;;;;;;;;;;;;;;KADJ,4C;;;;IAAA,wC;;;;IAKA,0B;MAAA,0E;KAAA,4C;;;;;;;;gCAAA,iC;;;;;;QASQ,wC;;QAFJ,wB;;;;;;MAOA,iC;;;;;;QACS,wC;aAAA,S;KAAA,0C;;;;IAAL,iC;;;;;;IAKiB,sC;IACF,0B;;EAAA,uD;UAAA,qD;G;;;;;;;;;;;;;;;;;;;;;;;;;UADF,W;;;WAeb,Q;gBArBJ,sD;;WAwBA,U;;;;;;;;;;;;;;;;EACJ,e,qBAEA,iB,cAAA,I,cAAA,e;EAAA,kE;EAAA,yB;EAAA,iD;;;QAAA,qB;;;;;;;;;;;;;;;;;;YAIiB,mB;;kBAAA,gB;kBAAA,gD;;;YACL,kB;UACA,oC;;;UACA,oC;;;;;G;;;;;;;;EAGJ,4C;;;qBAAI,K;;;;G;EACM,yD;;;;;;;;;;;MAEV,0CAAU,O;;;;G;;;;;;;;;;;;;QAblB,qB;;YAAA,oB;sBAAA,K;;qBAAA,gC;gBAeA,K;;;;cCnCQ,oB;;;;;;;cAIR,gB;;;;;kBAKQ,gB;eAAQ,C;;;;;;;;;;;UAShB,O;;UAKI,oC;UAEA,oB;;;;;EAaiC,sB;QAAQ,2D;;;;MAG5B,OAAA,iBAAT,M;;ECmNG,uB,UACH,U,cACmB,c,cDpNF,E;;IA0FjB,wC;;;IE7JR,kC;IAG8B,+B;IAAA,e3C2BqB,S;I2C1B/C,oBAAO,c;;IAGX,0B;;qDAI2B,MAAO,W,cAC9B,I,cACA,CAAW,aAAX,C;;;;;;gBAMqB,Y;;YAAN,MxC0D+B,oBAAQ,mBwC1DvC,E;cAAX,czCuPQ,qB;cyCtPS,MAAA,6BAAhB,oB;;YAGD,IAAI,oBAAJ,qB;cAAkB,I;cAClB,S;;cAEA,YAAe,I;;;;e7CiDnB,C;Y6C9CA,M7C+CO,gB;;Y6C5CX,4C;YAIQ,YAAQ,I;YAAiB,Q;eAC7B,C;YACA,IAAA,IAAW,qBAAX,iB;cAEA,Y;cACA,Q;;YAEI,IAAK,Y;YACY,wE;;cAAN,OxCiC+B,mB;YwCjC1C,Q;eACK,C;YACL,mB;cACA,iB;cAEI,Q;;cACJ,IAAO,Y;;;;e7CyBX,C;Y6CtBA,I7CuBO,kB;;c6CpBX,gB;cAAA,iG;cAAA,0C;gBAAA,0B;cAAA,Q;;;;;;;;;;;;;;;;;;8BACwC,sB;YAAA,iB;;;;;;;;;;;;;;;;;;;;;;YADxC,2D;kBAAA,Y;kBAAA,gD;;;QAEA,uB;UAEA,oC;UAMY,O;;;UAGgB,oB;;;IACxB,a;;EAMgD,sF;IAAA,8F;QACxC,S;MACA,OAAI,Q;;aAGR,Q;G;;;IAPA,qB;IAAA,6B;IACA,qBAAc,C;IACd,IAAI,8B;;IAQR,0B;;EAAA,+B,UAAA,iB,cAAA,I,cAAA,e;EAAA,8B;EAAA,8B;EAOA,oB;;;;;;;;;4BAPA,sE;;;;;;gBACW,IAAI,gB;cACP,oB;cAAA,yB;cAAA,wB;cAAA,gB;cAAA,iB;;;cAEmB,gB;;;;;;;;;;qBAFnB,mB;;;;YADJ,wB;;;;;;;;;;;;;;;;;eADJ,C;kBAAA,gB;kBAAA,gB;;;;YASA,kB;UAAA,qB;UAAA,O;;UAAA,oC;;;;;;;;;;;;;;;EACS,0B;;;EAAA,iG;;;;;;;;EACE,4B;;EAAA,8F;;;;;;;;;;;EAwBX,oD;;QAXA,oB;aAAA,qC;eAAA,8B;;gBAAA,M;;;MAakC,6B;;;;;;;MCtHqB,kB;QACvD,K;MAEA,kB;MAEA,qD;MAEA,mB;;IAIA,oBAAqC,aAArC,a;IAEA,gB;IAEA,gB;G;;QCVQ,I,E9C6BR,M;;;;I8CrBQ,8B;IACA,kB;;;;MALR,uC;UAAA,a;QAAA,iC;cAAA,I;;;;;;;;;;;;;;IACQ,sB;;;;;;;;;;gB9C2HD,Y;;gBAAA,I;;cAAA,gB;c8CzHH,aAAO,gG;;;;;;;;;;;;;;;;YAHX,gB;YAAA,Q;;;;YAW4B,sD;;;YAExB,Y;UAAA,I;;;UALJ,oC;UAAA,oB;;;;;;;;;;;;;;;;IACQ,sB;;;;;;;;;;gB9CmHD,Y;;YAAA,Y;;gBAAA,a;qB8CjHH,mB;;;;;;;;;;;;;;;;;;eAHJ,C;mBAAA,a;kBAAA,gB;;;;;;;;UChBA,YAAQ,GAAA,IAAY,iB;;;;;;ECGxB,a;ICVA,oG;QAGoD,S;;;MA0BhB,OAAA,QAAX,SArB4B,CAqB1C,IArB0C,C;;EAqBoB,uBArBpB,kB;QAAL,I;;MAEhD,sC;QAsBK,MAnBkD,I;OAgBlD,YAHwG,gBAAjD,GAAiD,EAAhE,MAAgE,EAA7B,MAA6B,C;MAGzB,M;YAGzB,uBAAM,cAAW,MAAX,e;;;IAHmB,aAAX,KAAX,sB;IAhBZ,qBAmBmC,I;;IAjBrF,yB;IAmB0D,cAAO,QAhBR,C;IAWrB,oBAAzB,GAAM,M;IAAZ,cAHwG,Q;IAGzB,iBAAtB,W;IAKb,iBAR4D,W;;mDAN7G,iB,cAgBoE,I,cAJzD,e;EAHM,sC;EAH2C,sCAAhB,YAAgD,GAAf,4B;EAGR,sC;;;QAGV,QAAA,IAAM,QAAN,C;eAHvB,C;YAA/B,gBAHwC,GAAG,IAAF,a;YAGsC,cAAtB,4C;YAOV,oBAJiC,oB;YAT/B,ICGgC,Y;;eDAtF,C;YAA2C,MAAkE,gB;;YAE7G,uC;cACoC,IAAX,QAAd,I;cAAN,Q;;YAAD,YAHyG,I;;YAK7G,0C;cACK,OAAM,mB;YAHyB,Q;eAA/B,C;YAA+E,SAAX,a;YAGpE,WAAiC,EAAjC,C;cAAsD,MAAM,6F;YAH7B,gBAAzB,GAAA,IAAM,YAAN,S;YAAN,oBAHyC,GAAA,IAAD,gBAA+C,KAAf,I;YAGO,YAAX,GAAX,C;YAG1D,Q;;YAEJ,M;kBALoC,YAAX,GAAd,C;YAAN,UAHwG,KAGxG,CAH2C,qCAG3C,C;;;YAKsC,YCsBwC,M;;UDpBnF,O;;UAJK,YAAM,wB;UAHyB,gBAAX,GAAd,C;;;IAAyE,a;;EAGnB,0CAAW,mE;QAHxC,WAAX,iF;QAApB,S;MAA+E,e;;MAOvC,OCVyC,uB;G;;WjCxBtF,6C;;EAAA,kCAMiD,UANjD,cAMiD,eANjD,cAU+C,2BAV/C,C;;;IAaA,uD;IAGiD,wD;IAAA,mB;IAAiB,sB;IAAA,gBAAoB,O;IAClF,sB;IAEA,iBAAO,GAAA,iCAAU,EAAH,M;;EAGlB,yDAGoD,UAHpD,cAGoD,sCAHpD,cAGqE,EAHrE,C;;IAII,qCAAc,E;;EAGlB,0C;QAII,MAAO,UAAO,C;;IAGlB,mB;MAGsD,Q;QAAA,c;MAAiB,8B;WAAA,gBAAmB,iL;;EAE1F,qC;IAEA,kC;IAAA,mE;G;wBAEI,mC,0BAAwC,I;;;;IACC,oBAAO,aAAP,CAAgB,8BAAhB,gB;;;;;;;IAH7C,gD;MAAA,+B;YAAA,kC;;EGtC2B,4B,UAwGvB,c,cAxG2D,iB;;;uCAIf,c;;;;;;;;;IPbhD,mC;IjBiBA,qE;;;QAAiE,IAAA,SAAW,iBAAX,Q;QAAA,MAH9B,kB;;;iBAKnC,iG;IAAkE,UAAA,4BAAgB,CAAX,EAAW,CAAQ,MAAxB,E;;;IiBnBlE,6B;IjBqBA,wH;;;QAAmE,IAAA,SAFD,W;;;;IAIE,kBAAA,OAAK,CAAW,CAAX,MAAW,GAAA,KAAQ,CAAA,IAAnB,GAAmB,eAAnB,CAAL,Q;;;;IAEpE,8B;QiBtBI,MjBsB8E,KiBtB1E,aAAQ,Q;QAAe,0B;QjBsBsC,OAFD,QAAK,CAAL,GAAK,YAES,GAFU,CAEV,GiBrBvE,QjBmBiF,MAAnB,CAAL,CAEC,M;;;;IAMjE,UAAA,OAAK,OAAS,KAAT,C;;;IiB/BT,4H;IjBkCA,kC;;;QA6DI,iB;MiB5FA,MjB4FgB,I;QiB5FW,iB;MjB4FtB,SAAA,YiB3FE,SjB2FF,GAAyC,C;IAClD,sB;;;EuDxFA,iD;IAQI,sB;MAAA,U;IACA,sB;MAAA,SpCiDa,oBAAmB,MAAA,I;IoC/ChC,kBAAY,aAAW,MAAX,EAAW,MAAX,EAAgB,MAAhB,CAAZ,C;G;;QpDoIA,iB;MoD3HQ,U;;;;;;;;EpCkDK,0BAAY,cAAO,mB;WoClCjB,WtCzCX,aAAQ,qBAAR,CsCyCW,C;G;EAAf,wCtCxCO,GsCwCP,gB;IACJ,kC;MAEA,qC;WAQI,uD;G;EACA,0B;;EAEY,8BAAW,OAEnB,WAFmB,cpD6FvB,kBoD7FuB,cAIf,WAJe,C;;;QpD6FvB,8BoDtFW,I;UACH,gB;;;EAKZ,sB;IAQI,8B;IAAA,gB;G;EACA,qBpCkDa,CAAA,MAAY,UAAZ,EAAmB,MAAnB,EAAmB,eF/H5B,IE+H4B,OF/HL,gG;WsC+E3B,mBAAa,CAAA,StC9EN,WsC8EM,C;GtC/Ec,CE+HK,CAAnB,C;EoC7CjB,iEAQI,IARJ,OAQI,oBARJ,8E;WASI,oB;GATJ,G;EAc8B,gBAMA,e;WAT1B,SAAY,e;;EAGc,+B;QAAtB,0F;WACI,iB;;;QAKkB,uC;aAAtB,2B;K;;;IAKR,I;;EAUI,uJ;QAAA,0F;WACA,wB;UAAA,OAAA,IpC6Da,K;UFnLb,KsCwHc,StCxHV,gB;QAAuB,+BsCwHb,OtCxHa,C;MsCwH3B,4BAAc,KAAd,C;K;GAHA,E;EAcA,2D;QAAA,c;MACA,uD;YAAA,6BpCuFgC,oB;SoCnFhC,EAAI,WAAJ,C;UpDYA,qD;YoDVQ,6BAAY,CAAA,SAAZ,SAAsD,EAA1C,C;;YpDUpB,8BoDPW,0BpDOX,0F;;G;EoDHJ,M;IAEA,oC;MAQI,yC;QAAA,qB;QACA,+B;MpC2EyB,gCAAO,QAAP,C;WoCzEV,kBtC9JX,OAAQ,MAAR,S;;EsC8JJ,+BAAe,GtC7JR,0D;IsC8JX,oF;IAEA,6G;IAQI,Y;G;EACA,+B;QAAA,epCyEa,MAAY,U;MoCvEzB,uBAAY,SAAa,QAAb,C;QAEZ,OAAI,c;QpD1BJ,+B;MoD4BoB,yC;;;QpD5BpB,gCoD+BW,U;MACS,gD;;;EAGxB,4B;IAEA,gC;IAQI,yD;G;EACA,2B,UAAA,W,ctClMI,W,cAAuB,E;MsCoM3B,4BAAgB,I;EACpB,wC;IAEA,uC;MAQI,sB;KACA,gC;G;EAEA,iBAAY,UAER,UAFQ,cpD9DZ,QoD8DY,cpD7DD,EoD6DC,C;;;QpD9DZ,qBAAA,SoDsEW,KpDtEX,wD;IqD43BkE,arD33BvD,iBqD23BuD,C;;;QDvyBlE,I;ItCzOA,IsC2OgB,GAAA,MtC3OZ,Y;SAAuB,kB,EAAA,KsC2OX,GtC3OW,I,EsC2OQ,K;MAAnC,8BAAgB,KAAhB,C;;;;;QpDvFA,qBAAA,SoD4GW,KpD5GX,wD;IqDk7BgE,arDj7BrD,CqDi7BqD,C;;;;IDh0BpE,+F;IAQI,e;;;QACA,OpCoHa,yBAAc,MAAd,S;IFnYb,IsCiRc,StCjRV,SsCiRU,CtCjRV,WAAQ,KsCiRE,qE;ItCjRa,e;;EsCkR/B,8E;IAEA,qG;G;;;;;;ME3PqC,kD;IAAiC,2BAAe,SAAf,4D;IAAhC,2B;;;;;;;;;;;;;IAAtC,qB;;IACkD,gG;IAAQ,2B;;QAE1D,6E;;;MAAwF,iD;QAAA,W5DIrE,iC;;;;;I4DQf,iC;MACA,iBAAmB,GjDsC2B,C;IiDpC9C,IAAA,KAAO,UAAQ,CAAf,C;MACmB,QAAM,WAAU,OAAhB,wB;QAAA,I,EAAuB,M;QAAtC,uBAAwD,SlDgOrD,KAAK,OkDhOR,EAAwD,SAAxD,6C;QACA,sB;MAEI,oB;WAAiC,YAAQ,C,EAAR,K;QACjC,oD;;;MACQ,SAAA,QAAQ,CAAA,I;MAHpB,qD;QAMkC,sD;;;;;QAalC,iBAAY,W;;IAGpB,qB;MAA0E,kD;;IAM/B,2B;MAAC,2C;;;;;;;;;;;MAE5C,qB;;cAAA,0C;IAAA,YAAsC,sF;;yCAAtC,O;QAAA,W;;;;QAAA,6D;;;;;IjDyUa,IAAA,YAAc,WAAd,C;MAAA,gB;IiDzTL,cAAkB,MAAlB,C;MACI,QAAA,aAAO,GAAO,YAAA,I;IAClB,YAAS,eAAO,SAAP,4D;IjDuTb,2B;MiD1TA,KjD2TA,aiD3TA,EjD2TA,KAAa,QiD3Tb,U;QAQA,KAAO,O;;;MAIP,mBAAc,CAAd,EAAc,OAAyB,QAAvC,EAA+B,SAA/B,C;QACA,iBAAA,MAAuB,CAAvB,OAAuB,oB;;;;;Q/ByKX,iBAAU,M;;QAEC,gB;cAAA,4B;;;uB+BtKnB,C,EAAU,KAAM,Q,EAAA,O;QAChB,eAAA,kBjDpCyC,QAAA,QiDoCxB,YjDpCwC,IAAhB,E;;;yBiDqCnB,C,EAAA,O;QjDsSjB,iBAAA,MiDpSL,CAAA,OjDoSW,eiDpSX,K;;;;;;qBC3DA,C;;cAqBF,gC;;;;;;0BAAA,8B;0BACQ,mB;;cAHV,a;;;eD4CY,a;yBACJ,C,EAAA,gB,EAAA,Y;6BACK,W;4BjD+Rb,qB;QiD3RQ,6D;;;;;;;;Q/BwJQ,gB;;iCAEQ,S;;;;;;WAMhB,e;QAGI,mD;;;;;QAQA,uB;;QAIJ,eAAU,C;MACV,QAAA,MAAU,OAAV,mB;;QACK,sB;;QAET,KAAI,O;;;;;;;;;IlBpOqC,+B;;;;IkByMhB,iC;;ElBkIpB,2CAAc,mB;QAAd,yBAAA,MiDpQQ,ejDoQoB,wB;aiDnQP,4B;eACd,0BAAO,IAAO,0B;;ejDkQ9B,ciDhQY,EjDgQZ,EiDhQY,EjDgQZ,C;mBiDpQiB,OjDqQjB,EiDrQiB,EjDqQjB,YiDrQiB,C;;iBAOL,sC;;;aAEQ,iC;;G;E/B2HI,2F;;;;;;;EAUZ,8E;;WAEI,uB;;;;;EAKJ,4BAAJ,+BAIA,gBAJA,cAKA,EALA,C;;IAMK,kC;;;EAGL,6B+B/JJ,qF;EAiBG,4B;IACX,qB;;EAGQ,4B;WAAkB,IAAO,kBAAP,+C;;;WACQ,gCAAA,MlCnFQ,UAAnB,IkCmFW,UlCnFQ,CkCmFe,M;;EACnC,qCAAiB,e;QAE/B,U;IACA,SAAA,MAAW,KAAM,kCAAjB,I;WAEW,M;G;;WACwB,c;;;;;;QCnGnC,oB;;QACF,kB;MACE,UAAM,Y;;;;QDgGN,I;QASA,EAAA,SAAM,WAAN,C;MACA,mC;MAGJ,MAAO,8BAAA,gBAA4B,EAA5B,C;KAKX,sE;MAAA,qD;KAEI,MAAA,YAAwC,SAAxC,CAAwC,iCAAxC,E;;;;;;;MAFJ,2B;MAAA,4B;MAAA,iD;MAAA,8E;;QAK8B,oB;WAAqB,iB;QAApB,+B;;;MACiB,4B;;kCAC5C,kB;MAA4C,iC;;;;;;;;;;;;IAFhD,qB;;qCAAA,U,4CAMiD,E;;8BAAgD,O;;;;;;;;;;;;;;;;;;EAG/E,mCAAyB,oB;WACvC,mBAAA,KAAqB,SAArB,oJ;G;;;;;kBAQY,gBAAO,CAAA,QAAP,CAAuB,aAAY,WAAnC,CAAO,EAAwC,IAAxC,C;2BAAsE,M;;;oBC/J9E,I;aACH,8B;;;qBADJ,I;;;;sBAmBJ,O;;cD4IyF,K;;;cAI7D,oB;cC7ImC,gB;;gBAtBpD,IDwKQ,M;gBCvKX,UAAA,wBAAe,I;;gBAEf,qB;;kBAHJ,iB;iBAqBF,0B;gBACE,YAAM,mB;;gBAHV,+G;;;;kBD2IQ,U;;oBAeO,U;oBACP,S;sBAEI,SAAA,OAAJ,OAAI,mB;;sB/B+CY,6B;;;;wBAGZ,iBAAQ,SAAR,C;;;;;;sBAOA,6B;8BAAA,uB;;;;gBACI,qC;gBACA,+B;;gBAEI,wB;;gBANZ,+B;;;;;;kBAeK,iB;;;;;;;;;;cAlEC,c;cACA,mB;;cAA2B,qB;cAAzC,wD;;;YAIa,c;;U+BJD,e;UACW,IAAA,KAAiB,MAAjB,C;YAAX,SAAA,mBAAiB,QlDgCV,OkDhCU,C;;YAGD,yB;;cAEI,cACZ,O;cADY,mD;;cC3LrB,kB;cAAA,MDgMY,oC;;;;;cChMnB,Y;;WAsBA,c;;;QAHJ,iB;;;;;;IDiLY,c;QACA,wB;mBACA,M;;Y/BTO,M,EAAA,M;;QAAX,uC;YACA,c;;aAEK,kB;;;;;;;Y+BUN,IAAA,QAAe,UAAf,C;;gBCrLL,wB;gBACQ,8B;;;;gBDuLN,kB;gBACM,gBAAa,KAAA,qBAAA,wBAAwC,OAAc,I;gBAEnE,+B;;;;kBElQwB,Y;qBAAC,mB;kBAA+B,Y;;;;;;;0BAAtE,4C;;;;;;;cAAA,SAAA,mBAAuC,kB;;;cAAA,Y;;0BAAvC,gC;eAAuC,W;gBAA+B,oC;;;;;;YAEtE,mB;cACQ,K;;YAMA,SAAgC,O;;UACrB,iBAAc,CAAd,C;;UAEP,IAAO,SAAP,C;;;;;KASO,yB;;;;MAEH,S;IAFZ,WAAA,MAGE,6B;IAEF,S;MACA,IAAO,mE;SAEC,I;UACA,UAAS,gBAAU,8C;UACf,OAAO,U;;;MAKf,U;;QAGJ,U;QACA,IAAO,iBAAP,0C;;;UAGQ,MAAI,GAAK,aAAU,WAAV,uD;YACL,UAAO,M;;;YAKf,2B;;;;;;MDsBF,uC;aACE,I;YAHJ,oB;;;;IEzEJ,qC;IACI,IAAI,cAAa,6B;;EpDqaR,mBAAM,UAAN,WAAM,cqDqDX,UrDrDW,iB;MoDlaX,oBAAS,I;;IAET,+B;MACI,c;YAEI,iB;;;IpD6ZZ,YoDzZI,Y;IAVJ,IpDoaA,Y;;EoDvZJ,W;IAEA,mC;;EAEA,W;;;EEfA,wDAYI,aAZJ,wB;EAAA,+C;WAeQ,IAAO,K;G;EAff,qD;WAmBQ,gBAAa,IAAb,+B;G;EAnBR,6C;IAAA,6D;G;EAAA,W;QAAA,U;IAW2E,qD;;;EAoB7C,gD;WAAA,2K;G;;;IAR9B,gC;IAQI,2B;;IChC2C,qC;;EAI3C,qBAAgC,qDAEhC,Y;WAEA,sB;GAJgC,E;;;;sECJpC,yB,cACI,W;;IAIA,cAAA,gBAAgC,UAAA,aAAO,WAAP,Q;IAEhC,yBAEA,WAFA,C;IAIA,0C;IAEA,Q;;;;;;QCdoC,mB;UAAmB,yB;SAGvD,oB;QAEA,Y;;;;;;;;gBCTJ,oB;gBAAA,U;gBAAA,8D;gBAAA,wB;;gBAAA,0E;kBAAA,iC;;kBACI,U;;oBAEA,U;;;;sBAFA,M;;;;oBAAY,gC;sBAAA,6H;;;;kBAEZ,4B;;kBAIqB,wH;kBACH,yB;kBACC,U;;oBAIE,IAAK,M;;+BAGtB,qC;;;;;;;;;sBAbJ,S;;kBAAA,8B;;gBAAA,iB;;;;;;;gBAHJ,wD;;;;;YAAA,O;YAAA,gB;cAAA,4C;;cAAA,yB;cAAA,Y;;;eCYe,W;gBAAA,kB;gBAAA,0C;;gBAAS,gB;;;YAGL,YAAgB,IAAhB,C;;aAID,c;YzEyEV,OyEzEkC,O;;UzE0E5B,iB;;;;;;;MyExFd,yB;;UAAgE,kB;UAAA,IjCgEX,gB;UiC/DnC,MACJ,iC;UADV,IAAA,MAAc,QAAd,C;YAEI,qB;;;;cAIJ,wB;cAYoC,IAAd,O;cAAsB,oE;cAArC,0B;;;;;;;;;kBCtBX,W;;oB9DFA,+C;;oBAAA,kC;;kBAOyB,qB;;kBAPzB,kC;oBASgB,MAAM,2H;;oBATtB,S;;gBAAA,+B;;c+DIA,oB;cAA2C,iB;;cAAiB,c;cAAc,IAAI,KAAJ,C;gBAClE,K;eAIK,iB;cACC,M;cACN,IAAA,MAAqB,QAArB,C;;eAIqC,mB;;cAAiB,S;;YAAkB,a;;YAEjE,c;cAGF,0BAAc,SAAd,C;;;;OAMoC,mC;;UAAqB,6B;cAAA,4BAAmC,0BAAnC,+D;;cAE9D,G;;IAIJ,IAAI,cAAM,EAAV,K;MACI,uBAAqB,uCAArB,uE;KAIR,oB;;MAA+C,4B;MAAiB,oB;;IAMvC,sB;IALrB,IAAI,8B;;EAKG,+DAGX,oBAHW,cAIsC,EAJtC,C;;WAIuD,sB;;EAC1D,sD;WACA,IAAO,c;G;;W3C2LG,gK;;EAAA,oD;WAAA,uC;G;EAAd,4B;;;aAIa,WAAM,sC;;;E2C1Lf,4B9DuNG,OAAK,oB;W8DtNM,cAAd,KAAO,KAAO,SAAY,KAAO,YAAc,aAAU,KAAA,MAA3C,eAA2C,sKAA/B,CAA1B,C;G;;;a3C4LI,6B;;;iBACA,a;UACA,WAAU,iB;eACV,yC;;;WAGJ,oB;;;;;M2C7LJ,IAAO,a;;MAGX,4B;IACqD,yD;QAAA,sB;IAAqB,uB;;QAClE,mE;QACA,IAAA,IAAO,wBAAP,C;UAGJ,gD;;;M3CuKc,iC;;IAA2B,e;WAAzC,WAAc,I;;;YAID,aAAM,iB;U2CzKA,WAAM,kBAAN,C7DI0B,M6DJ1B,E7DI0C,W6DJ1C,C;;;MAEf,iC;;;;M3C2Ke,+B;;UAAgC,a;kBAA3C,uB;;cAEA,C;;UACK,sD;;;QAGL,oB;;;;I2C7KR,WAAO,oBAAP,mC;;IAGJ,qE;IAEqB,kB;IAAjB,SAAO,iBAAP,EAAO,KAAU,UAAjB,EAAiB,OAAjB,C;;MAGJ,oB;QACQ,2B;OACJ,sD;;Q3CqJc,e;IADd,yB;WACc,uB;;;UAAd,qH;;;;M2C9IJ,oB;;;;IAKI,sD;;EAHJ,mD;I/D1FI,IAAI,K+D2FI,O;I/D1FJ,kC;IAKE,iB;I+DyFN,qBAAO,GAAA,SAAU,c;;G;EAID,6CACZ,UADY,cACY,0BADZ,cAEmB,EAFnB,C;;IAGhB,gB;IACA,SAAO,O;;IAGX,qB;IACI,qBAAgB,I;IAChB,IAAI,oBAAJ,I;IAAqB,gB;;E9DoKV,8C8DlKX,U9DkKW,c8DjKJ,2B9DiKI,iB;E8D9Jf,kC;IACI,kB;IACA,IAAI,iB;IAAiB,kB;IACV,aAAwB,I;IAAnC,eAAiB,O;G;;;;IC9Gb,iB;IAAQ,uB;;;IAEA,mC;K;;;IAYZ,iC;;MAoBI,6B;;;IAEA,oC;;;;;IAYA,OAAO,gC;;;IAMP,4B;;iCAGJ,C;IAGI,UAAO,sB;;;IAMP,aAAO,oH;;EAGX,yC;WAGI,IAAO,S;;0CAMP,W;MAMA,+BAAsB,I;EAC1B,2C;;IAKI,IAAA,4BAAsB,KAAf,IAAP,C;;KAMA,OAAO,4B;G;gCAMP,U;;;;EAYO,mC;EACX,iC;;WAKW,Y;;;QAMP,OAAO,mCAA2B,E;uBAGtC,0D;;G;;;;EhE9IJ,0DAOgB,WAPhB,cAOyB,EAPzB,C;EASsB,oCAAA,MAAyB,wC;EACnC,uB;EAVZ,kD;IAAA,sC;IAAA,gC;G;EuDQ6B,wC;UA2VzB,6B;;;;QAvVyC,gBAAO,C;;;;;aAEf,Y;;;;;;;MAU7B,U;QACI,MAAI,W;MACA,SAAM,2B;;;KAKN,yD;IAAR,IAAA,EAAwB,WAAxB,C;;;EAKJ,8D;;MAIK,U;IAAgB,IAAA,UAAhB,WAAgB,C;;;MAKT,2D;;;MAKA,oB;M;EAOa,0D;IAAE,sB;;IACoB,sB;MAAE,MAAM,0B;;;MAElD,uD;YAL2B,gBAAM,YAAsB,iCrDoBf,oBqDpBP,ErDoBuB,MqDpBvB,ErDoBuB,MqDpBvB,C;G;;IvDjDtC,IAAI,MuDmDQ,WvDnDZ,C;MACI,U;QAKE,iB;MANN,MuDoDY,GAAA,uBAAuB,I;QvDnD/B,uC;MAKA,OAAE,gBAAF,gC;;;MuDsDI,gB;MAAoB,kB;MACxB,OtD0MG,oBsD1MsB,YtD0MjB,CsD1MiB,C;MACR,IAAA,IAAhB,QAAgB,C;QACjB,qB;;;;;kBAQJ,8C;;UAE4B,eAAA,MAAhB,U;;0BAGZ,4B;;YAEqB,K;;UAIjB,MAAU,GAAA,mBAAY,oB;UAClB,IAAO,MAAP,S;YAAkB,K;;;UAKX,UAAJ,I;;;;QAIP,IAAU,OAAV,C;UAEI,kB;;;;;;;IAMJ,0B;;;MASC,U;IAAgB,IAAA,aAAhB,0BAAgB,C;;KAShB,sBAAgB,CAAhB,C;;MAKO,gB;MAAR,IAAwB,c;;;QAKhB,qB;;;;UAKgB,aAAhB,O;;+BAGZ,a;;UAE4B,SAAA,MAAhB,OAAgB,EAAhB,GAAgB,EAAhB,mBAAgB,EAAhB,QAAgB,EAAhB,WAAgB,G;;;;;uCAQ5B,S,EAAA,O;;YAEqB,K;;;UAKA,OAAhB,O;;;;QAKA,Y;UAAgB,kBAAhB,oB;;;;IAKgB,OAAA,WAAhB,E;;;IAKA,Q;IAAgB,OAAA,YAAhB,gDAAgB,IAAhB,GAA+B,QAAQ,EAAvC,EAAuC,MAAvC,S;;;IAKO,4C;MAAR,MAAwB,6BAAhB,kCAAA,SAA8B,UAAd,SAAhB,sC;;;;;MAUA,I;MAAR,IAAwB,YAAxB,C;;OAKQ,kB;;;6CAGZ,G,EAAA,qB,EAAA,M;;YAE4B,WAAA,MAAhB,W;;;WAKgB,e;;;;;;;;QAUA,a;;;;;;;;;;0CAa5B,0B;;;EAGA,sD;;MAIK,kE;MAAgB,U;gDAGrB,2B;G;;;;MAOK,S;IAAgB,QAAA,MAAhB,qB;;;IAKA,W;;EACL,0D;;IAIK,0B;MAAgB,S;;eAGrB,2D;IAEK,Y;IAAgB,W;G;;IAKhB,mC;IAAgB,sBAAhB,EAAgB,E;;;IAKhB,sE;IAAgB,wBAAhB,GAAgB,EAAhB,MAAgB,EAAhB,IAAgB,C;;;;;EAMrB,M,wEAIK,Y;WAAgB,gCAAhB,E;G;QAKA,Q;MAAgB,MAAA,6BAAhB,gC;;EAIL,+G;IACA,sB;;QAOW,c;MAHP,Q;QACA,c;MAGI,8B;WAAiC,qK;G;EACkC,eAAP,UAAO,e;;G;EAFvE,e;IAKJ,sB;;EAOW,e;WAHP,gB;;EAII,yBAAiB,e;WAAS,iB;G;EACkC,eAAP,W;;;EAFzD,e;IAKJ,8C;;EnExOJ,mE;WmE0OI,uC;G;EAQI,eAAS,kB;WnExOb,Y;;EAEU,mE;WmEwON,mBAAQ,GAAR,iB;G;;;;EnEpPR,mE;WmEwPI,uC;G;EAQI,eAAS,kB;WnEtPb,Y;;EAEU,wCAAsB,+B;WAFhC,gBcX8C,YAAQ,MAAR,EAAQ,MAAR,C;G;EdapC,wCAAsB,+B;WmEuP5B,2C;G;;;;EAKA,qC;IACJ,kD;;EAGI,eAAM,wD;IACV,kD;G;EAGI,qCrDtRyC,kC;;G;EqDwR7C,qC;WAUI,gBAA0B,mB;;EAG1B,eAAoC,kBAAS,kC;WAE7C,uC;G;EAsCA,iCAAoD,kC;;G;;WA7ChD,Y;;;;;EAUoD,qC;;;EAEhD,eAAO,sBAAS,kC;IACpB,kD;G;EAGyC,8BAAxB,qB;W1D7SzB,Q0D8SgB,c;G;EADJ,gB1D5SL,sC0DqT2C,O1DrT3C,c0DqT2C,W1DrT3C,C;E0DqT6C,mF;;;IACP,sC;IAAE,gC;;;UAH7B,qD;;EvD3Xd,6CAKE,UALF,cuD8XgB,uBvD9XhB,C;;;;;EuDkYQ,0CAAiB,WAAjB,EAA+B,eACtB,IADsB,mB;;GAAA,CAA/B,C;oFAKyC,Y;WAAS,kB;G;wEAE3C,I;;;;;;;;;;;;;EA7CnB,sE;QAAA,I;IAAA,yF;G;;;;;;IAyDJ,Q;WAA8C,qF;;;WAAiB,2B;;;IAEvD,MrDRiC,8BqDQ7B,ErDR6B,C;;EqDY1B,sE;QrDZX,I;SACA,sC;;SqDgB8C,uB;YAAA,6B;QAAiB,c;UAAA,QAAc,wBAAd,CAAc,yBAAd,C;MrDjBtD,U;SqDmBL,ErDnBiC,yBqDmB7B,GAAe,WAAnB,C;UACI,MAAM,6BAAa,2BAAb,C;MAGH,UAAP,E;KrDtBJ,kCAAa,IAAb,+E;G;EqD2BJ,0E;QAAkD,I;QAAA,0D;QAAiB,mB;aAAA,E;QAC/D,OrDhD0C,iC;IqDgDnB,uF;WACR,I;G;EACf,uCAAuB,+B;QACvB,I;IACJ,Y;G;EAEsD,wC;QAAA,I;WAAiB,6F;;ErDtDzB,oCAAgB,0B;QqDuD1C,I;IrD/W6B,aAAA,2BAAgB,MAAhB,CAAgB,oBAAhB,c;G;EqDiX7C,iCAAe,8B;QACf,MAAO,aAAP,8C;IACJ,gB;MAEA,iF;WAA+C,I;G;EAAiB,iC;WAAA,OAAc,IAAI,wE;;ErDzBrE,kBAAc,6C;QqD2BnB,MrD3BkC,YqD2B9B,IrD3B8B,EqD2Bf,GrD3Be,EqD2B9B,KrD3B8B,EqD2B9B,GrD3B8B,C;QqD4B9B,QAAM,G;YAGN,2E;WrD/BR,I;G;EqDkCJ,Q;IAEA,Q;IAAmD,iE;WAAA,I;;EAAiB,kBAAkB,cAAa,oC;QrDpCtF,I;IAAA,aAAA,MAAc,4BAAd,4C;G;EqDuCD,kBAAM,gD;QAGN,I;IrD1CR,0F;G;EqD6CJ,Q;;WrD7Ca,WAAM,wD;;EAAf,kBqDqDU,QAAO,e;QrDpDjB,I;WqDmDA,S;G;;QrDrES,I;WAAA,WAAc,wD;;EACvB,4C;QqD8EA,I;IAGJ,2E;G;EAGA,oC;QAAA,I;IrDpEa,YAAA,MAAM,4BAAN,0C;;EAAA,oCAA6B,kC;QAAtC,I;IACA,wF;G;;;;;EqD6EJ,oC;QrD/Fa,I;IAAA,YAAA,MAAc,4BAAd,0C;;EAAT,kBqDqGI,kBAAM,GAAU,+B;QrDpGpB,I;IACO,yF;G;;;;;E+D7YH,wC;IACJ,Q;2BAEA,kC;;EAIA,Q;;WAKI,e;;EAGJ,0E;QAGI,I;IACJ,mG;G;EAKI,wC;IACJ,Q;2BAGA,sD;;EAIA,Q;;WAKI,eAAW,CAAA,MAAK,OAAQ,qBAAb,0C;;EAGf,0E;QAGI,I;IACJ,oG;G;EAKI,oCAAwB,kB;IAC5B,Q;oBAEA,qD;G;EAIA,Q;;WAKI,WAAA,MAAW,OAAK,CAAA,IAAQ,OAAR,SAAhB,qB;;EAGJ,qD;QAGI,I;IACJ,Y;G;EAOI,kBAAQ,iB;IACZ,Q;;;;;;;;;ICnFJ,wE;;EAAoC,qC;QAChC,I;;;ECHA,kBAAO,mBAAe,kC;IAC1B,Q;IAEA,yF;G;EAEI,kBAAU,mB;QACV,I;IAEO,aAAA,MAAP,OACQ,CAAA,IAAQ,GADhB,IACQ,EAAgB,MAAhB,CADR,oBAAO,sB;;;QAKP,I;IACA,wCAAkB,MAAlB,2C;;EAEJ,Q;IAEA,Q;IACI,aAAA,MAAqB,QAAA,IAAP,OAAO,EAAP,MAAO,CAArB,0C;;EAEA,kBAAU,mB;QAEV,I;IACY,cAAA,MAAQ,OAAR,+D;;EACgC,kB;QACxC,I;;;EAIJ,kD;QACA,I;IACJ,M;G;EAMU,kBAAU,kB;Q/EoDZ,I;IACM,YAAA,2BAAsB,MAAtB,CAA8B,oBAA9B,I;;EADN,sC;QACA,I;I+EnDE,cAAA,MAAS,OAAT,QAAmB,IAAnB,EAAuB,MAAvB,mC;W/EkDF,M;;E+EbA,kB;;EANJ,kBAAY,4B;QACZ,I;QACU,gC;QAAI,gBjEA+B,kB;QiEA7C,YAAU,KlEkMH,a;MkEhMP,uD;SAAO,IAAA,YAAI,MAAJ,gD;;;;;G;;QAKP,I;QACA,gBAAe,kB;QACf,QAAS,IAAI,M;QACb,uB;MAzCA,OA2CO,8BA3CP,kB;;MAGJ,uB;;M/E6CQ,oBAdW,cAcX,2C;WACA,I;;EADA,qC;QACA,6BAAM,MAAsB,OAAQ,mC;WAFpC,iB;UACA,OAAA,iBAdW,E;UAeX,KAAA,KAAM,M;UAFV,EAAA,E+EtCM,K/EsCN,C;YACI,+E;cACA,0BAAM,CAAA,OAAsB,SAAQ,EAA9B,C;O+ErBV,oBAAmB,I;aACnB,E;K;;EAEc,kBjEA+B,oBAAgB,GAAA,oBAAhB,sG;QiEA7C,6BApB4E,MlEsNhE,OkElMZ,mC;WAEA,iB;UAAO,0B;;YACC,O;;;WACJ,8C;;QAGJ,sD;OAEA,0BAAmB,I;aACnB,E;K;GjEV6C,E;EiEjBjD,qD;IAmCI,kBAAmB,IAAnB,C;G;EAEA,uC;UnD2GA,kCAA4C,0C;G;EAExC,kB;WACS,oB;;;Id7HiC,kC;IiEoBhC,kBAAgC,qB;IAA1C,oBlEyKQ,mC;IkEvKR,qE;IAAO,0D;;qBjBu1B8C,+B;;qFiBr1BjD,I;WAGJ,C;;;IAIA,gC;;;WnD+FI,aAAO,4BAAP,6B;;;QAGJ,YAAA,WAAe,UAAf,2C;;ImD7FJ,iB;WAzDA,S;;EAGJ,yF;I/E6BI,O+E5BM,Y;a/E6BF,8D;K;G;;I+EGJ,uE;;;InD6GI,qB;UACS,uB;UmD3GH,yG;MACN,U;WACU,QAAgC,e;UAA1C,UlEyKG,wBkEzKH,iE;MAEA,Y;;;IArCmB,2CAAoB,iB;;;oFA0CvC,a;;IAGM,qB;;EjE9B4C,iDAAR,OiEiC1C,e;;G;;;;8DAGJ,U,cACO,Y;EAnDX,kB,8ClEoMA,W,ckElMA,E;MAWQ,kC;;QANJ,2BAAY,S;MACZ,wB;YACc,2B;;EAEd,6BAEI,UAFJ,sCAKA,cAAa,MAAb,QALA,C;;QAOA,MAAS,KAAI,KAAM,C;MACnB,U;QAEA,MAAO,W;;;gBAGX,sB;IlE4KA,mD;MenEA,iF;KmDzGA,4C;QAGI,W;IACA,8BAAQ,I;;;;MnD8GJ,U;QACS,gBAAM,C;MmD3GT,0BAAW,MAAX,I;iBACN,S;gBACU,SAAU,a;SAAsB,+B;YAA1C,iBlEyKQ,qCkEzKR,qB;KAII,4C;;IAGJ,8BAAW,I;;;QAIX,iB;;;MnD+FI,SAAA,GAAO,oBAAiB,GAAjB,C;;;QAGX,wD;;ImD7FJ,8C;WACA,Q;;;ICjHJ,sB;MAK2C,U;QAAA,MlCGzB,W;MkCHsC,oC;QAAA,EAAA,SlCItC,ckCJsC,0B;MAAa,S;QAAA,IAAA,SlCK9C,iBAAS,SAAT,akCL8C,I;IACjE,IAAI,WAAA,MAAc,aAAc,CAAd,C;IACd,wBAAqB,GAArB,mB;WAGJ,Q;;EAqBJ,uD;IAEA,sB;MAK6B,M;IAJzB,eAAa,MAAb,C;MhFPA,MgFQQ,GAAA,uBAAsB,GAAI,C;QhFP9B,SAAA,SAda,O;QAeb,YAAM,uB;SgFQV,eAAe,Y;MACf,qCAAyB,iCAAzB,qB;;;IC5CiC,mC;G;EjBsCrC,kB;G;EAAgD,gB;IAGxC,mBAAW,CAAX,C;;EAEA,gBAAW,iBAAgB,gB;IAAW,iBAAM,CAAN,C;G;EAEtC,kCAAgC,GAAO,a;IAG5B,kBAAJ,CAAI,C;G;EAKnB,M;;;EAsBA,oC;IApBA,sB;;;IAEe,wC;;EACH,qE;;G;;IADJ,wC;;EAqBF,qE;IACE,cAAM,IAAN,EAAM,GAAN,EAAM,MAAN,EAAM,MAAN,C;G;;;;;;;EAJR,mC;IAVA,gC;;;IAEe,kB;;EACH,uDAEA,QAFA,sC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAhEmB,Y;EAAA,+BAC/B,GAAO,Y;EAqByB,gC;EvDsD5B,qBuDpDa,kF;EvDoDb,YuD9CI,mB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}